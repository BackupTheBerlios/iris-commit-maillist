<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Iris-commit] [IRIS] r1325 - in /trunk: include/SortedOverlayContainer.h include/builder.h include/luabind.h src/SortedOverlayContainer.cpp src/builder.cpp src/data.cpp src/gfx2D_L.cpp src/profile.cpp src/scripting.cpp src/spritemanager.cpp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/iris-commit/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:iris-commit%40lists.berlios.de?Subject=Re%3A%20%5BIris-commit%5D%20%5BIRIS%5D%20r1325%20-%20in%20/trunk%3A%0A%20include/SortedOverlayContainer.h%20include/builder.h%20include/luabind.h%0A%20src/SortedOverlayContainer.cpp%20src/builder.cpp%20src/data.cpp%20src/gfx2D_L.cpp%0A%20src/profile.cpp%20src/scripting.cpp%20src/spritemanager.cpp&In-Reply-To=%3C20070802002721.1A1301058006%40localhost.localdomain%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000138.html">
   <LINK REL="Next"  HREF="000144.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Iris-commit] [IRIS] r1325 - in /trunk: include/SortedOverlayContainer.h include/builder.h include/luabind.h src/SortedOverlayContainer.cpp src/builder.cpp src/data.cpp src/gfx2D_L.cpp src/profile.cpp src/scripting.cpp src/spritemanager.cpp</H1>
    <B>no-reply at zwischenwelt.org</B> 
    <A HREF="mailto:iris-commit%40lists.berlios.de?Subject=Re%3A%20%5BIris-commit%5D%20%5BIRIS%5D%20r1325%20-%20in%20/trunk%3A%0A%20include/SortedOverlayContainer.h%20include/builder.h%20include/luabind.h%0A%20src/SortedOverlayContainer.cpp%20src/builder.cpp%20src/data.cpp%20src/gfx2D_L.cpp%0A%20src/profile.cpp%20src/scripting.cpp%20src/spritemanager.cpp&In-Reply-To=%3C20070802002721.1A1301058006%40localhost.localdomain%3E"
       TITLE="[Iris-commit] [IRIS] r1325 - in /trunk: include/SortedOverlayContainer.h include/builder.h include/luabind.h src/SortedOverlayContainer.cpp src/builder.cpp src/data.cpp src/gfx2D_L.cpp src/profile.cpp src/scripting.cpp src/spritemanager.cpp">no-reply at zwischenwelt.org
       </A><BR>
    <I>Thu Aug  2 02:27:18 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000138.html">[Iris-commit] [IRIS] r1324 - in /branches/knut/data/lua: net.customhouse.lua net.walk.lua net/net.mobile.lua net/net.multi.lua
</A></li>
        <LI>Next message: <A HREF="000144.html">[Iris-commit] [IRIS] r1326 - in /branches/knut/src: builder.cpp scripting.cpp spritemanager.cpp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#143">[ date ]</a>
              <a href="thread.html#143">[ thread ]</a>
              <a href="subject.html#143">[ subject ]</a>
              <a href="author.html#143">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ghoulsblade
Date: Thu Aug  2 02:27:17 2007
New Revision: 1325

Log:
cpp and header files from knut merged

Modified:
    trunk/include/SortedOverlayContainer.h
    trunk/include/builder.h
    trunk/include/luabind.h
    trunk/src/SortedOverlayContainer.cpp
    trunk/src/builder.cpp
    trunk/src/data.cpp
    trunk/src/gfx2D_L.cpp
    trunk/src/profile.cpp
    trunk/src/scripting.cpp
    trunk/src/spritemanager.cpp

Modified: trunk/include/SortedOverlayContainer.h
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/include/SortedOverlayContainer.h (original)
+++ trunk/include/SortedOverlayContainer.h Thu Aug  2 02:27:17 2007
@@ -25,6 +25,10 @@
 	=

 	void	SetRankFactor		(const int iRankFactor);
 	int		GetChildRank		(Ogre::OverlayElement* elem);
+	void	ChildBringToFront	(Ogre::OverlayElement* child);
+	void	ChildSendToBack		(Ogre::OverlayElement* child);
+	void	ChildInsertAfter	(Ogre::OverlayElement* child,Ogre::OverlayElement* =
other);
+	void	ChildInsertBefore	(Ogre::OverlayElement* child,Ogre::OverlayElement*=
 other);
 	=

 	/** Adds another OverlayElement to this container. */
 	virtual void addChildImpl(Ogre::OverlayElement* elem);

Modified: trunk/include/builder.h
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/include/builder.h (original)
+++ trunk/include/builder.h Thu Aug  2 02:27:17 2007
@@ -64,7 +64,7 @@
 bool	GenerateMapMaterial					(cGroundBlockLoader&amp; oGroundBlockLoader,cRada=
rColorLoader&amp; radarColors,const char* szMatName,const bool bBig);
 bool	GenerateArtMaterial					(cArtMapLoader&amp;	oArtMapLoader	,const char* sz=
MatName,const int iID,const bool bPixelExact,const bool bInvertY,const bool=
 bInvertX,const bool bHasAlpha,const bool bEnableLighting,const bool bEnabl=
eDepthWrite,cHueLoader* bHueLoader,const short bHue);
 bool	GenerateTexMapMaterial				(cTexMapLoader&amp; oTexMapLoader	,const char* =
szMatName,const int iID,const bool bHasAlpha,const bool bEnableLighting,con=
st bool bEnableDepthWrite,const bool bPixelExact,cHueLoader* bHueLoader,con=
st short bHue);
-bool	GenerateGumpMaterial				(cGumpLoader&amp; 	oGumpLoader		,const char* szMa=
tName,const int iID,const bool bHasAlpha,cHueLoader* bHueLoader,const short=
 bHue);
+bool	GenerateGumpMaterial				(cGumpLoader&amp; 	oGumpLoader		,const char* szMa=
tName,const int iID,const bool bHasAlpha,cHueLoader* bHueLoader,short bHue);
 bool	GenerateAnimMaterial				(cAnimLoader&amp; oAnimLoader		,const char* szMat=
Name,const int iID,const int iAnimID,const int iFrame, int&amp; iWidth, int&amp; iH=
eight, int&amp; iCenterX, int&amp; iCenterY, int&amp; iFrames, cHueLoader* pHueLoader, =
short iHue);
 bool	GenerateUnicodeText					(const Ogre::UTFString&amp; sText, const Ogre::UT=
FString&amp; sFont, Ogre::RenderOperation&amp; RenderOp, const uint8 bRed, const ui=
nt8 bGreen, const uint8 bBlue, const uint8 bAlpha, const int iMaxWidth);
 =


Modified: trunk/include/luabind.h
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/include/luabind.h (original)
+++ trunk/include/luabind.h Thu Aug  2 02:27:17 2007
@@ -515,7 +515,7 @@
 }
 =

 // increments index : +1 if table, +4 if 4 floats
-inline Ogre::ColourValue luaSFZ_checkColour4 (lua_State *L,size_t&amp; index) =
{ PROFILE
+inline Ogre::ColourValue luaSFZ_checkColour4 (lua_State *L,const int index=
) { PROFILE
 	if (lua_istable(L,index)) {
 		/*	void lua_rawgeti (lua_State *L, int index, int n);
 			Pushes onto the stack the value t[n], where t is the value at the given=
 valid index index.
@@ -527,11 +527,11 @@
 		lua_rawgeti(L,index,1);
 		Ogre::ColourValue res(luaL_checknumber(L,-1),luaL_checknumber(L,-2),luaL=
_checknumber(L,-3),luaL_checknumber(L,-4));
 		lua_pop(L,4); // clean stack
-		index +=3D 1;
+		//index +=3D 1;  old... should not be used anymore
 		return res;
 	} else {
 		Ogre::ColourValue res(luaL_checknumber(L,index),luaL_checknumber(L,index=
+1),luaL_checknumber(L,index+2),luaL_checknumber(L,index+3));
-		index +=3D 4;
+		//index +=3D 4;  old... should not be used anymore
 		return res;
 	}
 }

Modified: trunk/src/SortedOverlayContainer.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/src/SortedOverlayContainer.cpp (original)
+++ trunk/src/SortedOverlayContainer.cpp Thu Aug  2 02:27:17 2007
@@ -2,6 +2,7 @@
 #include &lt;OgreOverlayElementFactory.h&gt;
 #include &lt;OgreOverlayManager.h&gt;
 #include &lt;OgrePrerequisites.h&gt;
+#include &lt;algorithm&gt;
 =

 =

 using namespace Ogre;
@@ -44,6 +45,36 @@
 =

 void	cSortedOverlayContainer::SetRankFactor		(const int iRankFactor) {
 	miRankFactor =3D iRankFactor;
+	_notifyZOrder(mZOrder);
+}
+
+void	cSortedOverlayContainer::ChildBringToFront	(Ogre::OverlayElement* chi=
ld) {
+	mlSortedList.remove(child);
+	mlSortedList.push_back(child);
+	_notifyZOrder(mZOrder);
+}
+
+void	cSortedOverlayContainer::ChildSendToBack	(Ogre::OverlayElement* child=
) {
+	mlSortedList.remove(child);
+	mlSortedList.push_front(child);
+	_notifyZOrder(mZOrder);
+}
+
+void	cSortedOverlayContainer::ChildInsertAfter	(Ogre::OverlayElement* chil=
d,Ogre::OverlayElement* other) {
+	mlSortedList.remove(child);
+	std::list&lt;OverlayElement*&gt;::iterator itor =3D find(mlSortedList.begin(),m=
lSortedList.end(),other);
+	if (itor !=3D mlSortedList.end()) =

+			mlSortedList.insert(++itor,child); =

+	else	mlSortedList.push_back(child);
+	_notifyZOrder(mZOrder);
+}
+
+void	cSortedOverlayContainer::ChildInsertBefore	(Ogre::OverlayElement* chi=
ld,Ogre::OverlayElement* other) {
+	mlSortedList.remove(child);
+	std::list&lt;OverlayElement*&gt;::iterator itor =3D find(mlSortedList.begin(),m=
lSortedList.end(),other);
+	if (itor !=3D mlSortedList.end()) =

+			mlSortedList.insert(itor,child); =

+	else	mlSortedList.push_front(child);
 	_notifyZOrder(mZOrder);
 }
 =


Modified: trunk/src/builder.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/src/builder.cpp (original)
+++ trunk/src/builder.cpp Thu Aug  2 02:27:17 2007
@@ -275,7 +275,7 @@
 =

 =

 /// WARNING ! changes size to 2^n where n &gt;=3D 4
-bool	GenerateGumpMaterial	(cGumpLoader&amp; oGumpLoader,const char* szMatName,=
const int iID,const bool bHasAlpha,cHueLoader* pHueLoader,const short iHue)=
 { PROFILE
+bool	GenerateGumpMaterial	(cGumpLoader&amp; oGumpLoader,const char* szMatName,=
const int iID,const bool bHasAlpha,cHueLoader* pHueLoader,short iHue) { PRO=
FILE
 	cGump *gump =3D oGumpLoader.GetGump(iID);
 	if (gump =3D=3D 0) return false;
 	int iImgW =3D gump-&gt;GetWidth();
@@ -290,9 +290,17 @@
 	short *pImgRaw =3D new short[iTexW*iTexH] ;
 	memset(pImgRaw,0,2*iTexW*iTexH);
 	if( iHue &amp;&amp; pHueLoader ) {
-		cHueFilter Filter;
+		bool PartialHue =3D (iHue &amp; 0x8000);
+		iHue =3D iHue &amp; 0x7FFF;
 		short* ColorTable =3D pHueLoader-&gt;GetHue( iHue-1 )-&gt;GetColors();
-		gump-&gt;Decode(pImgRaw,iTexW*2,Filter,ColorTable);
+
+		if (PartialHue) {
+			cPartialHueFilter Filter;
+			gump-&gt;Decode(pImgRaw,iTexW*2,Filter,ColorTable);
+		} else {
+			cHueFilter Filter;
+			gump-&gt;Decode(pImgRaw,iTexW*2,Filter,ColorTable);
+		}
 	} else {
 		cSetHighBitFilter Filter;
 		gump-&gt;Decode(pImgRaw,iTexW*2,Filter,0);
@@ -368,8 +376,7 @@
 		short* ColorTable =3D pHueLoader-&gt;GetHue( iHue-1 )-&gt;GetColors();
 =

 		if (PartialHue) {
-			//cPartialHueFilter Filter;
-			cHueFilter Filter;
+			cPartialHueFilter Filter;
 			if (!anim-&gt;Decode( pImgRaw, iFrame, Filter, ColorTable )) {
 				return false;
 			}

Modified: trunk/src/data.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/src/data.cpp (original)
+++ trunk/src/data.cpp Thu Aug  2 02:27:17 2007
@@ -844,6 +844,7 @@
 	// read out offset of letter header
 	int32 offset =3D ((int32 *)(mpFullFileBuffer))[iCode];
 	if(offset =3D=3D -1)return 0;
+	if (offset &lt; 0)return 0;
 	// valid?
 	if(offset + sizeof(RawUniFontFileLetterHeader) &lt; miFullFileSize)return (R=
awUniFontFileLetterHeader *)(mpFullFileBuffer + offset);
 	else return 0;

Modified: trunk/src/gfx2D_L.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/src/gfx2D_L.cpp (original)
+++ trunk/src/gfx2D_L.cpp Thu Aug  2 02:27:17 2007
@@ -38,6 +38,7 @@
 			REGISTER_METHOD(InitRROC);
 			REGISTER_METHOD(InitText);
 			REGISTER_METHOD(SetPrepareFrameStep);
+			REGISTER_METHOD(SetTransparent);
 			REGISTER_METHOD(SetVisible);
 			REGISTER_METHOD(GetVisible);
 			REGISTER_METHOD(SetMaterial);
@@ -88,6 +89,11 @@
 			REGISTER_METHOD(RenderableSkipVertices);
 			REGISTER_METHOD(RenderableSkipIndices);
 			=

+			REGISTER_METHOD(SOC_ChildBringToFront);
+			REGISTER_METHOD(SOC_ChildSendToBack);
+			REGISTER_METHOD(SOC_ChildInsertAfter);
+			REGISTER_METHOD(SOC_ChildInsertBefore);
+			=

 			// synced with include/gfx2D.h
 			cScripting* scripting =3D cScripting::GetSingletonPtr();
 			#define RegisterClassConstant(name) scripting-&gt;SetGlobal(#name,cGfx2D::=
name)
@@ -173,6 +179,13 @@
 			checkudata_alive(L)-&gt;SetVisible(lua_isboolean(L,2) ? lua_toboolean(L,2)=
 : luaL_checkint(L,2));
 			return 0;
 		}
+
+		/// for overlays
+		static int	SetTransparent		(lua_State *L) { PROFILE /*(const bool bVisib=
le); */
+			cColourClipPaneOverlay* pCCPO =3D checkudata_alive(L)-&gt;mpCCPO; =

+			if (pCCPO) pCCPO-&gt;setTransparent(lua_isboolean(L,2) ? lua_toboolean(L,2=
) : luaL_checkint(L,2));
+			return 0;
+		}
 		static int	GetVisible		(lua_State *L) { PROFILE /*(const bool bVisible);=
 */
 			lua_pushboolean(L,checkudata_alive(L)-&gt;GetVisible());
 			return 1;
@@ -248,18 +261,21 @@
 			return 0;
 		}
 		static int	SetColour		(lua_State *L) { PROFILE =

-			size_t index =3D 2;
-			checkudata_alive(L)-&gt;SetColour(luaSFZ_checkColour4(L, index));
-			return 0;
-		}
+			checkudata_alive(L)-&gt;SetColour(luaSFZ_checkColour4(L, 2));
+			return 0;
+		}
+
+		/// lt:left top , rb:right bottom
+		/// for lua :	void	SetColours	((lt:)r,g,b,a, (rt:)r,g,b,a, (lb:)r,g,b,a,=
 (rb:)r,g,b,a)
 		static int	SetColours		(lua_State *L) { PROFILE =

-			size_t index =3D 2;
-			checkudata_alive(L)-&gt;SetColours(luaSFZ_checkColour4(L,index),luaSFZ_che=
ckColour4(L,index),luaSFZ_checkColour4(L,index),luaSFZ_checkColour4(L,index=
));
-			return 0;
-		}
+			checkudata_alive(L)-&gt;SetColours(luaSFZ_checkColour4(L,2),luaSFZ_checkCo=
lour4(L,6),luaSFZ_checkColour4(L,10),luaSFZ_checkColour4(L,14));
+			return 0;
+		}
+
+		/// lt:left top , rb:right bottom
+		/// for lua :	void	SetPartColours	(partid, (lt:)r,g,b,a, (rt:)r,g,b,a, (=
lb:)r,g,b,a, (rb:)r,g,b,a)
 		static int	SetPartColours		(lua_State *L) { PROFILE =

-			size_t index =3D 3;
-			checkudata_alive(L)-&gt;SetPartColours(luaL_checkint(L, 2),luaSFZ_checkCol=
our4(L,index),luaSFZ_checkColour4(L,index),luaSFZ_checkColour4(L,index),lua=
SFZ_checkColour4(L,index));
+			checkudata_alive(L)-&gt;SetPartColours(luaL_checkint(L, 2),luaSFZ_checkCol=
our4(L,3),luaSFZ_checkColour4(L,7),luaSFZ_checkColour4(L,11),luaSFZ_checkCo=
lour4(L,15));
 			return 0;
 		}
 		static int	SetRotate			(lua_State *L) { PROFILE /*(const Ogre::Real radi=
ans); */
@@ -409,6 +425,42 @@
 		}
 		=

 		=

+		/// ***** ***** ***** ***** ***** SortedOverlayContainer
+		=

+		/// void		SOC_ChildBringToFront		(child)
+		static int		SOC_ChildBringToFront		(lua_State *L) { PROFILE
+			cSortedOverlayContainer*	pSOC =3D checkudata_alive(L)-&gt;mpSOC;
+			Ogre::OverlayElement*		pChild =3D checkudata_alive(L,2)-&gt;mpOverlayEleme=
nt;
+			if (pSOC &amp;&amp; pChild) pSOC-&gt;ChildBringToFront(pChild);
+			return 0;
+		}
+		/// void		SOC_ChildSendToBack		(child)
+		static int		SOC_ChildSendToBack		(lua_State *L) { PROFILE
+			cSortedOverlayContainer*	pSOC =3D checkudata_alive(L)-&gt;mpSOC;
+			Ogre::OverlayElement*		pChild =3D checkudata_alive(L,2)-&gt;mpOverlayEleme=
nt;
+			if (pSOC &amp;&amp; pChild) pSOC-&gt;ChildSendToBack(pChild);
+			return 0;
+		}
+		/// void		SOC_ChildInsertAfter		(child,other)
+		static int		SOC_ChildInsertAfter		(lua_State *L) { PROFILE
+			cSortedOverlayContainer*	pSOC =3D checkudata_alive(L)-&gt;mpSOC;
+			Ogre::OverlayElement*		pChild =3D checkudata_alive(L,2)-&gt;mpOverlayEleme=
nt;
+			Ogre::OverlayElement*		pOther =3D checkudata_alive(L,3)-&gt;mpOverlayEleme=
nt;
+			if (pSOC &amp;&amp; pChild &amp;&amp; pOther) pSOC-&gt;ChildInsertAfter(pChild,pOther);
+			return 0;
+		}
+		/// void		SOC_ChildInsertBefore		(child,other)
+		static int		SOC_ChildInsertBefore		(lua_State *L) { PROFILE
+			cSortedOverlayContainer*	pSOC =3D checkudata_alive(L)-&gt;mpSOC;
+			Ogre::OverlayElement*		pChild =3D checkudata_alive(L,2)-&gt;mpOverlayEleme=
nt;
+			Ogre::OverlayElement*		pOther =3D checkudata_alive(L,3)-&gt;mpOverlayEleme=
nt;
+			if (pSOC &amp;&amp; pChild &amp;&amp; pOther) pSOC-&gt;ChildInsertBefore(pChild,pOther);
+			return 0;
+		}
+		=

+		=

+		/// ***** ***** ***** ***** ***** rest
+		=

 		/// only for cCompassOverlay
 		static int	SetUVMid		(lua_State *L) { PROFILE
 			cCompassOverlay* pCompass =3D checkudata_alive(L)-&gt;mpCompass;

Modified: trunk/src/profile.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/src/profile.cpp (original)
+++ trunk/src/profile.cpp Thu Aug  2 02:27:17 2007
@@ -5,6 +5,7 @@
 #include &lt;map&gt;
 #include &lt;set&gt;
 =

+std::vector&lt;unsigned int&gt; gCallStackCopy;
 std::vector&lt;unsigned int&gt; gCallStack;
 std::vector&lt;unsigned int&gt; gHistory;
 bool gDoInit =3D true;
@@ -55,25 +56,26 @@
 			gHistory.reserve(1024*1024*32);
 		#endif
 		gDoInit =3D false;
-	}
-	gCallStack.push_back((unsigned int)sFile);
-	gCallStack.push_back((unsigned int)iLine);
-	gCallStack.push_back((unsigned int)sFunc);
-	#ifdef PROFILE_CALLTIME
-		gCallStack.push_back(GET_TIMESTAMP);
+	}
+	gCallStack.push_back((unsigned int)sFile);
+	gCallStack.push_back((unsigned int)iLine);
+	gCallStack.push_back((unsigned int)sFunc);
+	#ifdef PROFILE_CALLTIME
+		gCallStack.push_back(GET_TIMESTAMP);
 	#endif
 	#ifdef MEGALOGPATH
 		FILE* fp =3D fopen(MEGALOGPATH,&quot;a&quot;);
 		int i =3D gCallStack.size()-CALLSTACK_ELEM_SIZE;
 		for (int j=3D0;j&lt;i/CALLSTACK_ELEM_SIZE;++j) fprintf(fp,&quot; &quot;);
-		fprintf(fp,&quot;START %s:%d:%s\n&quot;,(const char*) gCallStack[i],
-								(unsigned int)gCallStack[i+1],
+		fprintf(fp,&quot;START %s:%d:%s\n&quot;,(const char*) gCallStack[i],
+								(unsigned int)gCallStack[i+1],
 								(const char*) gCallStack[i+2]);
 		fclose(fp);
 	#endif
 	#ifdef PROFILE_CALLCOUNT
 		++gmCallCountProfileMap[cCallCountProfileIndex(sFile,iLine,sFunc)];
 	#endif
+	//gCallStackCopy.assign(gCallStack.begin(),gCallStack.end()); // TODO : k=
illme, dirty hack
 }
 =

 cProfiler::~cProfiler() {
@@ -81,44 +83,47 @@
 		FILE* fp =3D fopen(MEGALOGPATH,&quot;a&quot;);
 		int i =3D gCallStack.size()-CALLSTACK_ELEM_SIZE;
 		for (int j=3D0;j&lt;i/CALLSTACK_ELEM_SIZE;++j) fprintf(fp,&quot; &quot;);
-		fprintf(fp,&quot;END   %s:%d:%s\n&quot;,(const char*) gCallStack[i],
-									(unsigned int)gCallStack[i+1],
+		fprintf(fp,&quot;END   %s:%d:%s\n&quot;,(const char*) gCallStack[i],
+									(unsigned int)gCallStack[i+1],
 									(const char*) gCallStack[i+2]);
 		fclose(fp);
 	#endif
-	#ifdef KEEP_HISTORY =

-		gHistory.push_back(gCallStack[0+gCallStack.size()-CALLSTACK_ELEM_SIZE]);
-		gHistory.push_back(gCallStack[1+gCallStack.size()-CALLSTACK_ELEM_SIZE]);
+	#ifdef KEEP_HISTORY =

+		gHistory.push_back(gCallStack[0+gCallStack.size()-CALLSTACK_ELEM_SIZE]);
+		gHistory.push_back(gCallStack[1+gCallStack.size()-CALLSTACK_ELEM_SIZE]);
 		gHistory.push_back(gCallStack[2+gCallStack.size()-CALLSTACK_ELEM_SIZE]);
 		#ifdef PROFILE_CALLTIME
-			gHistory.push_back(GET_TIMESTAMP - gCallStack.back());
-		#endif
-	#endif
-	gCallStack.pop_back();
-	gCallStack.pop_back();
-	gCallStack.pop_back();
-	#ifdef PROFILE_CALLTIME
-		gCallStack.pop_back();
+			gHistory.push_back(GET_TIMESTAMP - gCallStack.back());
+		#endif
+	#endif
+	gCallStack.pop_back();
+	gCallStack.pop_back();
+	gCallStack.pop_back();
+	#ifdef PROFILE_CALLTIME
+		gCallStack.pop_back();
 	#endif
 }
 =

+#define PRINTEDSTACK gCallStack
+//#define PRINTEDSTACK gCallStackCopy
+
 void		cProfiler::PrintStackTrace	() {
-	for (int i=3D0;i&lt;gCallStack.size();i+=3DCALLSTACK_ELEM_SIZE) {
+	for (int i=3D0;i&lt;PRINTEDSTACK.size();i+=3DCALLSTACK_ELEM_SIZE) {
 		for (int j=3D0;j&lt;i/CALLSTACK_ELEM_SIZE;++j) printf(&quot; &quot;);
-		printf(&quot;%s:%d:%s\n&quot;,(const char*) gCallStack[i],
-							(unsigned int)gCallStack[i+1],
-							(const char*) gCallStack[i+2]);
+		printf(&quot;%s:%d:%s\n&quot;,(const char*) PRINTEDSTACK[i],
+							(unsigned int)PRINTEDSTACK[i+1],
+							(const char*) PRINTEDSTACK[i+2]);
 	}
 }
 =

 void		cProfiler::PrintStackTrace	(const char *filename) {
 	FILE *f =3D fopen(filename,&quot;a&quot;);
 	if(f){
-		for (int i=3D0;i&lt;gCallStack.size();i+=3DCALLSTACK_ELEM_SIZE) {
+		for (int i=3D0;i&lt;PRINTEDSTACK.size();i+=3DCALLSTACK_ELEM_SIZE) {
 			for (int j=3D0;j&lt;i/CALLSTACK_ELEM_SIZE;++j) fprintf(f,&quot; &quot;);
-			fprintf(f,&quot;%s:%d:%s\n&quot;,(const char*) gCallStack[i],
-								(unsigned int)gCallStack[i+1],
-								(const char*) gCallStack[i+2]);
+			fprintf(f,&quot;%s:%d:%s\n&quot;,(const char*) PRINTEDSTACK[i],
+								(unsigned int)PRINTEDSTACK[i+1],
+								(const char*) PRINTEDSTACK[i+2]);
 		}
 		fclose(f);
 	}

Modified: trunk/src/scripting.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/src/scripting.cpp (original)
+++ trunk/src/scripting.cpp Thu Aug  2 02:27:17 2007
@@ -1,713 +1,716 @@
-#include &quot;prefix.h&quot;
-#include &lt;assert.h&gt;
-#include &lt;stdarg.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &quot;net.h&quot;
-#include &quot;fifo.h&quot;
-#include &quot;game.h&quot;
-#include &quot;listener.h&quot;
-#include &quot;scripting.h&quot;
-#include &quot;input.h&quot;
-#include &quot;robstring1.2.h&quot;
-#include &quot;gfx3D.h&quot;
-#include &quot;gfx2D.h&quot;
-#include &quot;widget.h&quot;
-#include &quot;luabind.h&quot;
-#include &quot;data.h&quot;
-#include &quot;builder.h&quot;
-#include &quot;shell.h&quot;
-#include &quot;timer.h&quot;
-#include &quot;ogrewrapper.h&quot;
-#include &quot;pathsearch.h&quot;
-#include &quot;bitmask.h&quot;
-#include &quot;camera.h&quot;
-#include &quot;viewport.h&quot;
-#include &quot;rendertexture.h&quot;
+#include &quot;prefix.h&quot;
+#include &lt;assert.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &quot;net.h&quot;
+#include &quot;fifo.h&quot;
+#include &quot;game.h&quot;
+#include &quot;listener.h&quot;
+#include &quot;scripting.h&quot;
+#include &quot;input.h&quot;
+#include &quot;robstring1.2.h&quot;
+#include &quot;gfx3D.h&quot;
+#include &quot;gfx2D.h&quot;
+#include &quot;widget.h&quot;
+#include &quot;luabind.h&quot;
+#include &quot;data.h&quot;
+#include &quot;builder.h&quot;
+#include &quot;shell.h&quot;
+#include &quot;timer.h&quot;
+#include &quot;ogrewrapper.h&quot;
+#include &quot;pathsearch.h&quot;
+#include &quot;bitmask.h&quot;
+#include &quot;camera.h&quot;
+#include &quot;viewport.h&quot;
+#include &quot;rendertexture.h&quot;
 #include &quot;sound.h&quot;
-#include &quot;meshshape.h&quot;
-#include &quot;terrain.h&quot;
-#include &quot;radar.h&quot;
-#include &lt;Ogre.h&gt;
-#include &lt;OgreResourceManager.h&gt;
-#include &lt;OgreFontManager.h&gt;
-#include &lt;OgreTextAreaOverlayElement.h&gt;
-#include &lt;OgreMeshSerializer.h&gt;
-#include &lt;OgreCompositorManager.h&gt;
-#include &quot;luaxml.h&quot;
-#include &quot;spritemanager.h&quot;
-#include &quot;ogremanualloader.h&quot;
-
-//#define PROFILE_LUACALLCOUNT
-#ifdef PROFILE_LUACALLCOUNT
-std::map&lt;const char*,int&gt; gPROFILE_LUACALLCOUNT;
-struct cPROFILE_LUACALLCOUNTSetCmp {
-  inline bool operator() (const std::pair&lt;const char*,int&gt;&amp; x,const  std::=
pair&lt;const char*,int&gt;&amp; y) const {
-	return x.second &gt; y.second;
-  }
-};
-#endif
-
-#ifdef WIN32
-#include &lt;windows.h&gt;
-#else
-#include &lt;unistd.h&gt;
-#endif
-
-extern &quot;C&quot; {
-	#include &quot;lua.h&quot;
-	#include &quot;lauxlib.h&quot;
-	#include &quot;lualib.h&quot;
-}
-
-void	DisplayNotice			(const char* szMsg); ///&lt; defined in main.cpp, OS-spe=
cific
-void	DisplayErrorMessage		(const char* szMsg); ///&lt; defined in main.cpp, O=
S-specific
-void	Material_LuaRegister	(void *L);
-void	Granny_LuaRegister		(void *L);
-void	PrintLuaStackTrace		();
-void	ProfileDumpCallCount	(); ///&lt; defined in profile.cpp, only does somet=
hing if PROFILE_CALLCOUNT is enabled
-
-void	PrintLuaStackTrace		() { PROFILE
-	printf(&quot;PrintLuaStackTrace:\n&quot;);
-	// see l_TRACEBACK() : leaves a string containing the stacktrace at the t=
op of the stack
-	std::string sMyStackTrace;
-	cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;_TRACEBACK&quot;,&quot;&gt;s&quot;,&amp;sMyStackTrace);
-	printf(&quot;%s\n&quot;,sMyStackTrace.c_str());
-}
-
-void	PrintLuaStackTrace		(const char *filename) { PROFILE
-	FILE *f =3D fopen(filename,&quot;a&quot;);
-	if(f){
-		fprintf(f,&quot;PrintLuaStackTrace:\n&quot;);
-		// see l_TRACEBACK() : leaves a string containing the stacktrace at the =
top of the stack
-		std::string sMyStackTrace;
-		cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;_TRACEBACK&quot;,&quot;&gt;s&quot;,&amp;sMyStackTrace);
-		fprintf(f,&quot;%s\n&quot;,sMyStackTrace.c_str());
-
-		fclose(f);
-	}
-}
-
-void	printdebug	(const char *szCategory, const char *szFormat, ...) { PROF=
ILE
-	va_list ap;
-	va_start(ap,szFormat);
-	gRobStringBuffer[0] =3D 0;
-	vsnprintf(gRobStringBuffer,kRobStringBufferSize-1,szFormat,ap);
-	cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;printdebug&quot;,&quot;ss&quot;,szCategory,gRobS=
tringBuffer);
-	va_end(ap);
-}
-
-// ***** ***** global functionals exported to lua ***** *****
-
-
-cScripting*	cScripting::GetSingletonPtr	(cScripting* p) {
-	static cScripting* pSingleton =3D 0;
-	if (p) pSingleton =3D p;
-	return pSingleton;
-}
-
-
-/// called from lua : string keyname
-static int l_GetNamedKey (lua_State *L) { PROFILE
-	const char *keyname =3D luaL_checkstring(L, 1);
-	lua_pushnumber(L,cInput::GetSingleton().GetNamedKey(keyname));  // push r=
esult
-	return 1;  // number of results
-}
-
-/// called from lua : int keycode
-static int l_GetKeyName (lua_State *L) { PROFILE
-	int keycode =3D luaL_checkint(L, 1);
-	lua_pushstring(L,cInput::GetSingleton().GetKeyName(keycode));  // push re=
sult
-	return 1;  // number of results
-}
-
-/// terminates the application
-static int l_Terminate (lua_State *L) { PROFILE
-	cShell::mbAlive =3D false;
-	return 0;
-}
-
-/// only call this once at startup
-static int l_InitOgre (lua_State *L) { PROFILE
-	lua_pushboolean(L,cOgreWrapper::GetSingleton().Init());
-	return 1;
-}
-
-static int l_GetPointerSize (lua_State *L) { PROFILE
-	lua_pushnumber(L,sizeof(void*));
-	return 1;
-}
-
-/// only call this once at startup
-static int l_Client_IsAlive (lua_State *L) { PROFILE
-	lua_pushboolean(L,cShell::mbAlive);
-	return 1;
-}
-
-/// called from lua : no params, returns mousex,mousey,4xmousewheel info...
-static int l_PollInput (lua_State *L) { PROFILE
-	lua_pushnumber(L,cInput::iMouse[0]);
-	lua_pushnumber(L,cInput::iMouse[1]);
-	lua_pushnumber(L,cInput::iMouseWheel);
-	lua_pushnumber(L,cInput::iMouseWheel_pressed);
-	lua_pushnumber(L,cInput::iMouseWheel_all_since_last_step);
-	lua_pushnumber(L,cInput::iMouseWheel_pressed_since_last_step);
-	return 6;
-}
-
-
-static int l_ProfileDumpCallCount (lua_State *L) { PROFILE
-	ProfileDumpCallCount();
-
-	#ifdef PROFILE_LUACALLCOUNT
-	printf(&quot;LuaCallCounts:\n\n&quot;);
-
-	std::multiset&lt;std::pair&lt;const char*,int&gt;,cPROFILE_LUACALLCOUNTSetCmp&gt; myC=
allCountProfileSet;
-	typedef std::multiset&lt;std::pair&lt;const char*,int&gt;,cPROFILE_LUACALLCOUNTSet=
Cmp&gt;::iterator tLuaCallCountProfileSetItor;
-	{ for (std::map&lt;const char*,int&gt;::iterator itor=3DgPROFILE_LUACALLCOUNT.b=
egin();itor !=3D gPROFILE_LUACALLCOUNT.end();++itor)
-		myCallCountProfileSet.insert(std::make_pair((*itor).first,(*itor).second=
));
-	}
-	int i=3D0;
-	for (tLuaCallCountProfileSetItor itor=3DmyCallCountProfileSet.begin();ito=
r !=3D myCallCountProfileSet.end();++itor) {
-		//if (++i &gt; 10) break;
-		printf(&quot;LuaCallCallCount %16d %s\n&quot;,(*itor).second,(*itor).first);
-	}
-	#endif
-
-	return 0;
-}
-
-/// used as errfunc for lua_pcall, adds a callstack/backtrace/list_of_call=
ed_functions to the errormessage
-/// code from errorfb from /usr/src/lua-5.0.2/src/lua/ldblib.c
-/// &quot;_TRACEBACK&quot; is defined as errorfb
-/// leaves a string containing the stacktrace at the top of the stack
-#define LEVELS1	12	/* size of the first part of the stack */
-#define LEVELS2	10	/* size of the second part of the stack */
-static int l_TRACEBACK (lua_State *L) { PROFILE
-  int level =3D 1;  /* skip level 0 (it's this function) */
-  int firstpart =3D 1;  /* still before eventual `...' */
-  lua_Debug ar;
-  if (lua_gettop(L) =3D=3D 0)
-	lua_pushliteral(L, &quot;&quot;);
-  else if (!lua_isstring(L, 1)) return 1;  /* no string message */
-  else lua_pushliteral(L, &quot;\n&quot;);
-  lua_pushliteral(L, &quot;LuaStackTrace:\n&quot;);
-  while (lua_getstack(L, level++, &amp;ar)) {
-	if (level &gt; LEVELS1 &amp;&amp; firstpart) {
-	  /* no more than `LEVELS2' more levels? */
-	  if (!lua_getstack(L, level+LEVELS2, &amp;ar))
-		level--;  /* keep going */
-	  else {
-		lua_pushliteral(L, &quot;\n\t...&quot;);  /* too many levels */
-		while (lua_getstack(L, level+LEVELS2, &amp;ar))  /* find last levels */
-		  level++;
-	  }
-	  firstpart =3D 0;
-	  continue;
-	}
-	lua_pushliteral(L, &quot;\n\t&quot;);
-	lua_getinfo(L, &quot;Snl&quot;, &amp;ar);
-	lua_pushfstring(L, &quot;%s:&quot;, ar.short_src);
-	if (ar.currentline &gt; 0)
-	  lua_pushfstring(L, &quot;%d:&quot;, ar.currentline);
-	switch (*ar.namewhat) {
-	  case 'g':  /* global */
-	  case 'l':  /* local */
-	  case 'f':  /* field */
-	  case 'm':  /* method */
-		lua_pushfstring(L, &quot; in function `%s'&quot;, ar.name);
-		break;
-	  default: {
-		if (*ar.what =3D=3D 'm')  /* main? */
-		  lua_pushfstring(L, &quot; in main chunk&quot;);
-		else if (*ar.what =3D=3D 'C' || *ar.what =3D=3D 't')
-		  lua_pushliteral(L, &quot; ?&quot;);  /* C function or tail call */
-		else
-		  lua_pushfstring(L, &quot; in function &lt;%s:%d&gt;&quot;,
-							 ar.short_src, ar.linedefined);
-	  }
-	}
-	lua_concat(L, lua_gettop(L));
-  }
-  lua_concat(L, lua_gettop(L));
-  return 1;
-}
-
-
-
-static int l_Client_GetCurFPS (lua_State *L) { PROFILE
-	lua_pushnumber(L, (cTimer::miTimeSinceLastFrame &gt; 0) ? (float(1000.0) / f=
loat(cTimer::miTimeSinceLastFrame)) : 0.0 );
-	return 1;
-}
-
-static int l_Client_GetFrameNum (lua_State *L) { PROFILE
-	lua_pushnumber(L, cTimer::miCurFrameNum );
-	return 1;
-}
-
-static int l_Client_GetTicks (lua_State *L) { PROFILE
-	lua_pushnumber(L, cShell::GetTicks());
-	return 1;
-}
-
-
-/// void OgreAddCompositor(compositor script name)
-static int l_OgreAddCompositor (lua_State *L) { PROFILE
-	Ogre::Viewport* pViewport =3D cLuaBind&lt;cViewport&gt;::checkudata_alive(L,1)-=
&gt;<i>mpViewport;
</I>-//	printf(&quot;pViewport=3D%08x\n&quot;,pViewport);
-	if (pViewport)
-	{
-		const char *name =3D luaL_checkstring(L,2);
-		Ogre::CompositorManager::getSingleton().addCompositor(pViewport, name);
-		Ogre::CompositorManager::getSingleton().setCompositorEnabled(pViewport, =
name, true);
-	}
-	else
-	{
-		return false;
-	}
-	return true;
-}
-
-/// void OgreRemoveCompositor(compositor script name)
-static int l_OgreRemoveCompositor (lua_State *L) { PROFILE
-	Ogre::Viewport* pViewport =3D cLuaBind&lt;cViewport&gt;::checkudata_alive(L,1)-=
&gt;<i>mpViewport;
</I>-	if (pViewport)
-	{
-		const char *name =3D luaL_checkstring(L,2);
-		Ogre::CompositorManager::getSingleton().setCompositorEnabled(pViewport, =
name, false);
-		Ogre::CompositorManager::getSingleton().removeCompositor(pViewport, name=
);
-	}
-	else
-	{
-		return false;
-	}
-	return true;
-}
-
-/// int =3D OgreMemoryUsage(part)
-/// part in {compositor,font,gpuprogram,highlevelgpuprogram,material,mesh,=
skeleton,texture,all}
-/// returns memory usage in byte
-static int l_OgreMemoryUsage (lua_State *L) { PROFILE
-	std::string part(luaL_checkstring(L,1));
-	size_t mem =3D 0;
-
-#ifdef OGRE_VERSION_SUFFIX
-	if(part.find(&quot;compositor&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=
=3D std::string::npos)mem +=3D Ogre::CompositorManager::getSingleton().getM=
emoryUsage();
-	if(part.find(&quot;font&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D std:=
:<i>string::npos)mem +=3D Ogre::FontManager::getSingleton().getMemoryUsage();
</I>-	if(part.find(&quot;gpuprogram&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=
=3D std::string::npos)mem +=3D Ogre::GpuProgramManager::getSingleton().getM=
emoryUsage();
-	if(part.find(&quot;highlevelgpuprogram&quot;) !=3D std::string::npos || part.find(&quot;=
all&quot;) !=3D std::string::npos)mem +=3D Ogre::HighLevelGpuProgramManager::get=
Singleton().getMemoryUsage();
-	if(part.find(&quot;material&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D =
std::string::npos)mem +=3D Ogre::MaterialManager::getSingleton().getMemoryU=
sage();
-	if(part.find(&quot;mesh&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D std:=
:<i>string::npos)mem +=3D Ogre::MeshManager::getSingleton().getMemoryUsage();
</I>-	if(part.find(&quot;skeleton&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D =
std::string::npos)mem +=3D Ogre::SkeletonManager::getSingleton().getMemoryU=
sage();
-	if(part.find(&quot;texture&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D s=
td::string::npos)mem +=3D Ogre::TextureManager::getSingleton().getMemoryUsa=
ge();
-#endif
-
-	lua_pushnumber(L, mem);
-	return 1;
-}
-
-/// bool =3D OgreMeshAvailable(ressourcename)
-static int l_OgreMeshAvailable (lua_State *L) { PROFILE
-	const char *name =3D luaL_checkstring(L,1);
-	bool ret;
-
-	try {
-		Ogre::MeshManager::getSingleton().load(name,Ogre::ResourceGroupManager::=
DEFAULT_RESOURCE_GROUP_NAME);
-		ret =3D true;
-	} catch (...) {
-			ret =3D false;
-	}
-
-	lua_pushboolean(L, ret);
-	return 1;
-}
-
-/// see also OgreMaterialAvailable below
-/// bool =3D OgreMaterialNameKnown(ressourcename)
-/// returns false if name is empty string or nil
-static int l_OgreMaterialNameKnown (lua_State *L) { PROFILE
-	std::string sMatName =3D (lua_gettop(L) &gt;=3D 1 &amp;&amp; !lua_isnil(L,1)) ? luaL=
_checkstring(L,1) : &quot;&quot;;
-	if (sMatName.size() &gt; 0) {
-		Ogre::MaterialPtr pMaterial =3D Ogre::MaterialManager::getSingleton().ge=
tByName(sMatName.c_str());
-		lua_pushboolean(L,!pMaterial.isNull());
-	} else {
-		lua_pushboolean(L,false);
-	}
-	return 1;
-}
-
-/// bool =3D OgreMaterialAvailable(ressourcename)
-static int l_OgreMaterialAvailable (lua_State *L) { PROFILE
-	assert(0 &amp;&amp; &quot;DON'T USE ME, ALWAYS RETURNS TRUE&quot;);
-	// TODO, this code does not work, use l_OgreMaterialNameKnown  above
-	const char *name =3D luaL_checkstring(L,1);
-	bool ret;
-
-	try {
-		Ogre::MaterialManager::getSingleton().load(name,Ogre::ResourceGroupManag=
er::DEFAULT_RESOURCE_GROUP_NAME);
-		ret =3D true;
-	} catch (...) {
-			ret =3D false;
-	}
-
-	lua_pushboolean(L, ret);
-	return 1;
-}
-
-/// bool =3D OgreTextureAvailable(ressourcename)
-static int l_OgreTextureAvailable (lua_State *L) { PROFILE
-	const char *name =3D luaL_checkstring(L,1);
-	bool ret;
-
-	try {
-		Ogre::TextureManager::getSingleton().load(name,Ogre::ResourceGroupManage=
r::DEFAULT_RESOURCE_GROUP_NAME);
-		ret =3D true;
-	} catch (...) {
-			ret =3D false;
-	}
-
-	lua_pushboolean(L, ret);
-	return 1;
-}
-
-/// r,g,b =3D Uo16Color2Rgb(color)
-static int l_Uo16Color2Rgb (lua_State *L) { PROFILE
-	unsigned short color =3D luaL_checkint(L,1);
-
-	float r =3D float((color &gt;&gt; 10) &amp; 0x1F)/float(0x1f);
-	float g =3D float((color &gt;&gt;  5) &amp; 0x1F)/float(0x1f);
-	float b =3D float((color &gt;&gt;  0) &amp; 0x1F)/float(0x1f);
-
-	lua_pushnumber(L, r);
-	lua_pushnumber(L, g);
-	lua_pushnumber(L, b);
-	return 3;
-}
-
-/// CreateGrannyHuedTexture(GrannyTextureHook(texturepath),GrannyTextureHo=
ok(texturepath),gHueLoader,hue)
-static int l_CreateGrannyHuedTexture (lua_State *L) { PROFILE
-	std::string sTexturePath	=3D luaL_checkstring(L,1);
-	std::string sMaskPath		=3D luaL_checkstring(L,2);
-	cHueLoader *hueLoader 		=3D cLuaBind&lt;cHueLoader&gt;::checkudata(L,3);
-	int iHue					=3D luaL_checkint(L,4);
-
-	if (iHue =3D=3D 0 || !hueLoader) {
-		lua_pushstring(L,sTexturePath.c_str());
-		return 1;
-	}
-
-	// load image
-	Ogre::Image myImage;
-	myImage.load(sTexturePath,Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GR=
OUP_NAME);
-
-	// get image infos
-	Ogre::PixelFormat myFormat =3D myImage.getFormat();
-	unsigned int size =3D myImage.getSize();
-	unsigned int w =3D myImage.getWidth();
-	unsigned int h =3D myImage.getHeight();
-	unsigned int rowspan =3D myImage.getRowSpan();
-	unsigned int pixelsize =3D Ogre::PixelUtil::getNumElemBytes(myFormat);
-	//Ogre::uchar* dst =3D new Ogre::uchar[size];
-	Ogre::uchar* src =3D myImage.getData();
-	//Ogre::uchar* dst_start =3D dst;
-	Ogre::uchar* src_start =3D src;
-	uint8 cr,cg,cb,ca1,ca2;
-	short col;
-
-	// debug info
-	//printf(&quot;image size=3D%d w=3D%d h=3D%d d=3D%d f=3D%d bpp=3D%d rowspan=3D=
%d bIsNonZero2=3D%d\n&quot;,size,w,h,
-	//	myImage.getDepth(),myImage.getNumFaces(),myImage.getBPP(),rowspan,bIsN=
onZero2?1:0);
-
-	// hue filter
-	cHueFilter Filter;
-	short* ColorTable =3D hueLoader-&gt;GetHue( iHue-1 )-&gt;GetColors();
-
-	// colorize the pixels
-	for(unsigned int y =3D 0; y &lt; h; y++){
-		for(unsigned int x =3D 0; x &lt; w; x++) {
-			// read out pixel in src graphic
-			Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca1,myFormat,src);
-			Ogre::PixelUtil::packColour(cr,cg,cb,ca1,Ogre::PF_A1R5G5B5,&amp;col);
-			// and hue the pixel
-			col =3D Filter( col, ColorTable );
-			// TODO ! respect mask instead of hueing the complete texture
-			// and store it in destination (ignoring the new alpha)
-			Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca2,Ogre::PF_A1R5G5B5,&amp;col);
-			Ogre::PixelUtil::packColour(cr,cg,cb,ca1,myFormat,src);
-			src +=3D pixelsize;
-			//dst +=3D pixelsize;
-		}
-		src +=3D rowspan - w*pixelsize;
-	}
-
-	// and make a texture
-	std::string newtextname =3D cOgreWrapper::GetSingleton().GetUniqueName();
-	//Ogre::DataStreamPtr texstream(new Ogre::MemoryDataStream(dst_start, siz=
e));
-	//Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().loadR=
awData(newtextname,
-	//	Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,texstream, w,h=
,myFormat);
-
-	Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().loadIma=
ge(newtextname,
-		Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,myImage,Ogre::TE=
X_TYPE_2D,-1,1.0f,true,Ogre::PF_UNKNOWN);
-
-	// free memory
-	//delete [] dst_start;
-
-	lua_pushstring(L,newtextname.c_str());
-	return 1;
-}
-
-/// void HueMesh(meshname, hueloader, hue)
-static int l_HueMesh (lua_State *L) { PROFILE
+#include &quot;meshshape.h&quot;
+#include &quot;terrain.h&quot;
+#include &quot;radar.h&quot;
+#include &lt;Ogre.h&gt;
+#include &lt;OgreResourceManager.h&gt;
+#include &lt;OgreFontManager.h&gt;
+#include &lt;OgreTextAreaOverlayElement.h&gt;
+#include &lt;OgreMeshSerializer.h&gt;
+#include &lt;OgreCompositorManager.h&gt;
+#include &quot;luaxml.h&quot;
+#include &quot;spritemanager.h&quot;
+#include &quot;ogremanualloader.h&quot;
+
+//#define PROFILE_LUACALLCOUNT
+#ifdef PROFILE_LUACALLCOUNT
+std::map&lt;const char*,int&gt; gPROFILE_LUACALLCOUNT;
+struct cPROFILE_LUACALLCOUNTSetCmp {
+  inline bool operator() (const std::pair&lt;const char*,int&gt;&amp; x,const  std::=
pair&lt;const char*,int&gt;&amp; y) const {
+	return x.second &gt; y.second;
+  }
+};
+#endif
+
+#ifdef WIN32
+#include &lt;windows.h&gt;
+#else
+#include &lt;unistd.h&gt;
+#endif
+
+extern &quot;C&quot; {
+	#include &quot;lua.h&quot;
+	#include &quot;lauxlib.h&quot;
+	#include &quot;lualib.h&quot;
+}
+
+void	DisplayNotice			(const char* szMsg); ///&lt; defined in main.cpp, OS-spe=
cific
+void	DisplayErrorMessage		(const char* szMsg); ///&lt; defined in main.cpp, O=
S-specific
+void	Material_LuaRegister	(void *L);
+void	Granny_LuaRegister		(void *L);
+void	PrintLuaStackTrace		();
+void	ProfileDumpCallCount	(); ///&lt; defined in profile.cpp, only does somet=
hing if PROFILE_CALLCOUNT is enabled
+
+void	PrintLuaStackTrace		() { PROFILE
+	printf(&quot;PrintLuaStackTrace:\n&quot;);
+	// see l_TRACEBACK() : leaves a string containing the stacktrace at the t=
op of the stack
+	std::string sMyStackTrace;
+	cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;_TRACEBACK&quot;,&quot;&gt;s&quot;,&amp;sMyStackTrace);
+	printf(&quot;%s\n&quot;,sMyStackTrace.c_str());
+}
+
+void	PrintLuaStackTrace		(const char *filename) { PROFILE
+	FILE *f =3D fopen(filename,&quot;a&quot;);
+	if(f){
+		fprintf(f,&quot;PrintLuaStackTrace:\n&quot;);
+		// see l_TRACEBACK() : leaves a string containing the stacktrace at the =
top of the stack
+		std::string sMyStackTrace;
+		cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;_TRACEBACK&quot;,&quot;&gt;s&quot;,&amp;sMyStackTrace);
+		fprintf(f,&quot;%s\n&quot;,sMyStackTrace.c_str());
+
+		fclose(f);
+	}
+}
+
+void	printdebug	(const char *szCategory, const char *szFormat, ...) { PROF=
ILE
+	va_list ap;
+	va_start(ap,szFormat);
+	gRobStringBuffer[0] =3D 0;
+	vsnprintf(gRobStringBuffer,kRobStringBufferSize-1,szFormat,ap);
+	cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;printdebug&quot;,&quot;ss&quot;,szCategory,gRobS=
tringBuffer);
+	va_end(ap);
+}
+
+// ***** ***** global functionals exported to lua ***** *****
+
+
+cScripting*	cScripting::GetSingletonPtr	(cScripting* p) {
+	static cScripting* pSingleton =3D 0;
+	if (p) pSingleton =3D p;
+	return pSingleton;
+}
+
+
+/// called from lua : string keyname
+static int l_GetNamedKey (lua_State *L) { PROFILE
+	const char *keyname =3D luaL_checkstring(L, 1);
+	lua_pushnumber(L,cInput::GetSingleton().GetNamedKey(keyname));  // push r=
esult
+	return 1;  // number of results
+}
+
+/// called from lua : int keycode
+static int l_GetKeyName (lua_State *L) { PROFILE
+	int keycode =3D luaL_checkint(L, 1);
+	lua_pushstring(L,cInput::GetSingleton().GetKeyName(keycode));  // push re=
sult
+	return 1;  // number of results
+}
+
+/// terminates the application
+static int l_Terminate (lua_State *L) { PROFILE
+	cShell::mbAlive =3D false;
+	return 0;
+}
+
+/// only call this once at startup
+static int l_InitOgre (lua_State *L) { PROFILE
+	lua_pushboolean(L,cOgreWrapper::GetSingleton().Init());
+	return 1;
+}
+
+static int l_GetPointerSize (lua_State *L) { PROFILE
+	lua_pushnumber(L,sizeof(void*));
+	return 1;
+}
+
+/// only call this once at startup
+static int l_Client_IsAlive (lua_State *L) { PROFILE
+	lua_pushboolean(L,cShell::mbAlive);
+	return 1;
+}
+
+/// called from lua : no params, returns mousex,mousey,4xmousewheel info...
+static int l_PollInput (lua_State *L) { PROFILE
+	lua_pushnumber(L,cInput::iMouse[0]);
+	lua_pushnumber(L,cInput::iMouse[1]);
+	lua_pushnumber(L,cInput::iMouseWheel);
+	lua_pushnumber(L,cInput::iMouseWheel_pressed);
+	lua_pushnumber(L,cInput::iMouseWheel_all_since_last_step);
+	lua_pushnumber(L,cInput::iMouseWheel_pressed_since_last_step);
+	return 6;
+}
+
+
+static int l_ProfileDumpCallCount (lua_State *L) { PROFILE
+	ProfileDumpCallCount();
+
+	#ifdef PROFILE_LUACALLCOUNT
+	printf(&quot;LuaCallCounts:\n\n&quot;);
+
+	std::multiset&lt;std::pair&lt;const char*,int&gt;,cPROFILE_LUACALLCOUNTSetCmp&gt; myC=
allCountProfileSet;
+	typedef std::multiset&lt;std::pair&lt;const char*,int&gt;,cPROFILE_LUACALLCOUNTSet=
Cmp&gt;::iterator tLuaCallCountProfileSetItor;
+	{ for (std::map&lt;const char*,int&gt;::iterator itor=3DgPROFILE_LUACALLCOUNT.b=
egin();itor !=3D gPROFILE_LUACALLCOUNT.end();++itor)
+		myCallCountProfileSet.insert(std::make_pair((*itor).first,(*itor).second=
));
+	}
+	int i=3D0;
+	for (tLuaCallCountProfileSetItor itor=3DmyCallCountProfileSet.begin();ito=
r !=3D myCallCountProfileSet.end();++itor) {
+		//if (++i &gt; 10) break;
+		printf(&quot;LuaCallCallCount %16d %s\n&quot;,(*itor).second,(*itor).first);
+	}
+	#endif
+
+	return 0;
+}
+
+/// used as errfunc for lua_pcall, adds a callstack/backtrace/list_of_call=
ed_functions to the errormessage
+/// code from errorfb from /usr/src/lua-5.0.2/src/lua/ldblib.c
+/// &quot;_TRACEBACK&quot; is defined as errorfb
+/// leaves a string containing the stacktrace at the top of the stack
+#define LEVELS1	12	/* size of the first part of the stack */
+#define LEVELS2	10	/* size of the second part of the stack */
+static int l_TRACEBACK (lua_State *L) { PROFILE
+  int level =3D 1;  /* skip level 0 (it's this function) */
+  int firstpart =3D 1;  /* still before eventual `...' */
+  lua_Debug ar;
+  if (lua_gettop(L) =3D=3D 0)
+	lua_pushliteral(L, &quot;&quot;);
+  else if (!lua_isstring(L, 1)) return 1;  /* no string message */
+  else lua_pushliteral(L, &quot;\n&quot;);
+  lua_pushliteral(L, &quot;LuaStackTrace:\n&quot;);
+  while (lua_getstack(L, level++, &amp;ar)) {
+	if (level &gt; LEVELS1 &amp;&amp; firstpart) {
+	  /* no more than `LEVELS2' more levels? */
+	  if (!lua_getstack(L, level+LEVELS2, &amp;ar))
+		level--;  /* keep going */
+	  else {
+		lua_pushliteral(L, &quot;\n\t...&quot;);  /* too many levels */
+		while (lua_getstack(L, level+LEVELS2, &amp;ar))  /* find last levels */
+		  level++;
+	  }
+	  firstpart =3D 0;
+	  continue;
+	}
+	lua_pushliteral(L, &quot;\n\t&quot;);
+	lua_getinfo(L, &quot;Snl&quot;, &amp;ar);
+	lua_pushfstring(L, &quot;%s:&quot;, ar.short_src);
+	if (ar.currentline &gt; 0)
+	  lua_pushfstring(L, &quot;%d:&quot;, ar.currentline);
+	switch (*ar.namewhat) {
+	  case 'g':  /* global */
+	  case 'l':  /* local */
+	  case 'f':  /* field */
+	  case 'm':  /* method */
+		lua_pushfstring(L, &quot; in function `%s'&quot;, ar.name);
+		break;
+	  default: {
+		if (*ar.what =3D=3D 'm')  /* main? */
+		  lua_pushfstring(L, &quot; in main chunk&quot;);
+		else if (*ar.what =3D=3D 'C' || *ar.what =3D=3D 't')
+		  lua_pushliteral(L, &quot; ?&quot;);  /* C function or tail call */
+		else
+		  lua_pushfstring(L, &quot; in function &lt;%s:%d&gt;&quot;,
+							 ar.short_src, ar.linedefined);
+	  }
+	}
+	lua_concat(L, lua_gettop(L));
+  }
+  lua_concat(L, lua_gettop(L));
+  return 1;
+}
+
+
+
+static int l_Client_GetCurFPS (lua_State *L) { PROFILE
+	lua_pushnumber(L, (cTimer::miTimeSinceLastFrame &gt; 0) ? (float(1000.0) / f=
loat(cTimer::miTimeSinceLastFrame)) : 0.0 );
+	return 1;
+}
+
+static int l_Client_GetFrameNum (lua_State *L) { PROFILE
+	lua_pushnumber(L, cTimer::miCurFrameNum );
+	return 1;
+}
+
+static int l_Client_GetTicks (lua_State *L) { PROFILE
+	lua_pushnumber(L, cShell::GetTicks());
+	return 1;
+}
+
+
+/// void OgreAddCompositor(compositor script name)
+static int l_OgreAddCompositor (lua_State *L) { PROFILE
+	Ogre::Viewport* pViewport =3D cLuaBind&lt;cViewport&gt;::checkudata_alive(L,1)-=
&gt;<i>mpViewport;
</I>+//	printf(&quot;pViewport=3D%08x\n&quot;,pViewport);
+	if (pViewport)
+	{
+		const char *name =3D luaL_checkstring(L,2);
+		Ogre::CompositorManager::getSingleton().addCompositor(pViewport, name);
+		Ogre::CompositorManager::getSingleton().setCompositorEnabled(pViewport, =
name, true);
+	}
+	else
+	{
+		return false;
+	}
+	return true;
+}
+
+/// void OgreRemoveCompositor(compositor script name)
+static int l_OgreRemoveCompositor (lua_State *L) { PROFILE
+	Ogre::Viewport* pViewport =3D cLuaBind&lt;cViewport&gt;::checkudata_alive(L,1)-=
&gt;<i>mpViewport;
</I>+	if (pViewport)
+	{
+		const char *name =3D luaL_checkstring(L,2);
+		Ogre::CompositorManager::getSingleton().setCompositorEnabled(pViewport, =
name, false);
+		Ogre::CompositorManager::getSingleton().removeCompositor(pViewport, name=
);
+	}
+	else
+	{
+		return false;
+	}
+	return true;
+}
+
+/// int =3D OgreMemoryUsage(part)
+/// part in {compositor,font,gpuprogram,highlevelgpuprogram,material,mesh,=
skeleton,texture,all}
+/// returns memory usage in byte
+static int l_OgreMemoryUsage (lua_State *L) { PROFILE
+	std::string part(luaL_checkstring(L,1));
+	size_t mem =3D 0;
+
+#ifdef OGRE_VERSION_SUFFIX
+	if(part.find(&quot;compositor&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=
=3D std::string::npos)mem +=3D Ogre::CompositorManager::getSingleton().getM=
emoryUsage();
+	if(part.find(&quot;font&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D std:=
:<i>string::npos)mem +=3D Ogre::FontManager::getSingleton().getMemoryUsage();
</I>+	if(part.find(&quot;gpuprogram&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=
=3D std::string::npos)mem +=3D Ogre::GpuProgramManager::getSingleton().getM=
emoryUsage();
+	if(part.find(&quot;highlevelgpuprogram&quot;) !=3D std::string::npos || part.find(&quot;=
all&quot;) !=3D std::string::npos)mem +=3D Ogre::HighLevelGpuProgramManager::get=
Singleton().getMemoryUsage();
+	if(part.find(&quot;material&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D =
std::string::npos)mem +=3D Ogre::MaterialManager::getSingleton().getMemoryU=
sage();
+	if(part.find(&quot;mesh&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D std:=
:<i>string::npos)mem +=3D Ogre::MeshManager::getSingleton().getMemoryUsage();
</I>+	if(part.find(&quot;skeleton&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D =
std::string::npos)mem +=3D Ogre::SkeletonManager::getSingleton().getMemoryU=
sage();
+	if(part.find(&quot;texture&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D s=
td::string::npos)mem +=3D Ogre::TextureManager::getSingleton().getMemoryUsa=
ge();
+#endif
+
+	lua_pushnumber(L, mem);
+	return 1;
+}
+
+/// bool =3D OgreMeshAvailable(ressourcename)
+static int l_OgreMeshAvailable (lua_State *L) { PROFILE
+	const char *name =3D luaL_checkstring(L,1);
+	bool ret;
+
+	try {
+		Ogre::MeshManager::getSingleton().load(name,Ogre::ResourceGroupManager::=
DEFAULT_RESOURCE_GROUP_NAME);
+		ret =3D true;
+	} catch (...) {
+			ret =3D false;
+	}
+
+	lua_pushboolean(L, ret);
+	return 1;
+}
+
+
+
+/// see also OgreMaterialAvailable below
+/// bool =3D OgreMaterialNameKnown(ressourcename)
+/// returns false if name is empty string or nil
+static int l_OgreMaterialNameKnown (lua_State *L) { PROFILE
+	std::string sMatName =3D (lua_gettop(L) &gt;=3D 1 &amp;&amp; !lua_isnil(L,1)) ? luaL=
_checkstring(L,1) : &quot;&quot;;
+	if (sMatName.size() &gt; 0) {
+		Ogre::MaterialPtr pMaterial =3D Ogre::MaterialManager::getSingleton().ge=
tByName(sMatName.c_str());
+		lua_pushboolean(L,!pMaterial.isNull());
+	} else {
+		lua_pushboolean(L,false);
+	}
+	return 1;
+}
+
+
+/// bool =3D OgreMaterialAvailable(ressourcename)
+static int l_OgreMaterialAvailable (lua_State *L) { PROFILE
+	assert(0 &amp;&amp; &quot;DON'T USE ME, ALWAYS RETURNS TRUE&quot;);
+	// TODO, this code does not work, use l_OgreMaterialNameKnown  above
+	const char *name =3D luaL_checkstring(L,1);
+	bool ret;
+
+	try {
+		Ogre::MaterialManager::getSingleton().load(name,Ogre::ResourceGroupManag=
er::DEFAULT_RESOURCE_GROUP_NAME);
+		ret =3D true;
+	} catch (...) {
+			ret =3D false;
+	}
+
+	lua_pushboolean(L, ret);
+	return 1;
+}
+
+/// bool =3D OgreTextureAvailable(ressourcename)
+static int l_OgreTextureAvailable (lua_State *L) { PROFILE
+	const char *name =3D luaL_checkstring(L,1);
+	bool ret;
+
+	try {
+		Ogre::TextureManager::getSingleton().load(name,Ogre::ResourceGroupManage=
r::DEFAULT_RESOURCE_GROUP_NAME);
+		ret =3D true;
+	} catch (...) {
+			ret =3D false;
+	}
+
+	lua_pushboolean(L, ret);
+	return 1;
+}
+
+/// r,g,b =3D Uo16Color2Rgb(color)
+static int l_Uo16Color2Rgb (lua_State *L) { PROFILE
+	unsigned short color =3D luaL_checkint(L,1);
+
+	float r =3D float((color &gt;&gt; 10) &amp; 0x1F)/float(0x1f);
+	float g =3D float((color &gt;&gt;  5) &amp; 0x1F)/float(0x1f);
+	float b =3D float((color &gt;&gt;  0) &amp; 0x1F)/float(0x1f);
+
+	lua_pushnumber(L, r);
+	lua_pushnumber(L, g);
+	lua_pushnumber(L, b);
+	return 3;
+}
+
+/// CreateGrannyHuedTexture(GrannyTextureHook(texturepath),GrannyTextureHo=
ok(texturepath),gHueLoader,hue)
+static int l_CreateGrannyHuedTexture (lua_State *L) { PROFILE
+	std::string sTexturePath	=3D luaL_checkstring(L,1);
+	std::string sMaskPath		=3D luaL_checkstring(L,2);
+	cHueLoader *hueLoader 		=3D cLuaBind&lt;cHueLoader&gt;::checkudata(L,3);
+	int iHue					=3D luaL_checkint(L,4);
+
+	if (iHue =3D=3D 0 || !hueLoader) {
+		lua_pushstring(L,sTexturePath.c_str());
+		return 1;
+	}
+
+	// load image
+	Ogre::Image myImage;
+	myImage.load(sTexturePath,Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GR=
OUP_NAME);
+
+	// get image infos
+	Ogre::PixelFormat myFormat =3D myImage.getFormat();
+	unsigned int size =3D myImage.getSize();
+	unsigned int w =3D myImage.getWidth();
+	unsigned int h =3D myImage.getHeight();
+	unsigned int rowspan =3D myImage.getRowSpan();
+	unsigned int pixelsize =3D Ogre::PixelUtil::getNumElemBytes(myFormat);
+	//Ogre::uchar* dst =3D new Ogre::uchar[size];
+	Ogre::uchar* src =3D myImage.getData();
+	//Ogre::uchar* dst_start =3D dst;
+	Ogre::uchar* src_start =3D src;
+	uint8 cr,cg,cb,ca1,ca2;
+	short col;
+
+	// debug info
+	//printf(&quot;image size=3D%d w=3D%d h=3D%d d=3D%d f=3D%d bpp=3D%d rowspan=3D=
%d bIsNonZero2=3D%d\n&quot;,size,w,h,
+	//	myImage.getDepth(),myImage.getNumFaces(),myImage.getBPP(),rowspan,bIsN=
onZero2?1:0);
+
+	// hue filter
+	cHueFilter Filter;
+	short* ColorTable =3D hueLoader-&gt;GetHue( iHue-1 )-&gt;GetColors();
+
+	// colorize the pixels
+	for(unsigned int y =3D 0; y &lt; h; y++){
+		for(unsigned int x =3D 0; x &lt; w; x++) {
+			// read out pixel in src graphic
+			Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca1,myFormat,src);
+			Ogre::PixelUtil::packColour(cr,cg,cb,ca1,Ogre::PF_A1R5G5B5,&amp;col);
+			// and hue the pixel
+			col =3D Filter( col, ColorTable );
+			// TODO ! respect mask instead of hueing the complete texture
+			// and store it in destination (ignoring the new alpha)
+			Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca2,Ogre::PF_A1R5G5B5,&amp;col);
+			Ogre::PixelUtil::packColour(cr,cg,cb,ca1,myFormat,src);
+			src +=3D pixelsize;
+			//dst +=3D pixelsize;
+		}
+		src +=3D rowspan - w*pixelsize;
+	}
+
+	// and make a texture
+	std::string newtextname =3D cOgreWrapper::GetSingleton().GetUniqueName();
+	//Ogre::DataStreamPtr texstream(new Ogre::MemoryDataStream(dst_start, siz=
e));
+	//Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().loadR=
awData(newtextname,
+	//	Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,texstream, w,h=
,myFormat);
+
+	Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().loadIma=
ge(newtextname,
+		Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,myImage,Ogre::TE=
X_TYPE_2D,-1,1.0f,true,Ogre::PF_UNKNOWN);
+
+	// free memory
+	//delete [] dst_start;
+
+	lua_pushstring(L,newtextname.c_str());
+	return 1;
+}
+
+/// void HueMesh(meshname, hueloader, hue)
+static int l_HueMesh (lua_State *L) { PROFILE
 	std::string sMeshName =3D luaL_checkstring(L,1);
-	const char *meshname =3D sMeshName.c_str();
-	cHueLoader *hueLoader =3D cLuaBind&lt;cHueLoader&gt;::checkudata(L,2);
-	int hue =3D luaL_checkint(L,3);
-
-	//printf(&quot;HueMesh(%s,%i,%i)\n&quot;,meshname,hueLoader,hue);
-	if(hueLoader &amp;&amp; hue &amp;&amp; meshname){
-		try	{
+	const char *meshname =3D sMeshName.c_str();
+	cHueLoader *hueLoader =3D cLuaBind&lt;cHueLoader&gt;::checkudata(L,2);
+	int hue =3D luaL_checkint(L,3);
+
+	//printf(&quot;HueMesh(%s,%i,%i)\n&quot;,meshname,hueLoader,hue);
+	if(hueLoader &amp;&amp; hue &amp;&amp; meshname){
+		try	{
 			cHueFilter Filter;
 			cHue* pMyHue =3D hueLoader-&gt;GetHue( hue-1 );
-			if (!pMyHue) return 0;
-			short* ColorTable =3D pMyHue-&gt;GetColors();
+			if (!pMyHue) return 0;
+			short* ColorTable =3D pMyHue-&gt;GetColors();
 			if (!ColorTable) return 0;
-
-			// data seem ok, so read out the mesh
-			Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().load(meshname,=
Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+
+			// data seem ok, so read out the mesh
+			Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().load(meshname,=
Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
 			if (mesh.isNull()) return 0;
-
-			//printf(&quot;mesh=3D%s\n&quot;,mesh-&gt;getName().c_str());
-
-			// and iterate over all submeshes
-			Ogre::Mesh::SubMeshIterator sit =3D mesh-&gt;getSubMeshIterator();
-			while(sit.hasMoreElements()){
-				Ogre::SubMesh *submesh =3D sit.getNext();
-				//printf(&quot;submesh=3D%i\n&quot;,submesh);
-
+
+			//printf(&quot;mesh=3D%s\n&quot;,mesh-&gt;getName().c_str());
+
+			// and iterate over all submeshes
+			Ogre::Mesh::SubMeshIterator sit =3D mesh-&gt;getSubMeshIterator();
+			while(sit.hasMoreElements()){
+				Ogre::SubMesh *submesh =3D sit.getNext();
+				//printf(&quot;submesh=3D%i\n&quot;,submesh);
+
 				if(!submesh) continue;
-				if(!submesh-&gt;isMatInitialised())continue;
-
-				//printf(&quot;matname=3D%s\n&quot;,submesh-&gt;getMaterialName().c_str());
-
-				// create hued texture in the current material and update the current
-				Ogre::MaterialPtr mat =3D Ogre::MaterialManager::getSingleton().load(s=
ubmesh-&gt;getMaterialName(),Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROU=
P_NAME);
-				if(mat.isNull()){
-					printf(&quot;ERROR HueMesh: material %s is null\n&quot;,submesh-&gt;getMaterialNam=
e().c_str());
-					continue;
-				}
-
-				// clone current material for hueing
-				std::string newname =3D cOgreWrapper::GetSingleton().GetUniqueName();
-				Ogre::MaterialPtr mat_hue =3D Ogre::MaterialManager::getSingleton().cr=
eate(newname, mat-&gt;getGroup());
-				//printf(&quot;mat=3D%s mat_hue=3D%s\n&quot;,mat-&gt;getName().c_str(),mat_hue-&gt;get=
Name().c_str());
+				if(!submesh-&gt;isMatInitialised())continue;
+
+				//printf(&quot;matname=3D%s\n&quot;,submesh-&gt;getMaterialName().c_str());
+
+				// create hued texture in the current material and update the current
+				Ogre::MaterialPtr mat =3D Ogre::MaterialManager::getSingleton().load(s=
ubmesh-&gt;getMaterialName(),Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROU=
P_NAME);
+				if(mat.isNull()){
+					printf(&quot;ERROR HueMesh: material %s is null\n&quot;,submesh-&gt;getMaterialNam=
e().c_str());
+					continue;
+				}
+
+				// clone current material for hueing
+				std::string newname =3D cOgreWrapper::GetSingleton().GetUniqueName();
+				Ogre::MaterialPtr mat_hue =3D Ogre::MaterialManager::getSingleton().cr=
eate(newname, mat-&gt;getGroup());
+				//printf(&quot;mat=3D%s mat_hue=3D%s\n&quot;,mat-&gt;getName().c_str(),mat_hue-&gt;get=
Name().c_str());
 				if (mat_hue.isNull()) return 0;
-				mat-&gt;copyDetailsTo(mat_hue);
-
-				// iterate over all techniques
-				Ogre::Material::TechniqueIterator tit =3D mat-&gt;getTechniqueIterator();
-				Ogre::Material::TechniqueIterator tit_hue =3D mat_hue-&gt;getTechniqueIte=
rator();
-				while(tit.hasMoreElements()){
-					Ogre::Technique *tech =3D tit.getNext();
+				mat-&gt;copyDetailsTo(mat_hue);
+
+				// iterate over all techniques
+				Ogre::Material::TechniqueIterator tit =3D mat-&gt;getTechniqueIterator();
+				Ogre::Material::TechniqueIterator tit_hue =3D mat_hue-&gt;getTechniqueIte=
rator();
+				while(tit.hasMoreElements()){
+					Ogre::Technique *tech =3D tit.getNext();
 					Ogre::Technique *tech_hue =3D tit_hue.getNext();
-					if (!tech || !tech_hue) continue;
-
-					// iterate over all passes
-					Ogre::Technique::PassIterator pit =3D tech-&gt;getPassIterator();
-					Ogre::Technique::PassIterator pit_hue =3D tech_hue-&gt;getPassIterator();
-					while(pit.hasMoreElements()){
-						Ogre::Pass *pass =3D pit.getNext();
+					if (!tech || !tech_hue) continue;
+
+					// iterate over all passes
+					Ogre::Technique::PassIterator pit =3D tech-&gt;getPassIterator();
+					Ogre::Technique::PassIterator pit_hue =3D tech_hue-&gt;getPassIterator();
+					while(pit.hasMoreElements()){
+						Ogre::Pass *pass =3D pit.getNext();
 						Ogre::Pass *pass_hue =3D pit_hue.getNext();
-						if (!pass || !pass_hue) continue;
-
-						// iterate over all tex units
-						Ogre::Pass::TextureUnitStateIterator uit =3D pass-&gt;getTextureUnitSta=
teIterator();
-						Ogre::Pass::TextureUnitStateIterator uit_hue =3D pass_hue-&gt;getTextur=
eUnitStateIterator();
-						while(uit.hasMoreElements()){
-							Ogre::TextureUnitState *unit =3D uit.getNext();
+						if (!pass || !pass_hue) continue;
+
+						// iterate over all tex units
+						Ogre::Pass::TextureUnitStateIterator uit =3D pass-&gt;getTextureUnitSta=
teIterator();
+						Ogre::Pass::TextureUnitStateIterator uit_hue =3D pass_hue-&gt;getTextur=
eUnitStateIterator();
+						while(uit.hasMoreElements()){
+							Ogre::TextureUnitState *unit =3D uit.getNext();
 							Ogre::TextureUnitState *unit_hue =3D uit_hue.getNext();
-							if (!unit || !unit_hue) continue;
-
-							// current texture
-							Ogre::TexturePtr tex =3D Ogre::TextureManager::getSingleton().load(=
unit-&gt;getTextureName(),Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_N=
AME);
+							if (!unit || !unit_hue) continue;
+
+							// current texture
+							Ogre::TexturePtr tex =3D Ogre::TextureManager::getSingleton().load(=
unit-&gt;getTextureName(),Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_N=
AME);
 							if (tex.isNull()) continue;
-
-							// lock and read access buffer
+
+							// lock and read access buffer
 							Ogre::HardwarePixelBufferSharedPtr b =3D tex-&gt;getBuffer();
-							if (b.isNull()) continue;
-							// calc size of complete texture
-							Ogre::Image::Box area(0, 0, b-&gt;getWidth(), b-&gt;getHeight());
-							// and lock (ro)
-							const Ogre::PixelBox box =3D b-&gt;lock(area,Ogre::HardwareBuffer::HBL=
_READ_ONLY);
-
-							// size of one pixel in bytes
-							unsigned int pixelsize =3D Ogre::PixelUtil::getNumElemBytes(box.for=
mat);
-							// texture size in bytes
-							unsigned int size =3D box.getConsecutiveSize();
-
-							char *dst =3D new char[size+1024*32]; // add a little security over=
size
-							char *src =3D static_cast&lt;char *&gt;(box.data);
-
-							char *dst_start =3D dst;
-							char *src_start =3D src;
-
-							uint8 cr,cg,cb,ca1,ca2;
+							if (b.isNull()) continue;
+							// calc size of complete texture
+							Ogre::Image::Box area(0, 0, b-&gt;getWidth(), b-&gt;getHeight());
+							// and lock (ro)
+							const Ogre::PixelBox box =3D b-&gt;lock(area,Ogre::HardwareBuffer::HBL=
_READ_ONLY);
+
+							// size of one pixel in bytes
+							unsigned int pixelsize =3D Ogre::PixelUtil::getNumElemBytes(box.for=
mat);
+							// texture size in bytes
+							unsigned int size =3D box.getConsecutiveSize();
+
+							char *dst =3D new char[size+1024*32]; // add a little security over=
size
+							char *src =3D static_cast&lt;char *&gt;(box.data);
+
+							char *dst_start =3D dst;
+							char *src_start =3D src;
+
+							uint8 cr,cg,cb,ca1,ca2;
 							short col;
-							int dummy =3D 0;
-
-							// colorize the pixels
-							for(unsigned int y =3D 0; y &lt; box.getHeight(); y++){
-								for(unsigned int x =3D 0; x &lt; box.getWidth(); x++){
-									// read out pixel in src graphic
-									Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca1,box.format,src);
-									Ogre::PixelUtil::packColour(cr,cg,cb,ca1,Ogre::PF_A1R5G5B5,&amp;col);
-									// and hue the pixel
-									col =3D Filter( col, ColorTable );
-									//printf(&quot;RGBA_1(%i,%i,%i,%i)\n&quot;,cr,cg,cb,ca);
-									// and store it in destination (ignoring the new alpha)
-									Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca2,Ogre::PF_A1R5G5B5,=
&amp;col);
-									Ogre::PixelUtil::packColour(cr,cg,cb,ca1,box.format,dst);
-									//printf(&quot;RGBA_2(%i,%i,%i,%i)\n&quot;,cr,cg,cb,ca);
-									src +=3D pixelsize;
-									dst +=3D pixelsize;
-								}
-								src +=3D box.getRowSkip();
-							}
-
-							// and make a texture
-							Ogre::DataStreamPtr texstream(new Ogre::MemoryDataStream(dst_start,=
 size));
-							Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().c=
reate(cOgreWrapper::GetSingleton().GetUniqueName(),
-								Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
-							assert(!tex_hue.isNull() &amp;&amp; &quot;HueMesh bug&quot;);
-							tex_hue-&gt;loadRawData(texstream,box.getWidth(),box.getHeight(),box.f=
ormat);
-
-							// release the lock
-							b-&gt;unlock();
-
-							// set the texture
+							int dummy =3D 0;
+
+							// colorize the pixels
+							for(unsigned int y =3D 0; y &lt; box.getHeight(); y++){
+								for(unsigned int x =3D 0; x &lt; box.getWidth(); x++){
+									// read out pixel in src graphic
+									Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca1,box.format,src);
+									Ogre::PixelUtil::packColour(cr,cg,cb,ca1,Ogre::PF_A1R5G5B5,&amp;col);
+									// and hue the pixel
+									col =3D Filter( col, ColorTable );
+									//printf(&quot;RGBA_1(%i,%i,%i,%i)\n&quot;,cr,cg,cb,ca);
+									// and store it in destination (ignoring the new alpha)
+									Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca2,Ogre::PF_A1R5G5B5,=
&amp;col);
+									Ogre::PixelUtil::packColour(cr,cg,cb,ca1,box.format,dst);
+									//printf(&quot;RGBA_2(%i,%i,%i,%i)\n&quot;,cr,cg,cb,ca);
+									src +=3D pixelsize;
+									dst +=3D pixelsize;
+								}
+								src +=3D box.getRowSkip();
+							}
+
+							// and make a texture
+							Ogre::DataStreamPtr texstream(new Ogre::MemoryDataStream(dst_start,=
 size));
+							Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().c=
reate(cOgreWrapper::GetSingleton().GetUniqueName(),
+								Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+							assert(!tex_hue.isNull() &amp;&amp; &quot;HueMesh bug&quot;);
+							tex_hue-&gt;loadRawData(texstream,box.getWidth(),box.getHeight(),box.f=
ormat);
+
+							// release the lock
+							b-&gt;unlock();
+
+							// set the texture
 							unit_hue-&gt;setTextureName(tex_hue-&gt;getName());
 =

 							// free memory
-							delete [] dst_start;
-						}
-					}
-				}
-
+							delete [] dst_start;
+						}
+					}
+				}
+
 				// set new material
-				if (mat_hue.isNull()) continue;
-				submesh-&gt;setMaterialName(mat_hue-&gt;getName());
-			}
-		} catch (Ogre::FileNotFoundException e){
-			printf(&quot;ERROR file not found, so HueMesh(%s) canceled\n&quot;,meshname);
-		}
-	}
-
-	return 0;
-}
-
-/// create a lua lookup table based on the given file
-/// usage: lookup[id] =3D new_id
-static int l_CreateLookupTableFromFile (lua_State *L) { PROFILE
-	const char *filename =3D luaL_checkstring(L, 1);
-	lua_newtable(L);
-
-	cFullFileLoader f(filename);
-
-	const uint32 *buffer =3D (const uint32 *)f.mpFullFileBuffer;
-
-	for(int i =3D 0;i &lt; f.miFullFileSize / 4; ++i){
-		lua_pushnumber(L,i); lua_rawseti(L,-2,buffer[i]);
-	}
-
-	return 1;
-}
-
-
-static int l_Client_SetSkybox (lua_State *L) { PROFILE
-	cOgreWrapper::GetSingleton().SetSkybox( (lua_gettop(L) &gt; 0 &amp;&amp; !lua_isnil(=
L,1)) ? luaL_checkstring(L, 1) : 0 , true );
-	return 0;
-}
-
-static int l_Client_SetFog (lua_State *L) { PROFILE
-	int i=3D0;
-	int numargs=3Dlua_gettop(L);
-	int iFogMode 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checkint(L,=
 ++i) : 0;
-	Ogre::Real r 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
-	Ogre::Real g 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
-	Ogre::Real b 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
-	Ogre::Real a 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
-	Ogre::Real expDensity 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_chec=
knumber(L, ++i) : 0.001;
-	Ogre::Real linearStart 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_che=
cknumber(L, ++i) : 0.0;
-	Ogre::Real linearEnd 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_check=
number(L, ++i) : 1.0;
-	/*
-	void 	setFog (FogMode mode=3DFOG_NONE, const ColourValue &amp;colour=3DColour=
Value::White,
-					Real expDensity=3D0.001, Real linearStart=3D0.0, Real linearEnd=3D1.0)
-    0=3DFOG_NONE 	No fog. Duh.
-    1=3DFOG_EXP 	Fog density increases exponentially from the camera (fog =
=3D 1/e^(distance * density)).
-    2=3DFOG_EXP2 	Fog density increases at the square of FOG_EXP, i.e. eve=
n quicker (fog =3D 1/e^(distance * density)^2).
-    3=3DFOG_LINEAR 	Fog density increases linearly between the start and e=
nd distances.
-	*/
-	Ogre::FogMode      myFogMode =3D Ogre::FOG_NONE;
-	if (iFogMode =3D=3D 1) myFogMode =3D Ogre::FOG_EXP;
-	if (iFogMode =3D=3D 2) myFogMode =3D Ogre::FOG_EXP2;
-	if (iFogMode =3D=3D 3) myFogMode =3D Ogre::FOG_LINEAR;
-	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setFog(myFogMode,Ogre::ColourValu=
e(r,g,b,a),expDensity,linearStart,linearEnd);
-	return 0;
-}
-
-static int l_Client_RenderOneFrame (lua_State *L) { PROFILE
-	cGame::GetSingleton().RenderOneFrame();
-	return 0;
-}
-
-/// just do nothing for x seconds
-static int l_Client_Sleep (lua_State *L) { PROFILE
-	//TODO correct win handling
-#ifndef WIN32
-	sleep(luaL_checkint(L,1));
-#else
-	Sleep(luaL_checkint(L,1)*1000); // takes milliseconds
-#endif
-	return 0;
-}
-
-/// just do nothing for x milliseconds (1000msec =3D 1sec)
-static int l_Client_USleep (lua_State *L) { PROFILE
-	//TODO correct win handling
-#ifndef WIN32
-	usleep((uint32)luaL_checkint(L,1)*(uint32)1000L); // usleep takes MICROse=
conds, where 1000 =3D 1 MILLIsecond
-#else
-	Sleep(luaL_checkint(L,1)); // takes milliseconds
-#endif
-	return 0;
-}
-
-
-
-static int l_Client_SetAmbientLight (lua_State *L) { PROFILE
-	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
-	if (pSceneMgr) pSceneMgr-&gt;setAmbientLight(Ogre::ColourValue(luaL_checknum=
ber(L,1),luaL_checknumber(L,2),luaL_checknumber(L,3),luaL_checknumber(L,4))=
);
-	return 0;
-}
-
-static int l_Client_ClearLights (lua_State *L) { PROFILE
-	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
-	if (pSceneMgr) pSceneMgr-&gt;destroyAllLights();
-	return 0;
-}
-
-static int l_Client_AddPointLight (lua_State *L) { PROFILE
-	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
+				if (mat_hue.isNull()) continue;
+				submesh-&gt;setMaterialName(mat_hue-&gt;getName());
+			}
+		} catch (Ogre::FileNotFoundException e){
+			printf(&quot;ERROR file not found, so HueMesh(%s) canceled\n&quot;,meshname);
+		}
+	}
+
+	return 0;
+}
+
+/// create a lua lookup table based on the given file
+/// usage: lookup[id] =3D new_id
+static int l_CreateLookupTableFromFile (lua_State *L) { PROFILE
+	const char *filename =3D luaL_checkstring(L, 1);
+	lua_newtable(L);
+
+	cFullFileLoader f(filename);
+
+	const uint32 *buffer =3D (const uint32 *)f.mpFullFileBuffer;
+
+	for(int i =3D 0;i &lt; f.miFullFileSize / 4; ++i){
+		lua_pushnumber(L,i); lua_rawseti(L,-2,buffer[i]);
+	}
+
+	return 1;
+}
+
+
+static int l_Client_SetSkybox (lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().SetSkybox( (lua_gettop(L) &gt; 0 &amp;&amp; !lua_isnil(=
L,1)) ? luaL_checkstring(L, 1) : 0 , true );
+	return 0;
+}
+
+static int l_Client_SetFog (lua_State *L) { PROFILE
+	int i=3D0;
+	int numargs=3Dlua_gettop(L);
+	int iFogMode 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checkint(L,=
 ++i) : 0;
+	Ogre::Real r 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
+	Ogre::Real g 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
+	Ogre::Real b 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
+	Ogre::Real a 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
+	Ogre::Real expDensity 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_chec=
knumber(L, ++i) : 0.001;
+	Ogre::Real linearStart 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_che=
cknumber(L, ++i) : 0.0;
+	Ogre::Real linearEnd 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_check=
number(L, ++i) : 1.0;
+	/*
+	void 	setFog (FogMode mode=3DFOG_NONE, const ColourValue &amp;colour=3DColour=
Value::White,
+					Real expDensity=3D0.001, Real linearStart=3D0.0, Real linearEnd=3D1.0)
+    0=3DFOG_NONE 	No fog. Duh.
+    1=3DFOG_EXP 	Fog density increases exponentially from the camera (fog =
=3D 1/e^(distance * density)).
+    2=3DFOG_EXP2 	Fog density increases at the square of FOG_EXP, i.e. eve=
n quicker (fog =3D 1/e^(distance * density)^2).
+    3=3DFOG_LINEAR 	Fog density increases linearly between the start and e=
nd distances.
+	*/
+	Ogre::FogMode      myFogMode =3D Ogre::FOG_NONE;
+	if (iFogMode =3D=3D 1) myFogMode =3D Ogre::FOG_EXP;
+	if (iFogMode =3D=3D 2) myFogMode =3D Ogre::FOG_EXP2;
+	if (iFogMode =3D=3D 3) myFogMode =3D Ogre::FOG_LINEAR;
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setFog(myFogMode,Ogre::ColourValu=
e(r,g,b,a),expDensity,linearStart,linearEnd);
+	return 0;
+}
+
+static int l_Client_RenderOneFrame (lua_State *L) { PROFILE
+	cGame::GetSingleton().RenderOneFrame();
+	return 0;
+}
+
+/// just do nothing for x seconds
+static int l_Client_Sleep (lua_State *L) { PROFILE
+	//TODO correct win handling
+#ifndef WIN32
+	sleep(luaL_checkint(L,1));
+#else
+	Sleep(luaL_checkint(L,1)*1000); // takes milliseconds
+#endif
+	return 0;
+}
+
+/// just do nothing for x milliseconds (1000msec =3D 1sec)
+static int l_Client_USleep (lua_State *L) { PROFILE
+	//TODO correct win handling
+#ifndef WIN32
+	usleep((uint32)luaL_checkint(L,1)*(uint32)1000L); // usleep takes MICROse=
conds, where 1000 =3D 1 MILLIsecond
+#else
+	Sleep(luaL_checkint(L,1)); // takes milliseconds
+#endif
+	return 0;
+}
+
+
+
+static int l_Client_SetAmbientLight (lua_State *L) { PROFILE
+	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
+	if (pSceneMgr) pSceneMgr-&gt;setAmbientLight(Ogre::ColourValue(luaL_checknum=
ber(L,1),luaL_checknumber(L,2),luaL_checknumber(L,3),luaL_checknumber(L,4))=
);
+	return 0;
+}
+
+static int l_Client_ClearLights (lua_State *L) { PROFILE
+	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
+	if (pSceneMgr) pSceneMgr-&gt;destroyAllLights();
+	return 0;
+}
+
+static int l_Client_AddPointLight (lua_State *L) { PROFILE
+	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
 	if (!pSceneMgr) return 0;
-	std::string sName =3D cOgreWrapper::GetSingleton().GetUniqueName();
-	Ogre::Light* pLight =3D pSceneMgr-&gt;createLight( sName );
-	pLight-&gt;setType( Ogre::Light::LT_POINT );
-	pLight-&gt;setPosition(luaL_checknumber(L,1),luaL_checknumber(L,2),luaL_chec=
knumber(L,3));
-	pLight-&gt;setDiffuseColour(luaL_checknumber(L,4),luaL_checknumber(L,5),luaL=
_checknumber(L,6));
-	pLight-&gt;setSpecularColour(luaL_checknumber(L,7),luaL_checknumber(L,8),lua=
L_checknumber(L,9));
-	pLight-&gt;setAttenuation(luaL_checknumber(L,10),luaL_checknumber(L,11),luaL=
_checknumber(L,12),luaL_checknumber(L,13));
+	std::string sName =3D cOgreWrapper::GetSingleton().GetUniqueName();
+	Ogre::Light* pLight =3D pSceneMgr-&gt;createLight( sName );
+	pLight-&gt;setType( Ogre::Light::LT_POINT );
+	pLight-&gt;setPosition(luaL_checknumber(L,1),luaL_checknumber(L,2),luaL_chec=
knumber(L,3));
+	pLight-&gt;setDiffuseColour(luaL_checknumber(L,4),luaL_checknumber(L,5),luaL=
_checknumber(L,6));
+	pLight-&gt;setSpecularColour(luaL_checknumber(L,7),luaL_checknumber(L,8),lua=
L_checknumber(L,9));
+	pLight-&gt;setAttenuation(luaL_checknumber(L,10),luaL_checknumber(L,11),luaL=
_checknumber(L,12),luaL_checknumber(L,13));
 	pLight-&gt;setCastShadows(false);
-	lua_pushstring(L,sName.c_str());
-	return 1;
+	lua_pushstring(L,sName.c_str());
+	return 1;
 }
 =

 static int l_Client_AddDirectionalLight (lua_State *L) { PROFILE
@@ -726,416 +729,418 @@
 	if (pSceneMgr) pSceneMgr-&gt;destroyLight(luaL_checkstring(L,1));
 	return 0;
 }
-
-
-static int l_Client_GetPhysStepTime (lua_State *L) { PROFILE
-	lua_pushnumber(L,cTimer::mfPhysStepTime);
-	return 1;
-}
-
-/// saved in main directory
-static int l_Client_TakeGridScreenshot (lua_State *L) { PROFILE
-	std::string filename =3D strprintf( &quot;%shighres_%d&quot;, &quot;../screenshots/&quot;, cS=
hell::GetTicks() );
-	std::string ext =3D &quot;.jpg&quot;;
-	cOgreWrapper::GetSingleton().TakeGridScreenshot(3,filename,ext,true);
-	return 0;
-}
-
-/// saved in main directory
-static int l_Client_TakeScreenshot (lua_State *L) { PROFILE
-	cOgreWrapper::GetSingleton().TakeScreenshot();
-	return 0;
-}
-
-void	OgreForceCloseFullscreen ();
-
-/// shows ogre config dialog
-static int l_Client_ShowOgreConfig (lua_State *L) { PROFILE
-	bool bIsFullscreen =3D cOgreWrapper::GetSingleton().mWindow-&gt;isFullScreen=
();
-	printf(&quot;Client_ShowOgreConfig fullscreen=3D%d\n&quot;,bIsFullscreen);
-	bIsFullscreen =3D true; // detection fails in linux ?
-	if (bIsFullscreen) {
-		// hide window to make config window visible in fullscreen mode, evil ha=
ck since this is not supported by ogre
-		OgreForceCloseFullscreen();
-	}
-	lua_pushboolean(L,cOgreWrapper::GetSingleton().mRoot-&gt;showConfigDialog());
-	if (bIsFullscreen) cShell::mbAlive =3D false;
-	// the application shoudl terminate after this
-	// terminates the game if changes were made
-	return 1;
-}
-
-static int l_BuildTerrainEntity_Simple (lua_State *L) { PROFILE
-	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
-	if (!pGroundBlockLoader) return 0;
-	int i=3D5;
-	bool bGenerateNormals=3D		(lua_gettop(L) &gt;=3D ++i &amp;&amp; !lua_isnil(L,i)) ? l=
ua_toboolean(L,i) : true;
-	std::string meshname =3D BuildTerrainEntity_Simple(
-		pGroundBlockLoader,
-		luaL_checkint(L,2),luaL_checkint(L,3),
-		luaL_checkint(L,4),luaL_checkint(L,5),bGenerateNormals);
-	if (meshname.length() =3D=3D 0) return 0;
-	lua_pushstring(L,meshname.c_str());
-	return 1;
-}
-
-static int l_BuildTerrainEntity_Shaded (lua_State *L) { PROFILE
-	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
-	if (!pGroundBlockLoader) return 0;
-	std::string meshname =3D BuildTerrainEntity_Shaded(
-		pGroundBlockLoader,
-		luaL_checkint(L,2),luaL_checkint(L,3),
-		luaL_checkint(L,4),luaL_checkint(L,5));
-	if (meshname.length() =3D=3D 0) return 0;
-	lua_pushstring(L,meshname.c_str());
-	return 1;
-}
-
-/// OBSOLETED CODE ! don't use this, hasn't been adjusted to xmirror fix
-/// for lua : TerrainRayPick(GroundBlockLoader,blockx,blocky,vBlockPosX,vB=
lockPosY,vBlockPosZ,rx,ry,rz,rvx,rvy,rvz)  -- mainly for mousepicking
-static int l_TerrainRayPick (lua_State *L) { PROFILE
-	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
-	if (!pGroundBlockLoader) return 0;
-
-	// don't use ++i or something here, the compiler might mix the order
-	Ogre::Vector3 	vBlockPos(luaL_checknumber(L,4),luaL_checknumber(L,5),luaL=
_checknumber(L,6));
-	Ogre::Vector3	vRayPos(luaL_checknumber(L,7),luaL_checknumber(L,8),luaL_ch=
ecknumber(L,9));
-	Ogre::Vector3	vRayDir(luaL_checknumber(L,10),luaL_checknumber(L,11),luaL_=
checknumber(L,12));
-
-	// feedback via lua callback TerrainRayIntersect_Hit()
-	TerrainRayIntersect(pGroundBlockLoader,luaL_checkint(L,2),luaL_checkint(L=
,3),vRayPos-vBlockPos,vRayDir);
-	return 0;
-}
-
-/// for lua : dist =3D SphereRayPick(x,y,z,rad,rx,ry,rz,rvx,rvy,rvz)  -- m=
ainly for mousepicking, dist=3Dnil if not hit
-static int l_SphereRayPick (lua_State *L) { PROFILE
-	// don't use ++i or something here, the compiler might mix the order
-	Ogre::Vector3 	vSpherePos(	luaL_checknumber(L,1),luaL_checknumber(L,2),lu=
aL_checknumber(L,3));
-	float			fSphereRad =3D luaL_checknumber(L,4);
-	Ogre::Vector3	vRayPos(	luaL_checknumber(L,5),luaL_checknumber(L,6),luaL_c=
hecknumber(L,7));
-	Ogre::Vector3	vRayDir(	luaL_checknumber(L,8),luaL_checknumber(L,9),luaL_c=
hecknumber(L,10));
-
-	std::pair&lt;bool, Real&gt; hit =3D Ogre::Ray(vRayPos,vRayDir).intersects(Ogre:=
:<i>Sphere(vSpherePos,fSphereRad));
</I>-	if (!hit.first) return 0;
-	lua_pushnumber(L,hit.second);
-	return 1;
-}
-
-
+
+
+static int l_Client_GetPhysStepTime (lua_State *L) { PROFILE
+	lua_pushnumber(L,cTimer::mfPhysStepTime);
+	return 1;
+}
+
+/// saved in main directory
+static int l_Client_TakeGridScreenshot (lua_State *L) { PROFILE
+	std::string filename =3D strprintf( &quot;%shighres_%d&quot;, &quot;../screenshots/&quot;, cS=
hell::GetTicks() );
+	std::string ext =3D &quot;.jpg&quot;;
+	cOgreWrapper::GetSingleton().TakeGridScreenshot(3,filename,ext,true);
+	return 0;
+}
+
+/// saved in main directory
+static int l_Client_TakeScreenshot (lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().TakeScreenshot();
+	return 0;
+}
+
+void	OgreForceCloseFullscreen ();
+
+/// shows ogre config dialog
+static int l_Client_ShowOgreConfig (lua_State *L) { PROFILE
+	bool bIsFullscreen =3D cOgreWrapper::GetSingleton().mWindow-&gt;isFullScreen=
();
+	printf(&quot;Client_ShowOgreConfig fullscreen=3D%d\n&quot;,bIsFullscreen);
+	bIsFullscreen =3D true; // detection fails in linux ?
+	if (bIsFullscreen) {
+		// hide window to make config window visible in fullscreen mode, evil ha=
ck since this is not supported by ogre
+		OgreForceCloseFullscreen();
+	}
+	lua_pushboolean(L,cOgreWrapper::GetSingleton().mRoot-&gt;showConfigDialog());
+	if (bIsFullscreen) cShell::mbAlive =3D false;
+	// the application shoudl terminate after this
+	// terminates the game if changes were made
+	return 1;
+}
+
+static int l_BuildTerrainEntity_Simple (lua_State *L) { PROFILE
+	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
+	if (!pGroundBlockLoader) return 0;
+	int i=3D5;
+	bool bGenerateNormals=3D		(lua_gettop(L) &gt;=3D ++i &amp;&amp; !lua_isnil(L,i)) ? l=
ua_toboolean(L,i) : true;
+	std::string meshname =3D BuildTerrainEntity_Simple(
+		pGroundBlockLoader,
+		luaL_checkint(L,2),luaL_checkint(L,3),
+		luaL_checkint(L,4),luaL_checkint(L,5),bGenerateNormals);
+	if (meshname.length() =3D=3D 0) return 0;
+	lua_pushstring(L,meshname.c_str());
+	return 1;
+}
+
+static int l_BuildTerrainEntity_Shaded (lua_State *L) { PROFILE
+	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
+	if (!pGroundBlockLoader) return 0;
+	std::string meshname =3D BuildTerrainEntity_Shaded(
+		pGroundBlockLoader,
+		luaL_checkint(L,2),luaL_checkint(L,3),
+		luaL_checkint(L,4),luaL_checkint(L,5));
+	if (meshname.length() =3D=3D 0) return 0;
+	lua_pushstring(L,meshname.c_str());
+	return 1;
+}
+
+/// OBSOLETED CODE ! don't use this, hasn't been adjusted to xmirror fix
+/// for lua : TerrainRayPick(GroundBlockLoader,blockx,blocky,vBlockPosX,vB=
lockPosY,vBlockPosZ,rx,ry,rz,rvx,rvy,rvz)  -- mainly for mousepicking
+static int l_TerrainRayPick (lua_State *L) { PROFILE
+	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
+	if (!pGroundBlockLoader) return 0;
+
+	// don't use ++i or something here, the compiler might mix the order
+	Ogre::Vector3 	vBlockPos(luaL_checknumber(L,4),luaL_checknumber(L,5),luaL=
_checknumber(L,6));
+	Ogre::Vector3	vRayPos(luaL_checknumber(L,7),luaL_checknumber(L,8),luaL_ch=
ecknumber(L,9));
+	Ogre::Vector3	vRayDir(luaL_checknumber(L,10),luaL_checknumber(L,11),luaL_=
checknumber(L,12));
+
+	// feedback via lua callback TerrainRayIntersect_Hit()
+	TerrainRayIntersect(pGroundBlockLoader,luaL_checkint(L,2),luaL_checkint(L=
,3),vRayPos-vBlockPos,vRayDir);
+	return 0;
+}
+
+/// for lua : dist =3D SphereRayPick(x,y,z,rad,rx,ry,rz,rvx,rvy,rvz)  -- m=
ainly for mousepicking, dist=3Dnil if not hit
+static int l_SphereRayPick (lua_State *L) { PROFILE
+	// don't use ++i or something here, the compiler might mix the order
+	Ogre::Vector3 	vSpherePos(	luaL_checknumber(L,1),luaL_checknumber(L,2),lu=
aL_checknumber(L,3));
+	float			fSphereRad =3D luaL_checknumber(L,4);
+	Ogre::Vector3	vRayPos(	luaL_checknumber(L,5),luaL_checknumber(L,6),luaL_c=
hecknumber(L,7));
+	Ogre::Vector3	vRayDir(	luaL_checknumber(L,8),luaL_checknumber(L,9),luaL_c=
hecknumber(L,10));
+
+	std::pair&lt;bool, Real&gt; hit =3D Ogre::Ray(vRayPos,vRayDir).intersects(Ogre:=
:<i>Sphere(vSpherePos,fSphereRad));
</I>+	if (!hit.first) return 0;
+	lua_pushnumber(L,hit.second);
+	return 1;
+}
+
+
 static int l_UnloadMeshName (lua_State *L) { PROFILE
 	const char* szMeshName =3D luaL_checkstring(L,1);
 	Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().load(szMeshName,=
Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
 	if (mesh.isNull()) return 0;
 	mesh-&gt;unload();
-	UnloadMeshShape(szMeshName);
-	//Ogre::MeshManager::getSingleton().unload(luaL_checkstring(L,1));
-	return 0;
-}
-
-static int l_CountMeshTriangles (lua_State *L) { PROFILE
-	Ogre::MeshPtr pMesh =3D Ogre::MeshManager::getSingleton().load(luaL_check=
string(L,1),
-					Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
-	int res =3D 0;
-	for (int i=3D0;i&lt;pMesh-&gt;getNumSubMeshes();++i) {
-		Ogre::SubMesh *pSub =3D pMesh-&gt;getSubMesh(i);
-		if (pSub &amp;&amp; pSub-&gt;indexData) res +=3D pSub-&gt;indexData-&gt;indexCount / 3;
-	}
-	lua_pushnumber(L,res);
-	return 1;
-}
-
-static int l_getUOPath(lua_State *L) { PROFILE
-	std::string res =3D getUOPath();
-	if (res.length() =3D=3D 0) return 0;
-	lua_pushstring(L,res.c_str());
-	return 1;
-}
-
-/// attempts to correct case-sensitivity for filepaths
-static int l_PathSearch (lua_State *L) { PROFILE
-	std::string res =3D rob_pathsearch(luaL_checkstring(L,1));
-	if (res.length() =3D=3D 0) return 0;
-	lua_pushstring(L,res.c_str());
-	return 1;
-}
-
-static int l_file_exists (lua_State *L) { PROFILE
-	std::ifstream	myFileStream(luaL_checkstring(L,1));
-	lua_pushboolean(L,myFileStream?true:false);
-	return 1;
-}
-
-static int l_file_size (lua_State *L) { PROFILE
-	std::ifstream	myFileStream(luaL_checkstring(L,1));
-	int iFileSize =3D 0;
-	if (myFileStream) {
-		myFileStream.seekg(0, std::ios::end);
-		iFileSize =3D myFileStream.tellg();
-	}
-	lua_pushnumber(L,iFileSize);
-	return 1;
-}
-
-
-// for testing bitwise ops
-static int l_GetRandomHexString 	(lua_State *L) { PROFILE lua_pushstring( =
L, strprintf(&quot;0x%08x&quot;,rand()).c_str()); return 1; }
-
-/// converts &quot;0x1234&quot; to a number
-static int l_Hex2Num 	(lua_State *L) { PROFILE
-	std::string hexcode =3D luaL_checkstring(L,1);
-	uint32 res =3D 0;
-	sscanf(hexcode.c_str(),&quot;0x%x&quot;,&amp;res);
-	lua_pushnumber(L, res);
-	return 1;
-}
-
-// bitwise operations, used for networking, packet manipulation etc
-static int l_BitwiseAND 	(lua_State *L) { PROFILE
-	// keep this spread out like this to avoid strange, 32 bi
-	double g =3D luaL_checknumber(L,1);
-	double h =3D luaL_checknumber(L,2);
-	uint32 a =3D uint32(g);
-	uint32 b =3D uint32(h);
-	uint32 c =3D a &amp; b;
-	lua_pushnumber( L, c);
-	return 1;
-}
-static int l_BitwiseOR 		(lua_State *L) { PROFILE
-	// keep this spread out like this to avoid strange, 32 bi
-	double g =3D luaL_checknumber(L,1);
-	double h =3D luaL_checknumber(L,2);
-	uint32 a =3D uint32(g);
-	uint32 b =3D uint32(h);
-	uint32 c =3D a | b;
-	lua_pushnumber( L, c);
-	return 1;
-}
-
-
-static int l_BitwiseXOR 	(lua_State *L) { PROFILE
-	// keep this spread out like this to avoid strange, 32 bi
-	double g =3D luaL_checknumber(L,1);
-	double h =3D luaL_checknumber(L,2);
-	uint32 a =3D uint32(g);
-	uint32 b =3D uint32(h);
-	uint32 c =3D a ^ b;
-	lua_pushnumber( L, c);
-	return 1;
-}
-
-// bitwise operations, used for networking, packet manipulation etc
-static int l_BitwiseSHL 	(lua_State *L) { PROFILE
-	// keep this spread out like this to avoid strange, 32 bi
-	double g =3D luaL_checknumber(L,1);
-	double h =3D luaL_checknumber(L,2);
-	uint32 a =3D uint32(g);
-	uint32 b =3D uint32(h);
-	uint32 c =3D a &lt;&lt; b;
-	lua_pushnumber( L, c);
-	return 1;
-}
-// bitwise operations, used for networking, packet manipulation etc
-static int l_BitwiseSHR 	(lua_State *L) { PROFILE
-	// keep this spread out like this to avoid strange, 32 bi
-	double g =3D luaL_checknumber(L,1);
-	double h =3D luaL_checknumber(L,2);
-	uint32 a =3D uint32(g);
-	uint32 b =3D uint32(h);
-	uint32 c =3D a &gt;&gt; b;
-	lua_pushnumber( L, c);
-	return 1;
-}
-
-
-static int l_TestBit 		(lua_State *L) { PROFILE lua_pushboolean(L,(uint32(=
luaL_checknumber(L,1)) &amp; (uint32(1) &lt;&lt; luaL_checkint(L,2))) !=3D 0); return=
 1; }
-static int l_SetBit 		(lua_State *L) { PROFILE lua_pushnumber( L,(uint32(l=
uaL_checknumber(L,1)) | (uint32(1) &lt;&lt; luaL_checkint(L,2)))); return 1; }
-static int l_ClearBit 		(lua_State *L) { PROFILE
-	uint32 input =3D uint32(luaL_checknumber(L,1));
-	uint32 mask =3D 1L &lt;&lt; uint32(luaL_checknumber(L,2));
-	lua_pushnumber(L,(input &amp; mask)?(input ^ mask):(input));  // XOR =3D ^ =
=3D toggle bit... toggle only if set (&amp;) to clear
-	return 1;
-}
-
-
-static int l_Exit		 		(lua_State *L) { PROFILE
-	exit((lua_gettop(L) &gt;=3D 1 &amp;&amp; !lua_isnil(L,1)) ? luaL_checkint(L,1) : 0);
-	return 0;
-}
-
-static int l_Crash		 		(lua_State *L) { PROFILE
-	DisplayErrorMessage(&quot;CRASH triggered from script, see console for info (s=
tart with commandline option -c)&quot;);
-	exit(88);
-	return 0;
-}
-
-/// triggers a segfault, for testing our segfault handlers lua stacktrace
-static int l_CrashSegFault		 		(lua_State *L) { PROFILE
-	DisplayErrorMessage(&quot;testing segfault handler...&quot;);
-	*((char*)0) =3D 0; // trigger segfault
-	return 0;
-}
-
-
-static int l_DisplayNotice	(lua_State *L) { PROFILE
-	DisplayNotice(luaL_checkstring(L,1));
-	return 0;
-}
-
-
-static int l_FatalErrorMessage	(lua_State *L) { PROFILE
-	DisplayErrorMessage(luaL_checkstring(L,1));
-	exit(77);
-	return 0;
-}
-
-
-/// for lua :   void  ExportMesh  (meshname,filename)
-static int l_ExportMesh		(lua_State *L) { PROFILE
-	Ogre::MeshPtr pMesh =3D Ogre::MeshManager::getSingleton().load(luaL_check=
string(L,1),
-					// autodetect group location
-					//Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
-					Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
-	Ogre::MeshSerializer myExporter;
-	//Ogre::Mesh* pMesh =3D pEntity-&gt;getMesh().get();
-	myExporter.exportMesh(pMesh.get(),luaL_checkstring(L,2));
-	return 0;
-}
-
-/// for lua :   x,y,z,vx,vy,vz  GetMouseRay  ()
-static int l_GetMouseRay		(lua_State *L) { PROFILE
-	cOgreWrapper&amp; ogrewrapper =3D cOgreWrapper::GetSingleton();
-	Ogre::Ray myray(	ogrewrapper.mCamera-&gt;getCameraToViewportRay(
-				Ogre::Real(cInput::iMouse[0]) / Ogre::Real(ogrewrapper.mViewport-&gt;getA=
ctualWidth()),
-				Ogre::Real(cInput::iMouse[1]) / Ogre::Real(ogrewrapper.mViewport-&gt;getA=
ctualHeight()) ));
-	lua_pushnumber(L,myray.getOrigin().x);
-	lua_pushnumber(L,myray.getOrigin().y);
-	lua_pushnumber(L,myray.getOrigin().z);
-	lua_pushnumber(L,myray.getDirection().x);
-	lua_pushnumber(L,myray.getDirection().y);
-	lua_pushnumber(L,myray.getDirection().z);
-	return 6;
-}
-
-/// for lua :   z  GetMaxZ  ()
-static int 		l_GetMaxZ		(lua_State *L) { PROFILE
-	lua_pushnumber(L,Ogre::Root::getSingleton().getRenderSystem()-&gt;getMaximum=
DepthInputValue());
-	return 1;
-}
-
-
-/// for lua :   bIsInFront,px,py  ProjectPos  (x,y,z)
-static int l_ProjectPos		(lua_State *L) { PROFILE
-	bool 		bIsInFront;
-	Ogre::Real	fX,fY;
-	bIsInFront =3D cOgreWrapper::GetSingleton().ProjectPos(
-		Ogre::Vector3(luaL_checknumber(L,0),luaL_checknumber(L,1),luaL_checknumb=
er(L,2)),fX,fY);
-	lua_pushboolean(L,bIsInFront);
-	lua_pushnumber(L,fX);
-	lua_pushnumber(L,fY);
-	return 3;
-}
-
-/// for lua :   bIsInFront,px,py,cx,cy  ProjectSizeAndPos  (x,y,z,r)
-static int l_ProjectSizeAndPos		(lua_State *L) { PROFILE
-	bool 		bIsInFront;
-	Ogre::Real	fX,fY,fCX,fCY;
-	bIsInFront =3D cOgreWrapper::GetSingleton().ProjectSizeAndPos(
-		Ogre::Vector3(luaL_checknumber(L,0),luaL_checknumber(L,1),luaL_checknumb=
er(L,2)),fX,fY,luaL_checknumber(L,3),fCX,fCY);
-	lua_pushboolean(L,bIsInFront);
-	lua_pushnumber(L,fX);
-	lua_pushnumber(L,fY);
-	lua_pushnumber(L,fCX);
-	lua_pushnumber(L,fCY);
-	return 5;
-}
-
-
-
-/// for lua :   void  CreateSceneManager  (sSceneManagerName)
-static int l_CreateSceneManager		(lua_State *L) { PROFILE  // TODO : move =
to seperate file ?
-	cOgreWrapper::GetSingleton().mRoot-&gt;createSceneManager(Ogre::ST_GENERIC,l=
uaL_checkstring(L,1));
-	return 0;
-}
-
-/// for lua :   table[id=3Dtexname...]  OgreMeshTextures  (meshfile)
-static int l_OgreMeshTextures	(lua_State *L) { PROFILE  // TODO : move to =
seperate file ?
-	Ogre::MeshSerializer* meshSerializer =3D new Ogre::MeshSerializer();
-	const char *szMeshName =3D luaL_checkstring(L,1);
-
-	lua_newtable(L);
-
-	//printf(&quot;open file: %s\n&quot;,szMeshName);
-	// model file
-	std::ifstream ifs;
-	ifs.open(szMeshName, std::ios_base::in | std::ios_base::binary);
-	Ogre::DataStreamPtr stream(new Ogre::FileStreamDataStream(&amp;ifs, false));
-
-	if(ifs.is_open()){
-		//printf(&quot;create tmp mesh\n&quot;);
-		// create tmp mesh import resource
-		Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().create(&quot;l_OgreM=
eshTextureMissing_conversion&quot;,
-			Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
-
-		//printf(&quot;import\n&quot;);
-		// import
-		meshSerializer-&gt;importMesh(stream, mesh.getPointer());
-
-		if(!mesh.isNull()){
-			// iterator over submeshes
-			Ogre::Mesh::SubMeshIterator it =3D mesh-&gt;getSubMeshIterator();
-			int i =3D 1;
-			while(it.hasMoreElements()){
-				Ogre::SubMesh *submesh =3D it.getNext();
-				std::string tex =3D submesh-&gt;getMaterialName();
-				//printf(&quot;material found: %s\n&quot;,tex.c_str());
-				lua_pushstring(L,tex.c_str()); lua_rawseti(L,-2,i);
-				++i;
-			}
-		}
-
-		// remove all stuff
-		Ogre::MeshManager::getSingleton().remove(&quot;l_OgreMeshTextureMissing_conve=
rsion&quot;);
-
-		ifs.close();
-	} else {
-		printf(&quot;ERROR can't open file: %s\n&quot;,szMeshName);
-	}
-
-	delete meshSerializer;
-
-	return 1;
-}
-
-
-/// for lua :   void OgreShadowTechnique  (string techique)
-static int l_OgreShadowTechnique	(lua_State *L) { PROFILE  // TODO : move =
to seperate file ?
-	const char *tech =3D luaL_checkstring(L,1);
-	Ogre::SceneManager *p =3D cOgreWrapper::GetSingleton().mSceneMgr;
-
-	if(p){
-		if(strcmp(tech,&quot;stencil_modulative&quot;) =3D=3D 0)p-&gt;setShadowTechnique(Ogre=
::<i>SHADOWTYPE_STENCIL_MODULATIVE);
</I>-		else if(strcmp(tech,&quot;stencil_additive&quot;) =3D=3D 0)p-&gt;setShadowTechnique(O=
gre::SHADOWTYPE_STENCIL_ADDITIVE);
-		else if(strcmp(tech,&quot;texture_modulative&quot;) =3D=3D 0)p-&gt;setShadowTechnique=
(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE);
-		else if(strcmp(tech,&quot;texture_additive&quot;) =3D=3D 0)p-&gt;setShadowTechnique(O=
gre::SHADOWTYPE_TEXTURE_ADDITIVE);
-		else if(strcmp(tech,&quot;texture_additive_integrated&quot;) =3D=3D 0)p-&gt;setShadow=
Technique(Ogre::SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED);
-		else if(strcmp(tech,&quot;texture_modulative_integrated&quot;) =3D=3D 0)p-&gt;setShad=
owTechnique(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED);
-		else p-&gt;setShadowTechnique(Ogre::SHADOWTYPE_NONE);
-	}
-    return 0;
-}
-
-/// for lua :   void	  OgreSetShadowTextureSize  (int size)
-static int 				l_OgreSetShadowTextureSize	(lua_State *L) { PROFILE
-	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureSize(luaL_checkin=
t(L,1));
-	return 0;
-}
-
-
-
-/// for lua :   void	  OgreSetShadowFarDistance	(float x)
-static int 				l_OgreSetShadowFarDistance	(lua_State *L) { PROFILE
-	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowFarDistance(luaL_checknu=
mber(L,1));
-	return 0;
+	UnloadMeshShape(szMeshName);
+	//Ogre::MeshManager::getSingleton().unload(luaL_checkstring(L,1));
+	return 0;
+}
+
+static int l_CountMeshTriangles (lua_State *L) { PROFILE
+	Ogre::MeshPtr pMesh =3D Ogre::MeshManager::getSingleton().load(luaL_check=
string(L,1),
+					Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
+	int res =3D 0;
+	for (int i=3D0;i&lt;pMesh-&gt;getNumSubMeshes();++i) {
+		Ogre::SubMesh *pSub =3D pMesh-&gt;getSubMesh(i);
+		if (pSub &amp;&amp; pSub-&gt;indexData) res +=3D pSub-&gt;indexData-&gt;indexCount / 3;
+	}
+	lua_pushnumber(L,res);
+	return 1;
+}
+
+static int l_getUOPath(lua_State *L) { PROFILE
+	std::string res =3D getUOPath();
+	if (res.length() =3D=3D 0) return 0;
+	lua_pushstring(L,res.c_str());
+	return 1;
+}
+
+/// attempts to correct case-sensitivity for filepaths
+static int l_PathSearch (lua_State *L) { PROFILE
+	std::string res =3D rob_pathsearch(luaL_checkstring(L,1));
+	if (res.length() =3D=3D 0) return 0;
+	lua_pushstring(L,res.c_str());
+	return 1;
+}
+
+static int l_file_exists (lua_State *L) { PROFILE
+	std::ifstream	myFileStream(luaL_checkstring(L,1));
+	lua_pushboolean(L,myFileStream?true:false);
+	return 1;
+}
+
+static int l_file_size (lua_State *L) { PROFILE
+	std::ifstream	myFileStream(luaL_checkstring(L,1));
+	int iFileSize =3D 0;
+	if (myFileStream) {
+		myFileStream.seekg(0, std::ios::end);
+		iFileSize =3D myFileStream.tellg();
+	}
+	lua_pushnumber(L,iFileSize);
+	return 1;
+}
+
+
+// for testing bitwise ops
+static int l_GetRandomHexString 	(lua_State *L) { PROFILE lua_pushstring( =
L, strprintf(&quot;0x%08x&quot;,rand()).c_str()); return 1; }
+
+/// converts &quot;0x1234&quot; to a number
+static int l_Hex2Num 	(lua_State *L) { PROFILE
+	std::string hexcode =3D luaL_checkstring(L,1);
+	uint32 res =3D 0;
+	sscanf(hexcode.c_str(),&quot;0x%x&quot;,&amp;res);
+	lua_pushnumber(L, res);
+	return 1;
+}
+
+// bitwise operations, used for networking, packet manipulation etc
+static int l_BitwiseAND 	(lua_State *L) { PROFILE
+	// keep this spread out like this to avoid strange, 32 bi
+	double g =3D luaL_checknumber(L,1);
+	double h =3D luaL_checknumber(L,2);
+	uint32 a =3D uint32(g);
+	uint32 b =3D uint32(h);
+	uint32 c =3D a &amp; b;
+	lua_pushnumber( L, c);
+	return 1;
+}
+static int l_BitwiseOR 		(lua_State *L) { PROFILE
+	// keep this spread out like this to avoid strange, 32 bi
+	double g =3D luaL_checknumber(L,1);
+	double h =3D luaL_checknumber(L,2);
+	uint32 a =3D uint32(g);
+	uint32 b =3D uint32(h);
+	uint32 c =3D a | b;
+	lua_pushnumber( L, c);
+	return 1;
+}
+
+
+static int l_BitwiseXOR 	(lua_State *L) { PROFILE
+	// keep this spread out like this to avoid strange, 32 bi
+	double g =3D luaL_checknumber(L,1);
+	double h =3D luaL_checknumber(L,2);
+	uint32 a =3D uint32(g);
+	uint32 b =3D uint32(h);
+	uint32 c =3D a ^ b;
+	lua_pushnumber( L, c);
+	return 1;
+}
+
+// bitwise operations, used for networking, packet manipulation etc
+static int l_BitwiseSHL 	(lua_State *L) { PROFILE
+	// keep this spread out like this to avoid strange, 32 bi
+	double g =3D luaL_checknumber(L,1);
+	double h =3D luaL_checknumber(L,2);
+	uint32 a =3D uint32(g);
+	uint32 b =3D uint32(h);
+	uint32 c =3D a &lt;&lt; b;
+	lua_pushnumber( L, c);
+	return 1;
+}
+// bitwise operations, used for networking, packet manipulation etc
+static int l_BitwiseSHR 	(lua_State *L) { PROFILE
+	// keep this spread out like this to avoid strange, 32 bi
+	double g =3D luaL_checknumber(L,1);
+	double h =3D luaL_checknumber(L,2);
+	uint32 a =3D uint32(g);
+	uint32 b =3D uint32(h);
+	uint32 c =3D a &gt;&gt; b;
+	lua_pushnumber( L, c);
+	return 1;
+}
+
+
+static int l_TestBit 		(lua_State *L) { PROFILE lua_pushboolean(L,(uint32(=
luaL_checknumber(L,1)) &amp; (uint32(1) &lt;&lt; luaL_checkint(L,2))) !=3D 0); return=
 1; }
+static int l_SetBit 		(lua_State *L) { PROFILE lua_pushnumber( L,(uint32(l=
uaL_checknumber(L,1)) | (uint32(1) &lt;&lt; luaL_checkint(L,2)))); return 1; }
+static int l_ClearBit 		(lua_State *L) { PROFILE
+	uint32 input =3D uint32(luaL_checknumber(L,1));
+	uint32 mask =3D 1L &lt;&lt; uint32(luaL_checknumber(L,2));
+	lua_pushnumber(L,(input &amp; mask)?(input ^ mask):(input));  // XOR =3D ^ =
=3D toggle bit... toggle only if set (&amp;) to clear
+	return 1;
+}
+
+
+static int l_Exit		 		(lua_State *L) { PROFILE
+	exit((lua_gettop(L) &gt;=3D 1 &amp;&amp; !lua_isnil(L,1)) ? luaL_checkint(L,1) : 0);
+	return 0;
+}
+
+void MyCrash		(const char* szMessage); // see main.cpp
+
+static int l_Crash		 		(lua_State *L) { PROFILE
+	MyCrash(&quot;CRASH triggered from script, see console for info (start with co=
mmandline option -c)&quot;); // does not return...
+	exit(88);
+	return 0;
+}
+
+/// triggers a segfault, for testing our segfault handlers lua stacktrace
+static int l_CrashSegFault		 		(lua_State *L) { PROFILE
+	DisplayErrorMessage(&quot;testing segfault handler...&quot;);
+	*((char*)0) =3D 0; // trigger segfault
+	return 0;
+}
+
+
+static int l_DisplayNotice	(lua_State *L) { PROFILE
+	DisplayNotice(luaL_checkstring(L,1));
+	return 0;
+}
+
+
+static int l_FatalErrorMessage	(lua_State *L) { PROFILE
+	DisplayErrorMessage(luaL_checkstring(L,1));
+	exit(77);
+	return 0;
+}
+
+
+/// for lua :   void  ExportMesh  (meshname,filename)
+static int l_ExportMesh		(lua_State *L) { PROFILE
+	Ogre::MeshPtr pMesh =3D Ogre::MeshManager::getSingleton().load(luaL_check=
string(L,1),
+					// autodetect group location
+					//Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
+					Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
+	Ogre::MeshSerializer myExporter;
+	//Ogre::Mesh* pMesh =3D pEntity-&gt;getMesh().get();
+	myExporter.exportMesh(pMesh.get(),luaL_checkstring(L,2));
+	return 0;
+}
+
+/// for lua :   x,y,z,vx,vy,vz  GetMouseRay  ()
+static int l_GetMouseRay		(lua_State *L) { PROFILE
+	cOgreWrapper&amp; ogrewrapper =3D cOgreWrapper::GetSingleton();
+	Ogre::Ray myray(	ogrewrapper.mCamera-&gt;getCameraToViewportRay(
+				Ogre::Real(cInput::iMouse[0]) / Ogre::Real(ogrewrapper.mViewport-&gt;getA=
ctualWidth()),
+				Ogre::Real(cInput::iMouse[1]) / Ogre::Real(ogrewrapper.mViewport-&gt;getA=
ctualHeight()) ));
+	lua_pushnumber(L,myray.getOrigin().x);
+	lua_pushnumber(L,myray.getOrigin().y);
+	lua_pushnumber(L,myray.getOrigin().z);
+	lua_pushnumber(L,myray.getDirection().x);
+	lua_pushnumber(L,myray.getDirection().y);
+	lua_pushnumber(L,myray.getDirection().z);
+	return 6;
+}
+
+/// for lua :   z  GetMaxZ  ()
+static int 		l_GetMaxZ		(lua_State *L) { PROFILE
+	lua_pushnumber(L,Ogre::Root::getSingleton().getRenderSystem()-&gt;getMaximum=
DepthInputValue());
+	return 1;
+}
+
+
+/// for lua :   bIsInFront,px,py  ProjectPos  (x,y,z)
+static int l_ProjectPos		(lua_State *L) { PROFILE
+	bool 		bIsInFront;
+	Ogre::Real	fX,fY;
+	bIsInFront =3D cOgreWrapper::GetSingleton().ProjectPos(
+		Ogre::Vector3(luaL_checknumber(L,0),luaL_checknumber(L,1),luaL_checknumb=
er(L,2)),fX,fY);
+	lua_pushboolean(L,bIsInFront);
+	lua_pushnumber(L,fX);
+	lua_pushnumber(L,fY);
+	return 3;
+}
+
+/// for lua :   bIsInFront,px,py,cx,cy  ProjectSizeAndPos  (x,y,z,r)
+static int l_ProjectSizeAndPos		(lua_State *L) { PROFILE
+	bool 		bIsInFront;
+	Ogre::Real	fX,fY,fCX,fCY;
+	bIsInFront =3D cOgreWrapper::GetSingleton().ProjectSizeAndPos(
+		Ogre::Vector3(luaL_checknumber(L,0),luaL_checknumber(L,1),luaL_checknumb=
er(L,2)),fX,fY,luaL_checknumber(L,3),fCX,fCY);
+	lua_pushboolean(L,bIsInFront);
+	lua_pushnumber(L,fX);
+	lua_pushnumber(L,fY);
+	lua_pushnumber(L,fCX);
+	lua_pushnumber(L,fCY);
+	return 5;
+}
+
+
+
+/// for lua :   void  CreateSceneManager  (sSceneManagerName)
+static int l_CreateSceneManager		(lua_State *L) { PROFILE  // TODO : move =
to seperate file ?
+	cOgreWrapper::GetSingleton().mRoot-&gt;createSceneManager(Ogre::ST_GENERIC,l=
uaL_checkstring(L,1));
+	return 0;
+}
+
+/// for lua :   table[id=3Dtexname...]  OgreMeshTextures  (meshfile)
+static int l_OgreMeshTextures	(lua_State *L) { PROFILE  // TODO : move to =
seperate file ?
+	Ogre::MeshSerializer* meshSerializer =3D new Ogre::MeshSerializer();
+	const char *szMeshName =3D luaL_checkstring(L,1);
+
+	lua_newtable(L);
+
+	//printf(&quot;open file: %s\n&quot;,szMeshName);
+	// model file
+	std::ifstream ifs;
+	ifs.open(szMeshName, std::ios_base::in | std::ios_base::binary);
+	Ogre::DataStreamPtr stream(new Ogre::FileStreamDataStream(&amp;ifs, false));
+
+	if(ifs.is_open()){
+		//printf(&quot;create tmp mesh\n&quot;);
+		// create tmp mesh import resource
+		Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().create(&quot;l_OgreM=
eshTextureMissing_conversion&quot;,
+			Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+
+		//printf(&quot;import\n&quot;);
+		// import
+		meshSerializer-&gt;importMesh(stream, mesh.getPointer());
+
+		if(!mesh.isNull()){
+			// iterator over submeshes
+			Ogre::Mesh::SubMeshIterator it =3D mesh-&gt;getSubMeshIterator();
+			int i =3D 1;
+			while(it.hasMoreElements()){
+				Ogre::SubMesh *submesh =3D it.getNext();
+				std::string tex =3D submesh-&gt;getMaterialName();
+				//printf(&quot;material found: %s\n&quot;,tex.c_str());
+				lua_pushstring(L,tex.c_str()); lua_rawseti(L,-2,i);
+				++i;
+			}
+		}
+
+		// remove all stuff
+		Ogre::MeshManager::getSingleton().remove(&quot;l_OgreMeshTextureMissing_conve=
rsion&quot;);
+
+		ifs.close();
+	} else {
+		printf(&quot;ERROR can't open file: %s\n&quot;,szMeshName);
+	}
+
+	delete meshSerializer;
+
+	return 1;
+}
+
+
+/// for lua :   void OgreShadowTechnique  (string techique)
+static int l_OgreShadowTechnique	(lua_State *L) { PROFILE  // TODO : move =
to seperate file ?
+	const char *tech =3D luaL_checkstring(L,1);
+	Ogre::SceneManager *p =3D cOgreWrapper::GetSingleton().mSceneMgr;
+
+	if(p){
+		if(strcmp(tech,&quot;stencil_modulative&quot;) =3D=3D 0)p-&gt;setShadowTechnique(Ogre=
::<i>SHADOWTYPE_STENCIL_MODULATIVE);
</I>+		else if(strcmp(tech,&quot;stencil_additive&quot;) =3D=3D 0)p-&gt;setShadowTechnique(O=
gre::SHADOWTYPE_STENCIL_ADDITIVE);
+		else if(strcmp(tech,&quot;texture_modulative&quot;) =3D=3D 0)p-&gt;setShadowTechnique=
(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE);
+		else if(strcmp(tech,&quot;texture_additive&quot;) =3D=3D 0)p-&gt;setShadowTechnique(O=
gre::SHADOWTYPE_TEXTURE_ADDITIVE);
+		else if(strcmp(tech,&quot;texture_additive_integrated&quot;) =3D=3D 0)p-&gt;setShadow=
Technique(Ogre::SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED);
+		else if(strcmp(tech,&quot;texture_modulative_integrated&quot;) =3D=3D 0)p-&gt;setShad=
owTechnique(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED);
+		else p-&gt;setShadowTechnique(Ogre::SHADOWTYPE_NONE);
+	}
+    return 0;
+}
+
+/// for lua :   void	  OgreSetShadowTextureSize  (int size)
+static int 				l_OgreSetShadowTextureSize	(lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureSize(luaL_checkin=
t(L,1));
+	return 0;
+}
+
+
+
+/// for lua :   void	  OgreSetShadowFarDistance	(float x)
+static int 				l_OgreSetShadowFarDistance	(lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowFarDistance(luaL_checknu=
mber(L,1));
+	return 0;
 }
 =

 /// for lua :   void	  OgreSetShadowDirLightTextureOffset	(float x)
@@ -1154,13 +1159,13 @@
 static int 				l_OgreSetShadowTextureFadeEnd	(lua_State *L) { PROFILE
 	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureFadeEnd(luaL_chec=
knumber(L,1));
 	return 0;
-}
-
-/// for lua :   void	  OgreSetShadowTexturePixelFormat	()
+}
+
+/// for lua :   void	  OgreSetShadowTexturePixelFormat	()
 static int 				l_OgreSetShadowTexturePixelFormat	(lua_State *L) { PROFILE
-	Ogre::PixelFormat pf =3D (lua_gettop(L) &gt;=3D 2 &amp;&amp; !lua_isnil(L,1)) ? ((Og=
re::PixelFormat)luaL_checkint(L,1)) : Ogre::PF_FLOAT16_R;
-	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTexturePixelFormat(pf);
-	return 0;
+	Ogre::PixelFormat pf =3D (lua_gettop(L) &gt;=3D 2 &amp;&amp; !lua_isnil(L,1)) ? ((Og=
re::PixelFormat)luaL_checkint(L,1)) : Ogre::PF_FLOAT16_R;
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTexturePixelFormat(pf);
+	return 0;
 }
 =

 =

@@ -1216,502 +1221,502 @@
 	OgrePixelFormatList_REGISTER(PF_COUNT)			//
 	return 1;
 }
-
-
-/// for lua :   void	  OgreSetShadowTextureSelfShadow  (bool)
-static int 				l_OgreSetShadowTextureSelfShadow	(lua_State *L) { PROFILE
-	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureSelfShadow(lua_to=
boolean(L,1));
-	return 0;
-}
-
-/// for lua :   void 	  OgreSetShadowTextureCasterMaterial  (sMatName)
-static int 				l_OgreSetShadowTextureCasterMaterial			(lua_State *L) { PRO=
FILE
-	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureCasterMaterial(lu=
aL_checkstring(L,1));
-	return 0;
-}
-
-/// for lua :   void	  OgreSetShadowTextureReceiverMaterial  (sMatName)
-static int 				l_OgreSetShadowTextureReceiverMaterial	(lua_State *L) { PRO=
FILE  // TODO : move to seperate file ?
-	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureReceiverMaterial(=
luaL_checkstring(L,1));
-	return 0;
-}
-
-/// for lua :   void OgreAmbientLight  (r,g,b) [color value 0..1 each]
-static int l_OgreAmbientLight	(lua_State *L) { PROFILE  // TODO : move to =
seperate file ?
-	float r =3D luaL_checknumber(L,1);
-	float g =3D luaL_checknumber(L,2);
-	float b =3D luaL_checknumber(L,3);
-	Ogre::SceneManager *p =3D cOgreWrapper::GetSingleton().mSceneMgr;
-
-	if(p){
-		p-&gt;setAmbientLight( ColourValue( r, g, b ) );
-	}
-
-	return 0;
-}
-
-/// for lua :   string  GetUniqueName  ()
-static int l_GetUniqueName	(lua_State *L) { PROFILE  // TODO : move to sep=
erate file ?
-	std::string n =3D cOgreWrapper::GetSingleton().GetUniqueName();
-	lua_pushstring(L,n.c_str());
-	return 1;
-}
-
-
-/// for lua :   number OgreLastFPS  ()
-static int l_OgreLastFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWr=
apper::GetSingleton().mfLastFPS);return 1; }
-/// for lua :   number OgreAvgFPS  ()
-static int l_OgreAvgFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWra=
pper::GetSingleton().mfAvgFPS);return 1; }
-/// for lua :   number OgreBestFPS  ()
-static int l_OgreBestFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWr=
apper::GetSingleton().mfBestFPS);return 1; }
-/// for lua :   number OgreWorstFPS  ()
-static int l_OgreWorstFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreW=
rapper::GetSingleton().mfWorstFPS);return 1; }
-/// for lua :   number OgreBestFrameTime  ()
-static int l_OgreBestFrameTime	(lua_State *L) { PROFILE lua_pushnumber(L,c=
OgreWrapper::GetSingleton().miBestFrameTime);return 1; }
-/// for lua :   number OgreWorstFrameTime  ()
-static int l_OgreWorstFrameTime	(lua_State *L) { PROFILE lua_pushnumber(L,=
cOgreWrapper::GetSingleton().miWorstFrameTime);return 1; }
-/// for lua :   number OgreTriangleCount  ()
-static int l_OgreTriangleCount	(lua_State *L) { PROFILE lua_pushnumber(L,c=
OgreWrapper::GetSingleton().miTriangleCount);return 1; }
-/// for lua :   number OgreBatchCount  ()
-static int l_OgreBatchCount	(lua_State *L) { PROFILE lua_pushnumber(L,cOgr=
eWrapper::GetSingleton().miBatchCount);return 1; }
-
-/*
-static int l_Client_SetMouseSensitivity (lua_State *L) { PROFILE
-	cClient* client =3D cGame::GetSingleton().mpClient;
-	if (client) client-&gt;mfMouseSensitivity =3D luaL_checknumber(L,1);
-	return 0;
-}
-
-
-
-static int l_Client_SetInvertMouse (lua_State *L) { PROFILE
-	cClient* client =3D cGame::GetSingleton().mpClient;
-	if (client) client-&gt;mbInvertMouse =3D luaL_checkint(L,1) !=3D 0;
-	return 0;
-}
-
-
-static int l_Client_SetCamera (lua_State *L) { PROFILE
-	int i=3D0;
-	Real x =3D luaL_checknumber(L,++i);
-	Real y =3D luaL_checknumber(L,++i);
-	Real z =3D luaL_checknumber(L,++i);
-	Real qw =3D luaL_checknumber(L,++i);
-	Real qx =3D luaL_checknumber(L,++i);
-	Real qy =3D luaL_checknumber(L,++i);
-	Real qz =3D luaL_checknumber(L,++i);
-	cClient* client =3D cGame::GetSingleton().mpClient;
-	if (client)
-			client-&gt;SetCamera(Vector3(x,y,z),Quaternion(qw,qx,qy,qz));
-	else	printf(&quot;l_Client_SetCamera called from lua on non-client&quot;);
-	return 0;
-}
-
-static int l_Client_ForceCamRot (lua_State *L) { PROFILE
-	int i=3D0;
-	Real qw =3D luaL_checknumber(L,++i);
-	Real qx =3D luaL_checknumber(L,++i);
-	Real qy =3D luaL_checknumber(L,++i);
-	Real qz =3D luaL_checknumber(L,++i);
-	cClient* client =3D cGame::GetSingleton().mpClient;
-	if (client)
-			client-&gt;ForceCamRot(Quaternion(qw,qx,qy,qz));
-	else	printf(&quot;l_Client_ForceCamRot called from lua on non-client&quot;);
-	return 0;
-}
-
-static int l_Client_CameraLookAt (lua_State *L) { PROFILE
-	int i=3D0;
-	Real x =3D luaL_checknumber(L,++i);
-	Real y =3D luaL_checknumber(L,++i);
-	Real z =3D luaL_checknumber(L,++i);
-	cClient* client =3D cGame::GetSingleton().mpClient;
-	if (client)
-			client-&gt;CameraLookAt(Vector3(x,y,z));
-	else	printf(&quot;l_Client_CameraLookAt called from lua on non-client&quot;);
-	return 0;
-}
-*/
-
-
-// ***** ***** utilities and error handling ***** *****
-
-
-/// also adds a traceback to the error message in case of an error
-/// nret=3D-1 for unlimited
-/// don't use directly, used by LuaCall
-int 	PCallWithErrFuncWrapper (lua_State *L,int narg, int nret) { PROFILE
-	int status;
-	int base =3D lua_gettop(L) - narg;  // function index
-	lua_pushliteral(L, &quot;_TRACEBACK&quot;);
-	lua_rawget(L, LUA_GLOBALSINDEX); // get traceback function
-	lua_insert(L, base);  // put it under chunk and args
-	// signal(SIGINT, laction); // copyed from example, no idea what this is =
good for =3D(
-	status =3D lua_pcall(L, narg, (nret=3D=3D-1) ? LUA_MULTRET : nret, base);
-
-	//printf(&quot;pcall end, cleaning up....\n&quot;);
-
-	// signal(SIGINT, SIG_DFL); // copyed from example, no idea what this is =
good for =3D(
-	lua_remove(L, base);  // remove traceback function // TODO : this might c=
rash if error handler closed the lua state
-
-	//printf(&quot;pcall end\n&quot;);
-
-	return status;
-}
-
-
-void MyCrash				(const char* szMessage);
-
-void LuaErrorHandler (lua_State *L, const char *fmt, ...) { PROFILE
-	printf(&quot;LuaErrorHandler start\n&quot;);
-
-	va_list argp;
-	va_start(argp, fmt);
-	gRobStringBuffer[0] =3D 0;
-	vsnprintf(gRobStringBuffer,kRobStringBufferSize-1,fmt, argp);
-	std::string s(gRobStringBuffer);
-	va_end(argp);
-
-	std::string mystr(&quot;LuaError\n&quot;);
-	mystr +=3D s;
-
-	printf(&quot;\nLuaErrorHandler end\n&quot;);
-
-	//lua_close(L);
-	MyCrash(mystr.c_str());
-	// todo : attempt recovery in case of protected function call ?
-	// todo : deinit ogre to free mouse here
-}
-
-
-struct luaL_reg make_luaL_reg(const char *name,lua_CFunction func){
-  struct luaL_reg s;
-  s.name =3D name;
-  s.func =3D func;
-  return s;
-}
-
-void	cScripting::Listener_Notify (cListenable* pTarget,const size_t eventc=
ode,const size_t param,const size_t userdata) { PROFILE
-	switch (userdata) {
-		case kListenerBinding_Keys:
-			switch (eventcode) {
-				case cInput::kListenerEvent_KeyPress:
-					LuaCall(&quot;KeyDown&quot;,&quot;ii&quot;,(int)(param &amp; 255),(int)((param &gt;&gt; 8) &amp; 255));
-					//printf(&quot;keydown(%d)\n&quot;,param);
-				break;
-				case cInput::kListenerEvent_KeyRelease:
-					LuaCall(&quot;KeyUp&quot;,&quot;i&quot;,(int)param);
-					//printf(&quot;keyup(%d)\n&quot;,param);
-				break;
-			}
-			//printf(&quot;event=3D%d,key=3D%d\n&quot;,eventcode,param);
-		break;
-		// TODO : maybe timer ?
-	}
-}
-
-int		cScripting::GetGlobal	(const char* name) { PROFILE
-	lua_getglobal(L,name);
-	if (!lua_isnumber(L,-1)) { lua_pop(L,1); return 0; }
-	return (int)lua_tonumber(L,-1);
-}
-
-void	cScripting::SetGlobal	(const char* name,int value) { PROFILE
-	lua_pushnumber(L,value);
-	lua_setglobal(L,name);
-}
-
-/// this is the call_va function from the Book &quot;Programming in Lua&quot; with a=
ltered type notation :
-/// float : f
-/// int : i
-/// const char* : s
-/// returns true on successful call
-/// warning ! maybe this cannot return more than one string ! todo : check=
 doc of lua_tostring
-bool cScripting::LuaCall (const char *func, const char *sig, ...) { PROFILE
-	#ifdef PROFILE_LUACALLCOUNT
-	++gPROFILE_LUACALLCOUNT[func];
-	#endif
-
-	bool result =3D true;
-	va_list vl;
-	int narg, nres;  /* number of arguments and results */
-
-	va_start(vl, sig);
-	lua_getglobal(L, func);  /* get function */
-
-	/* push arguments */
-	narg =3D 0;
-	while (*sig) {  /* push arguments */
-		bool endwhile =3D false;
-		switch (*sig++) {
-		  case 'f':  /* float/double argument */
-			lua_pushnumber(L, va_arg(vl, double));
-			break;
-
-		  case 'i':  /* int argument (ansi printf : also use %d) */
-			lua_pushnumber(L, va_arg(vl, int));
-			break;
-
-		  case 's':  /* string argument */
-			lua_pushstring(L, va_arg(vl, char *));
-			break;
-
-		  case '&gt;':
-			endwhile =3D true;
-			break;
-		  default:
-			LuaErrorHandler(L, &quot;invalid option (%c)&quot;, *(sig - 1));
-			lua_pushnil(L);
-			break;
-		}
-		if (endwhile) break;
-		narg++;
-		luaL_checkstack(L, 1, &quot;too many arguments&quot;);
-	}
-
-	/* do the call */
-	nres =3D strlen(sig);  /* number of expected results */
-	// todo : push lua error handler function here ?!?
-	if (PCallWithErrFuncWrapper(L,narg, nres) !=3D 0) {
-	//if (lua_pcall(L, narg, nres, 0) !=3D 0)  { // old
-		/* do the call */
-		LuaErrorHandler(L, &quot;error running function `%s': %s&quot;,func, lua_tostring(=
L, -1));
-
-		/*
-		doku for lua_pcall last argument (errorfunc)
-		if 0 ... else that argument should be the index in the stack where the e=
rror handler function is located. Notice that, in such cases, the handler m=
ust be pushed in the stack before the function to be called and its argumen=
ts.
-		*/
-		result =3D false;
-	} else {
-		/* retrieve results */
-		int popamount =3D nres;
-		nres =3D -nres;  /* stack index of first result */
-		while (*sig) {  /* get results */
-			switch (*sig++) {
-
-			  case 'f':  /* float / double result */
-				if (!lua_isnumber(L, nres)) {
-					LuaErrorHandler(L, &quot;wrong result type&quot;);
-					*va_arg(vl, double *) =3D 0;
-				} else {
-					*va_arg(vl, double *) =3D lua_tonumber(L, nres);
-				}
-				break;
-
-			  case 'i':  /* int result */
-				if (!lua_isnumber(L, nres)) {
-					LuaErrorHandler(L, &quot;wrong result type&quot;);
-					*va_arg(vl, int *) =3D 0;
-				} else {
-					*va_arg(vl, int *) =3D (int)lua_tonumber(L, nres);
-				}
-				break;
-
-			  case 's':  /* string result */
-				if (!lua_isstring(L, nres)) {
-					LuaErrorHandler(L, &quot;wrong result type&quot;);
-					*va_arg(vl,std::string*) =3D &quot;&quot;;
-				} else {
-					*va_arg(vl,std::string*) =3D lua_tostring(L, nres); // return as std:=
:<i>string, as pure lua pointer becomes invalid with pop
</I>-				}
-				break;
-
-			  default:
-				LuaErrorHandler(L, &quot;invalid option (%c)&quot;, *(sig - 1));
-				break;
-			}
-			nres++;
-		}
-		// pop stack
-		lua_pop(L, popamount);
-	}
-	va_end(vl);
-	return result;
-}
-
-
-cScripting::cScripting	() : L(0) {}
-
-void	cScripting::Init () { PROFILE
-	if (sizeof(lua_Number) &lt;=3D 4) {
-		printf(&quot;sizeof(lua_Number) =3D %d, but must be greater than 4 (32 bit) f=
or bitwise ops\n&quot;,sizeof(lua_Number));
-		DisplayErrorMessage(&quot;ERROR : lua-precision wrong&quot;);
-		exit(43);
-	}
-
-	L =3D lua_open();
-	assert(L);
-	luaopen_base(L);
-	luaopen_table(L);
-	luaopen_io(L);
-	luaopen_string(L);
-	luaopen_math(L);
-	luaopen_debug(L);
-
-	lua_register(L,&quot;GetNamedKey&quot;,		l_GetNamedKey);
-	lua_register(L,&quot;GetKeyName&quot;,		l_GetKeyName);
-	lua_register(L,&quot;PollInput&quot;,			l_PollInput);
-	lua_register(L,&quot;Terminate&quot;,			l_Terminate);
-	lua_register(L,&quot;InitOgre&quot;,			l_InitOgre);
-	lua_register(L,&quot;GetPointerSize&quot;,	l_GetPointerSize);
-	lua_register(L,&quot;Client_IsAlive&quot;,	l_Client_IsAlive);
-	//lua_register(L,&quot;ServerSendMsgToClient&quot;,			l_ServerSendMsgToClient);
-	//lua_register(L,&quot;ClientSendMsgToServer&quot;,			l_ClientSendMsgToServer);
-	//lua_register(L,&quot;SoundPlayAmbient&quot;,				l_SoundPlayAmbient);
-	//lua_register(L,&quot;Server_SetMaxResyncsPerSecond&quot;,	l_Server_SetMaxResyncsP=
erSecond);
-	//lua_register(L,&quot;Server_GetMaxResyncsPerSecond&quot;,	l_Server_GetMaxResyncsP=
erSecond);
-	lua_register(L,&quot;Client_ShowOgreConfig&quot;,			l_Client_ShowOgreConfig);
-	lua_register(L,&quot;Client_TakeScreenshot&quot;,			l_Client_TakeScreenshot);
-	lua_register(L,&quot;Client_TakeGridScreenshot&quot;,			l_Client_TakeGridScreenshot=
);
-	//lua_register(L,&quot;Client_SetCamera&quot;,				l_Client_SetCamera);
-	//lua_register(L,&quot;Client_ForceCamRot&quot;,			l_Client_ForceCamRot);
-	//lua_register(L,&quot;Client_CameraLookAt&quot;,			l_Client_CameraLookAt);
-	//lua_register(L,&quot;Client_SetPlayerShip&quot;,			l_Client_SetPlayerShip);
-	//lua_register(L,&quot;Client_SetMaxFPS&quot;,				l_Client_SetMaxFPS);
-	//lua_register(L,&quot;Client_GetMaxFPS&quot;,				l_Client_GetMaxFPS);
-	lua_register(L,&quot;Client_GetCurFPS&quot;,				l_Client_GetCurFPS);
-	lua_register(L,&quot;Client_GetFrameNum&quot;,			l_Client_GetFrameNum);
-	//lua_register(L,&quot;Client_SetMouseSensitivity&quot;,	l_Client_SetMouseSensitivi=
ty);
-	//lua_register(L,&quot;Client_SetInvertMouse&quot;,			l_Client_SetInvertMouse);
-	//lua_register(L,&quot;Client_ShowMessage&quot;,			l_Client_ShowMessage);
-	lua_register(L,&quot;Client_GetTicks&quot;,				l_Client_GetTicks);
-	lua_register(L,&quot;Client_SetSkybox&quot;,				l_Client_SetSkybox);
-	lua_register(L,&quot;Client_SetFog&quot;,					l_Client_SetFog);
-	lua_register(L,&quot;Client_RenderOneFrame&quot;,			l_Client_RenderOneFrame);
-	lua_register(L,&quot;Client_Sleep&quot;,					l_Client_Sleep);
-	lua_register(L,&quot;Client_USleep&quot;,					l_Client_USleep);
-	lua_register(L,&quot;Client_SetAmbientLight&quot;,		l_Client_SetAmbientLight);
-	lua_register(L,&quot;Client_ClearLights&quot;,			l_Client_ClearLights);
-	lua_register(L,&quot;Client_AddPointLight&quot;,			l_Client_AddPointLight);
+
+
+/// for lua :   void	  OgreSetShadowTextureSelfShadow  (bool)
+static int 				l_OgreSetShadowTextureSelfShadow	(lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureSelfShadow(lua_to=
boolean(L,1));
+	return 0;
+}
+
+/// for lua :   void 	  OgreSetShadowTextureCasterMaterial  (sMatName)
+static int 				l_OgreSetShadowTextureCasterMaterial			(lua_State *L) { PRO=
FILE
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureCasterMaterial(lu=
aL_checkstring(L,1));
+	return 0;
+}
+
+/// for lua :   void	  OgreSetShadowTextureReceiverMaterial  (sMatName)
+static int 				l_OgreSetShadowTextureReceiverMaterial	(lua_State *L) { PRO=
FILE  // TODO : move to seperate file ?
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureReceiverMaterial(=
luaL_checkstring(L,1));
+	return 0;
+}
+
+/// for lua :   void OgreAmbientLight  (r,g,b) [color value 0..1 each]
+static int l_OgreAmbientLight	(lua_State *L) { PROFILE  // TODO : move to =
seperate file ?
+	float r =3D luaL_checknumber(L,1);
+	float g =3D luaL_checknumber(L,2);
+	float b =3D luaL_checknumber(L,3);
+	Ogre::SceneManager *p =3D cOgreWrapper::GetSingleton().mSceneMgr;
+
+	if(p){
+		p-&gt;setAmbientLight( ColourValue( r, g, b ) );
+	}
+
+	return 0;
+}
+
+/// for lua :   string  GetUniqueName  ()
+static int l_GetUniqueName	(lua_State *L) { PROFILE  // TODO : move to sep=
erate file ?
+	std::string n =3D cOgreWrapper::GetSingleton().GetUniqueName();
+	lua_pushstring(L,n.c_str());
+	return 1;
+}
+
+
+/// for lua :   number OgreLastFPS  ()
+static int l_OgreLastFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWr=
apper::GetSingleton().mfLastFPS);return 1; }
+/// for lua :   number OgreAvgFPS  ()
+static int l_OgreAvgFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWra=
pper::GetSingleton().mfAvgFPS);return 1; }
+/// for lua :   number OgreBestFPS  ()
+static int l_OgreBestFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWr=
apper::GetSingleton().mfBestFPS);return 1; }
+/// for lua :   number OgreWorstFPS  ()
+static int l_OgreWorstFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreW=
rapper::GetSingleton().mfWorstFPS);return 1; }
+/// for lua :   number OgreBestFrameTime  ()
+static int l_OgreBestFrameTime	(lua_State *L) { PROFILE lua_pushnumber(L,c=
OgreWrapper::GetSingleton().miBestFrameTime);return 1; }
+/// for lua :   number OgreWorstFrameTime  ()
+static int l_OgreWorstFrameTime	(lua_State *L) { PROFILE lua_pushnumber(L,=
cOgreWrapper::GetSingleton().miWorstFrameTime);return 1; }
+/// for lua :   number OgreTriangleCount  ()
+static int l_OgreTriangleCount	(lua_State *L) { PROFILE lua_pushnumber(L,c=
OgreWrapper::GetSingleton().miTriangleCount);return 1; }
+/// for lua :   number OgreBatchCount  ()
+static int l_OgreBatchCount	(lua_State *L) { PROFILE lua_pushnumber(L,cOgr=
eWrapper::GetSingleton().miBatchCount);return 1; }
+
+/*
+static int l_Client_SetMouseSensitivity (lua_State *L) { PROFILE
+	cClient* client =3D cGame::GetSingleton().mpClient;
+	if (client) client-&gt;mfMouseSensitivity =3D luaL_checknumber(L,1);
+	return 0;
+}
+
+
+
+static int l_Client_SetInvertMouse (lua_State *L) { PROFILE
+	cClient* client =3D cGame::GetSingleton().mpClient;
+	if (client) client-&gt;mbInvertMouse =3D luaL_checkint(L,1) !=3D 0;
+	return 0;
+}
+
+
+static int l_Client_SetCamera (lua_State *L) { PROFILE
+	int i=3D0;
+	Real x =3D luaL_checknumber(L,++i);
+	Real y =3D luaL_checknumber(L,++i);
+	Real z =3D luaL_checknumber(L,++i);
+	Real qw =3D luaL_checknumber(L,++i);
+	Real qx =3D luaL_checknumber(L,++i);
+	Real qy =3D luaL_checknumber(L,++i);
+	Real qz =3D luaL_checknumber(L,++i);
+	cClient* client =3D cGame::GetSingleton().mpClient;
+	if (client)
+			client-&gt;SetCamera(Vector3(x,y,z),Quaternion(qw,qx,qy,qz));
+	else	printf(&quot;l_Client_SetCamera called from lua on non-client&quot;);
+	return 0;
+}
+
+static int l_Client_ForceCamRot (lua_State *L) { PROFILE
+	int i=3D0;
+	Real qw =3D luaL_checknumber(L,++i);
+	Real qx =3D luaL_checknumber(L,++i);
+	Real qy =3D luaL_checknumber(L,++i);
+	Real qz =3D luaL_checknumber(L,++i);
+	cClient* client =3D cGame::GetSingleton().mpClient;
+	if (client)
+			client-&gt;ForceCamRot(Quaternion(qw,qx,qy,qz));
+	else	printf(&quot;l_Client_ForceCamRot called from lua on non-client&quot;);
+	return 0;
+}
+
+static int l_Client_CameraLookAt (lua_State *L) { PROFILE
+	int i=3D0;
+	Real x =3D luaL_checknumber(L,++i);
+	Real y =3D luaL_checknumber(L,++i);
+	Real z =3D luaL_checknumber(L,++i);
+	cClient* client =3D cGame::GetSingleton().mpClient;
+	if (client)
+			client-&gt;CameraLookAt(Vector3(x,y,z));
+	else	printf(&quot;l_Client_CameraLookAt called from lua on non-client&quot;);
+	return 0;
+}
+*/
+
+
+// ***** ***** utilities and error handling ***** *****
+
+
+/// also adds a traceback to the error message in case of an error
+/// nret=3D-1 for unlimited
+/// don't use directly, used by LuaCall
+int 	PCallWithErrFuncWrapper (lua_State *L,int narg, int nret) { PROFILE
+	int status;
+	int base =3D lua_gettop(L) - narg;  // function index
+	lua_pushliteral(L, &quot;_TRACEBACK&quot;);
+	lua_rawget(L, LUA_GLOBALSINDEX); // get traceback function
+	lua_insert(L, base);  // put it under chunk and args
+	// signal(SIGINT, laction); // copyed from example, no idea what this is =
good for =3D(
+	status =3D lua_pcall(L, narg, (nret=3D=3D-1) ? LUA_MULTRET : nret, base);
+
+	//printf(&quot;pcall end, cleaning up....\n&quot;);
+
+	// signal(SIGINT, SIG_DFL); // copyed from example, no idea what this is =
good for =3D(
+	lua_remove(L, base);  // remove traceback function // TODO : this might c=
rash if error handler closed the lua state
+
+	//printf(&quot;pcall end\n&quot;);
+
+	return status;
+}
+
+
+void MyCrash				(const char* szMessage);
+
+void LuaErrorHandler (lua_State *L, const char *fmt, ...) { PROFILE
+	printf(&quot;LuaErrorHandler start\n&quot;);
+
+	va_list argp;
+	va_start(argp, fmt);
+	gRobStringBuffer[0] =3D 0;
+	vsnprintf(gRobStringBuffer,kRobStringBufferSize-1,fmt, argp);
+	std::string s(gRobStringBuffer);
+	va_end(argp);
+
+	std::string mystr(&quot;LuaError\n&quot;);
+	mystr +=3D s;
+
+	printf(&quot;\nLuaErrorHandler end\n&quot;);
+
+	//lua_close(L);
+	MyCrash(mystr.c_str());
+	// todo : attempt recovery in case of protected function call ?
+	// todo : deinit ogre to free mouse here
+}
+
+
+struct luaL_reg make_luaL_reg(const char *name,lua_CFunction func){
+  struct luaL_reg s;
+  s.name =3D name;
+  s.func =3D func;
+  return s;
+}
+
+void	cScripting::Listener_Notify (cListenable* pTarget,const size_t eventc=
ode,const size_t param,const size_t userdata) { PROFILE
+	switch (userdata) {
+		case kListenerBinding_Keys:
+			switch (eventcode) {
+				case cInput::kListenerEvent_KeyPress:
+					LuaCall(&quot;KeyDown&quot;,&quot;ii&quot;,(int)(param &amp; 255),(int)((param &gt;&gt; 8) &amp; 255));
+					//printf(&quot;keydown(%d)\n&quot;,param);
+				break;
+				case cInput::kListenerEvent_KeyRelease:
+					LuaCall(&quot;KeyUp&quot;,&quot;i&quot;,(int)param);
+					//printf(&quot;keyup(%d)\n&quot;,param);
+				break;
+			}
+			//printf(&quot;event=3D%d,key=3D%d\n&quot;,eventcode,param);
+		break;
+		// TODO : maybe timer ?
+	}
+}
+
+int		cScripting::GetGlobal	(const char* name) { PROFILE
+	lua_getglobal(L,name);
+	if (!lua_isnumber(L,-1)) { lua_pop(L,1); return 0; }
+	return (int)lua_tonumber(L,-1);
+}
+
+void	cScripting::SetGlobal	(const char* name,int value) { PROFILE
+	lua_pushnumber(L,value);
+	lua_setglobal(L,name);
+}
+
+/// this is the call_va function from the Book &quot;Programming in Lua&quot; with a=
ltered type notation :
+/// float : f
+/// int : i
+/// const char* : s
+/// returns true on successful call
+/// warning ! maybe this cannot return more than one string ! todo : check=
 doc of lua_tostring
+bool cScripting::LuaCall (const char *func, const char *sig, ...) { PROFILE
+	#ifdef PROFILE_LUACALLCOUNT
+	++gPROFILE_LUACALLCOUNT[func];
+	#endif
+
+	bool result =3D true;
+	va_list vl;
+	int narg, nres;  /* number of arguments and results */
+
+	va_start(vl, sig);
+	lua_getglobal(L, func);  /* get function */
+
+	/* push arguments */
+	narg =3D 0;
+	while (*sig) {  /* push arguments */
+		bool endwhile =3D false;
+		switch (*sig++) {
+		  case 'f':  /* float/double argument */
+			lua_pushnumber(L, va_arg(vl, double));
+			break;
+
+		  case 'i':  /* int argument (ansi printf : also use %d) */
+			lua_pushnumber(L, va_arg(vl, int));
+			break;
+
+		  case 's':  /* string argument */
+			lua_pushstring(L, va_arg(vl, char *));
+			break;
+
+		  case '&gt;':
+			endwhile =3D true;
+			break;
+		  default:
+			LuaErrorHandler(L, &quot;invalid option (%c)&quot;, *(sig - 1));
+			lua_pushnil(L);
+			break;
+		}
+		if (endwhile) break;
+		narg++;
+		luaL_checkstack(L, 1, &quot;too many arguments&quot;);
+	}
+
+	/* do the call */
+	nres =3D strlen(sig);  /* number of expected results */
+	// todo : push lua error handler function here ?!?
+	if (PCallWithErrFuncWrapper(L,narg, nres) !=3D 0) {
+	//if (lua_pcall(L, narg, nres, 0) !=3D 0)  { // old
+		/* do the call */
+		LuaErrorHandler(L, &quot;error running function `%s': %s&quot;,func, lua_tostring(=
L, -1));
+
+		/*
+		doku for lua_pcall last argument (errorfunc)
+		if 0 ... else that argument should be the index in the stack where the e=
rror handler function is located. Notice that, in such cases, the handler m=
ust be pushed in the stack before the function to be called and its argumen=
ts.
+		*/
+		result =3D false;
+	} else {
+		/* retrieve results */
+		int popamount =3D nres;
+		nres =3D -nres;  /* stack index of first result */
+		while (*sig) {  /* get results */
+			switch (*sig++) {
+
+			  case 'f':  /* float / double result */
+				if (!lua_isnumber(L, nres)) {
+					LuaErrorHandler(L, &quot;wrong result type&quot;);
+					*va_arg(vl, double *) =3D 0;
+				} else {
+					*va_arg(vl, double *) =3D lua_tonumber(L, nres);
+				}
+				break;
+
+			  case 'i':  /* int result */
+				if (!lua_isnumber(L, nres)) {
+					LuaErrorHandler(L, &quot;wrong result type&quot;);
+					*va_arg(vl, int *) =3D 0;
+				} else {
+					*va_arg(vl, int *) =3D (int)lua_tonumber(L, nres);
+				}
+				break;
+
+			  case 's':  /* string result */
+				if (!lua_isstring(L, nres)) {
+					LuaErrorHandler(L, &quot;wrong result type&quot;);
+					*va_arg(vl,std::string*) =3D &quot;&quot;;
+				} else {
+					*va_arg(vl,std::string*) =3D lua_tostring(L, nres); // return as std:=
:<i>string, as pure lua pointer becomes invalid with pop
</I>+				}
+				break;
+
+			  default:
+				LuaErrorHandler(L, &quot;invalid option (%c)&quot;, *(sig - 1));
+				break;
+			}
+			nres++;
+		}
+		// pop stack
+		lua_pop(L, popamount);
+	}
+	va_end(vl);
+	return result;
+}
+
+
+cScripting::cScripting	() : L(0) {}
+
+void	cScripting::Init () { PROFILE
+	if (sizeof(lua_Number) &lt;=3D 4) {
+		printf(&quot;sizeof(lua_Number) =3D %d, but must be greater than 4 (32 bit) f=
or bitwise ops\n&quot;,sizeof(lua_Number));
+		DisplayErrorMessage(&quot;ERROR : lua-precision wrong&quot;);
+		exit(43);
+	}
+
+	L =3D lua_open();
+	assert(L);
+	luaopen_base(L);
+	luaopen_table(L);
+	luaopen_io(L);
+	luaopen_string(L);
+	luaopen_math(L);
+	luaopen_debug(L);
+
+	lua_register(L,&quot;GetNamedKey&quot;,		l_GetNamedKey);
+	lua_register(L,&quot;GetKeyName&quot;,		l_GetKeyName);
+	lua_register(L,&quot;PollInput&quot;,			l_PollInput);
+	lua_register(L,&quot;Terminate&quot;,			l_Terminate);
+	lua_register(L,&quot;InitOgre&quot;,			l_InitOgre);
+	lua_register(L,&quot;GetPointerSize&quot;,	l_GetPointerSize);
+	lua_register(L,&quot;Client_IsAlive&quot;,	l_Client_IsAlive);
+	//lua_register(L,&quot;ServerSendMsgToClient&quot;,			l_ServerSendMsgToClient);
+	//lua_register(L,&quot;ClientSendMsgToServer&quot;,			l_ClientSendMsgToServer);
+	//lua_register(L,&quot;SoundPlayAmbient&quot;,				l_SoundPlayAmbient);
+	//lua_register(L,&quot;Server_SetMaxResyncsPerSecond&quot;,	l_Server_SetMaxResyncsP=
erSecond);
+	//lua_register(L,&quot;Server_GetMaxResyncsPerSecond&quot;,	l_Server_GetMaxResyncsP=
erSecond);
+	lua_register(L,&quot;Client_ShowOgreConfig&quot;,			l_Client_ShowOgreConfig);
+	lua_register(L,&quot;Client_TakeScreenshot&quot;,			l_Client_TakeScreenshot);
+	lua_register(L,&quot;Client_TakeGridScreenshot&quot;,			l_Client_TakeGridScreenshot=
);
+	//lua_register(L,&quot;Client_SetCamera&quot;,				l_Client_SetCamera);
+	//lua_register(L,&quot;Client_ForceCamRot&quot;,			l_Client_ForceCamRot);
+	//lua_register(L,&quot;Client_CameraLookAt&quot;,			l_Client_CameraLookAt);
+	//lua_register(L,&quot;Client_SetPlayerShip&quot;,			l_Client_SetPlayerShip);
+	//lua_register(L,&quot;Client_SetMaxFPS&quot;,				l_Client_SetMaxFPS);
+	//lua_register(L,&quot;Client_GetMaxFPS&quot;,				l_Client_GetMaxFPS);
+	lua_register(L,&quot;Client_GetCurFPS&quot;,				l_Client_GetCurFPS);
+	lua_register(L,&quot;Client_GetFrameNum&quot;,			l_Client_GetFrameNum);
+	//lua_register(L,&quot;Client_SetMouseSensitivity&quot;,	l_Client_SetMouseSensitivi=
ty);
+	//lua_register(L,&quot;Client_SetInvertMouse&quot;,			l_Client_SetInvertMouse);
+	//lua_register(L,&quot;Client_ShowMessage&quot;,			l_Client_ShowMessage);
+	lua_register(L,&quot;Client_GetTicks&quot;,				l_Client_GetTicks);
+	lua_register(L,&quot;Client_SetSkybox&quot;,				l_Client_SetSkybox);
+	lua_register(L,&quot;Client_SetFog&quot;,					l_Client_SetFog);
+	lua_register(L,&quot;Client_RenderOneFrame&quot;,			l_Client_RenderOneFrame);
+	lua_register(L,&quot;Client_Sleep&quot;,					l_Client_Sleep);
+	lua_register(L,&quot;Client_USleep&quot;,					l_Client_USleep);
+	lua_register(L,&quot;Client_SetAmbientLight&quot;,		l_Client_SetAmbientLight);
+	lua_register(L,&quot;Client_ClearLights&quot;,			l_Client_ClearLights);
+	lua_register(L,&quot;Client_AddPointLight&quot;,			l_Client_AddPointLight);
 	lua_register(L,&quot;Client_AddDirectionalLight&quot;,	l_Client_AddDirectionalLight=
);
-	lua_register(L,&quot;Client_DeleteLight&quot;,			l_Client_DeleteLight);
-	lua_register(L,&quot;Client_GetPhysStepTime&quot;,		l_Client_GetPhysStepTime);
-	lua_register(L,&quot;BuildTerrainEntity_Simple&quot;,		l_BuildTerrainEntity_Simple);
-	lua_register(L,&quot;BuildTerrainEntity_Shaded&quot;,		l_BuildTerrainEntity_Shaded);
-	lua_register(L,&quot;TerrainRayPick&quot;,				l_TerrainRayPick);
-	lua_register(L,&quot;SphereRayPick&quot;,					l_SphereRayPick);
-	lua_register(L,&quot;UnloadMeshName&quot;,				l_UnloadMeshName);
-	lua_register(L,&quot;CountMeshTriangles&quot;,			l_CountMeshTriangles);
-	lua_register(L,&quot;GetUOPath&quot;,						l_getUOPath);
-	lua_register(L,&quot;PathSearch&quot;,					l_PathSearch);
-	lua_register(L,&quot;file_exists&quot;,					l_file_exists);
-	lua_register(L,&quot;file_size&quot;,						l_file_size);
-	lua_register(L,&quot;Hex2Num&quot;,						l_Hex2Num);
-	lua_register(L,&quot;GetRandomHexString&quot;,			l_GetRandomHexString);
-	lua_register(L,&quot;BitwiseAND&quot;,					l_BitwiseAND);
-	lua_register(L,&quot;BitwiseOR&quot;,						l_BitwiseOR);
-	lua_register(L,&quot;BitwiseXOR&quot;,					l_BitwiseXOR);
-	lua_register(L,&quot;BitwiseSHL&quot;,					l_BitwiseSHL);
-	lua_register(L,&quot;BitwiseSHR&quot;,					l_BitwiseSHR);
-	lua_register(L,&quot;TestBit&quot;,						l_TestBit);
-	lua_register(L,&quot;SetBit&quot;,						l_SetBit);
-	lua_register(L,&quot;ClearBit&quot;,						l_ClearBit);
-	lua_register(L,&quot;Exit&quot;,							l_Exit);
-	lua_register(L,&quot;Crash&quot;,							l_Crash);
-	lua_register(L,&quot;CrashSegFault&quot;,					l_CrashSegFault);
-	lua_register(L,&quot;DisplayNotice&quot;,					l_DisplayNotice);
-	lua_register(L,&quot;FatalErrorMessage&quot;,				l_FatalErrorMessage);
-	lua_register(L,&quot;ExportMesh&quot;,					l_ExportMesh);
-	lua_register(L,&quot;CreateSceneManager&quot;,			l_CreateSceneManager);
-	lua_register(L,&quot;GetUniqueName&quot;,					l_GetUniqueName);
-	lua_register(L,&quot;GetMouseRay&quot;,					l_GetMouseRay);
-	lua_register(L,&quot;GetMaxZ&quot;,						l_GetMaxZ);
-	lua_register(L,&quot;ProjectPos&quot;,					l_ProjectPos);
-	lua_register(L,&quot;ProjectSizeAndPos&quot;,				l_ProjectSizeAndPos);
-	lua_register(L,&quot;_TRACEBACK&quot;,					l_TRACEBACK);
-	lua_register(L,&quot;ProfileDumpCallCount&quot;,			l_ProfileDumpCallCount);
-	lua_register(L,&quot;OgreMemoryUsage&quot;,				l_OgreMemoryUsage);
-	lua_register(L,&quot;OgreMeshAvailable&quot;,				l_OgreMeshAvailable);
-	lua_register(L,&quot;OgreMaterialNameKnown&quot;,			l_OgreMaterialNameKnown);
-	lua_register(L,&quot;OgreMaterialAvailable&quot;,			l_OgreMaterialAvailable);
-	lua_register(L,&quot;OgreTextureAvailable&quot;,			l_OgreTextureAvailable);
-	lua_register(L,&quot;OgreMeshTextures&quot;,				l_OgreMeshTextures);
-	// some statistic stuff
-	lua_register(L,&quot;OgreLastFPS&quot;,				l_OgreLastFPS);
-	lua_register(L,&quot;OgreAvgFPS&quot;,				l_OgreAvgFPS);
-	lua_register(L,&quot;OgreBestFPS&quot;,				l_OgreBestFPS);
-	lua_register(L,&quot;OgreWorstFPS&quot;,				l_OgreWorstFPS);
-	lua_register(L,&quot;OgreBestFrameTime&quot;,			l_OgreBestFrameTime);
-	lua_register(L,&quot;OgreWorstFrameTime&quot;,			l_OgreWorstFrameTime);
-	lua_register(L,&quot;OgreTriangleCount&quot;,			l_OgreTriangleCount);
-	lua_register(L,&quot;OgreBatchCount&quot;,			l_OgreBatchCount);
-
-	lua_register(L,&quot;CreateGrannyHuedTexture&quot;,		l_CreateGrannyHuedTexture);
-	lua_register(L,&quot;HueMesh&quot;,						l_HueMesh);
-	lua_register(L,&quot;OgreAddCompositor&quot;,						l_OgreAddCompositor);
-	lua_register(L,&quot;OgreRemoveCompositor&quot;,						l_OgreRemoveCompositor);
-	lua_register(L,&quot;CreateLookupTableFromFile&quot;,			l_CreateLookupTableFromFile=
);
-	lua_register(L,&quot;Uo16Color2Rgb&quot;,			l_Uo16Color2Rgb);
-	// shadow stuff
+	lua_register(L,&quot;Client_DeleteLight&quot;,			l_Client_DeleteLight);
+	lua_register(L,&quot;Client_GetPhysStepTime&quot;,		l_Client_GetPhysStepTime);
+	lua_register(L,&quot;BuildTerrainEntity_Simple&quot;,		l_BuildTerrainEntity_Simple);
+	lua_register(L,&quot;BuildTerrainEntity_Shaded&quot;,		l_BuildTerrainEntity_Shaded);
+	lua_register(L,&quot;TerrainRayPick&quot;,				l_TerrainRayPick);
+	lua_register(L,&quot;SphereRayPick&quot;,					l_SphereRayPick);
+	lua_register(L,&quot;UnloadMeshName&quot;,				l_UnloadMeshName);
+	lua_register(L,&quot;CountMeshTriangles&quot;,			l_CountMeshTriangles);
+	lua_register(L,&quot;GetUOPath&quot;,						l_getUOPath);
+	lua_register(L,&quot;PathSearch&quot;,					l_PathSearch);
+	lua_register(L,&quot;file_exists&quot;,					l_file_exists);
+	lua_register(L,&quot;file_size&quot;,						l_file_size);
+	lua_register(L,&quot;Hex2Num&quot;,						l_Hex2Num);
+	lua_register(L,&quot;GetRandomHexString&quot;,			l_GetRandomHexString);
+	lua_register(L,&quot;BitwiseAND&quot;,					l_BitwiseAND);
+	lua_register(L,&quot;BitwiseOR&quot;,						l_BitwiseOR);
+	lua_register(L,&quot;BitwiseXOR&quot;,					l_BitwiseXOR);
+	lua_register(L,&quot;BitwiseSHL&quot;,					l_BitwiseSHL);
+	lua_register(L,&quot;BitwiseSHR&quot;,					l_BitwiseSHR);
+	lua_register(L,&quot;TestBit&quot;,						l_TestBit);
+	lua_register(L,&quot;SetBit&quot;,						l_SetBit);
+	lua_register(L,&quot;ClearBit&quot;,						l_ClearBit);
+	lua_register(L,&quot;Exit&quot;,							l_Exit);
+	lua_register(L,&quot;Crash&quot;,							l_Crash);
+	lua_register(L,&quot;CrashSegFault&quot;,					l_CrashSegFault);
+	lua_register(L,&quot;DisplayNotice&quot;,					l_DisplayNotice);
+	lua_register(L,&quot;FatalErrorMessage&quot;,				l_FatalErrorMessage);
+	lua_register(L,&quot;ExportMesh&quot;,					l_ExportMesh);
+	lua_register(L,&quot;CreateSceneManager&quot;,			l_CreateSceneManager);
+	lua_register(L,&quot;GetUniqueName&quot;,					l_GetUniqueName);
+	lua_register(L,&quot;GetMouseRay&quot;,					l_GetMouseRay);
+	lua_register(L,&quot;GetMaxZ&quot;,						l_GetMaxZ);
+	lua_register(L,&quot;ProjectPos&quot;,					l_ProjectPos);
+	lua_register(L,&quot;ProjectSizeAndPos&quot;,				l_ProjectSizeAndPos);
+	lua_register(L,&quot;_TRACEBACK&quot;,					l_TRACEBACK);
+	lua_register(L,&quot;ProfileDumpCallCount&quot;,			l_ProfileDumpCallCount);
+	lua_register(L,&quot;OgreMemoryUsage&quot;,				l_OgreMemoryUsage);
+	lua_register(L,&quot;OgreMeshAvailable&quot;,				l_OgreMeshAvailable);
+	lua_register(L,&quot;OgreMaterialNameKnown&quot;,			l_OgreMaterialNameKnown);
+	lua_register(L,&quot;OgreMaterialAvailable&quot;,			l_OgreMaterialAvailable);
+	lua_register(L,&quot;OgreTextureAvailable&quot;,			l_OgreTextureAvailable);
+	lua_register(L,&quot;OgreMeshTextures&quot;,				l_OgreMeshTextures);
+	// some statistic stuff
+	lua_register(L,&quot;OgreLastFPS&quot;,				l_OgreLastFPS);
+	lua_register(L,&quot;OgreAvgFPS&quot;,				l_OgreAvgFPS);
+	lua_register(L,&quot;OgreBestFPS&quot;,				l_OgreBestFPS);
+	lua_register(L,&quot;OgreWorstFPS&quot;,				l_OgreWorstFPS);
+	lua_register(L,&quot;OgreBestFrameTime&quot;,			l_OgreBestFrameTime);
+	lua_register(L,&quot;OgreWorstFrameTime&quot;,			l_OgreWorstFrameTime);
+	lua_register(L,&quot;OgreTriangleCount&quot;,			l_OgreTriangleCount);
+	lua_register(L,&quot;OgreBatchCount&quot;,			l_OgreBatchCount);
+
+	lua_register(L,&quot;CreateGrannyHuedTexture&quot;,		l_CreateGrannyHuedTexture);
+	lua_register(L,&quot;HueMesh&quot;,						l_HueMesh);
+	lua_register(L,&quot;OgreAddCompositor&quot;,						l_OgreAddCompositor);
+	lua_register(L,&quot;OgreRemoveCompositor&quot;,						l_OgreRemoveCompositor);
+	lua_register(L,&quot;CreateLookupTableFromFile&quot;,			l_CreateLookupTableFromFile=
);
+	lua_register(L,&quot;Uo16Color2Rgb&quot;,			l_Uo16Color2Rgb);
+	// shadow stuff
 	lua_register(L,&quot;OgreSetShadowTextureFadeStart&quot;,						l_OgreSetShadowTextu=
reFadeStart);
 	lua_register(L,&quot;OgreSetShadowTextureFadeEnd&quot;,						l_OgreSetShadowTexture=
FadeEnd);
 	lua_register(L,&quot;OgreSetShadowDirLightTextureOffset&quot;,				l_OgreSetShadowDi=
rLightTextureOffset);
 	lua_register(L,&quot;OgreSetShadowFarDistance&quot;,							l_OgreSetShadowFarDistan=
ce);
-	lua_register(L,&quot;OgreSetShadowTextureSize&quot;,							l_OgreSetShadowTextureSi=
ze);
+	lua_register(L,&quot;OgreSetShadowTextureSize&quot;,							l_OgreSetShadowTextureSi=
ze);
 	lua_register(L,&quot;OgreSetShadowTexturePixelFormat&quot;,					l_OgreSetShadowText=
urePixelFormat);
-	lua_register(L,&quot;OgrePixelFormatList&quot;,								l_OgrePixelFormatList);
-	lua_register(L,&quot;OgreSetShadowTextureSelfShadow&quot;,					l_OgreSetShadowTextu=
reSelfShadow);
-	lua_register(L,&quot;OgreSetShadowTextureCasterMaterial&quot;,				l_OgreSetShadowTe=
xtureCasterMaterial);
-	lua_register(L,&quot;OgreSetShadowTextureReceiverMaterial&quot;,				l_OgreSetShadow=
TextureReceiverMaterial);
-	lua_register(L,&quot;OgreShadowTechnique&quot;,				l_OgreShadowTechnique);
-	lua_register(L,&quot;OgreAmbientLight&quot;,				l_OgreAmbientLight);
-
-	// file paths for init
-	const char* szLuaUDataPath =3D &quot;../data/lua/udata.lua&quot;;
-	const char* szLuaMainPath =3D &quot;../data/lua/main.lua&quot;;
-
-
-	// check if lua files exist (otherwise working directory probably wrong)
-	std::ifstream myFileStream(szLuaMainPath);
-	if (!myFileStream) {
-		MyCrash(strprintf(&quot;%s cannot be found, probably the working directory is=
 wrong&quot;,szLuaMainPath).c_str());
-		exit(34);
-	}
-	myFileStream.close();
-
-	// load utils
-	int res;
-	res	=3D lua_dofile(L,szLuaUDataPath); // loads function used for register=
ing udatatypes
-	if (res) {
-		MyCrash(&quot;error in udata script-initialisation\n&quot;);
-		exit(44);
-	}
-
-	RegisterLuaXML(L);
-	LuaRegisterFIFO(L);
-	LuaRegisterNet(L);
-	cGfx3D::LuaRegister(L);
-	cGfx2D::LuaRegister(L);
-	cDialog::LuaRegister(L);
-	cWidget::LuaRegister(L);
-	cBitMask::LuaRegister(L);
-	cCamera::LuaRegister(L);
-	cViewport::LuaRegister(L);
-	cRenderTexture::LuaRegister(L);
-	cSoundSource::LuaRegister(L);
-	cSpriteManager::LuaRegister(L);
-	cManualArtMaterialLoader::LuaRegister(L);
-	cSprite::LuaRegister(L);
-	Material_LuaRegister(L);
-	Granny_LuaRegister(L);
-	LuaRegisterData(L);
-	LuaRegisterBuilder(L);
-	LuaRegisterRadar(L);
-
-	cInput::GetSingleton().RegisterListener(this,kListenerBinding_Keys);
-
-	res =3D lua_dofile(L,szLuaMainPath);
-	if (res) {
-		MyCrash(&quot;error in main script-initialisation\n&quot;);
-		exit(-1);
-	}
-}
-
-cScripting::~cScripting	() { PROFILE
-	cInput::GetSingleton().UnRegisterListener(this,kListenerBinding_Keys);
-
-	assert(L);
-	lua_setgcthreshold(L, 0);  // collected garbage
-	lua_close(L);
-	L =3D 0;
-}
+	lua_register(L,&quot;OgrePixelFormatList&quot;,								l_OgrePixelFormatList);
+	lua_register(L,&quot;OgreSetShadowTextureSelfShadow&quot;,					l_OgreSetShadowTextu=
reSelfShadow);
+	lua_register(L,&quot;OgreSetShadowTextureCasterMaterial&quot;,				l_OgreSetShadowTe=
xtureCasterMaterial);
+	lua_register(L,&quot;OgreSetShadowTextureReceiverMaterial&quot;,				l_OgreSetShadow=
TextureReceiverMaterial);
+	lua_register(L,&quot;OgreShadowTechnique&quot;,				l_OgreShadowTechnique);
+	lua_register(L,&quot;OgreAmbientLight&quot;,				l_OgreAmbientLight);
+
+	// file paths for init
+	const char* szLuaUDataPath =3D &quot;../data/lua/udata.lua&quot;;
+	const char* szLuaMainPath =3D &quot;../data/lua/main.lua&quot;;
+
+
+	// check if lua files exist (otherwise working directory probably wrong)
+	std::ifstream myFileStream(szLuaMainPath);
+	if (!myFileStream) {
+		MyCrash(strprintf(&quot;%s cannot be found, probably the working directory is=
 wrong&quot;,szLuaMainPath).c_str());
+		exit(34);
+	}
+	myFileStream.close();
+
+	// load utils
+	int res;
+	res	=3D lua_dofile(L,szLuaUDataPath); // loads function used for register=
ing udatatypes
+	if (res) {
+		MyCrash(&quot;error in udata script-initialisation\n&quot;);
+		exit(44);
+	}
+
+	RegisterLuaXML(L);
+	LuaRegisterFIFO(L);
+	LuaRegisterNet(L);
+	cGfx3D::LuaRegister(L);
+	cGfx2D::LuaRegister(L);
+	cDialog::LuaRegister(L);
+	cWidget::LuaRegister(L);
+	cBitMask::LuaRegister(L);
+	cCamera::LuaRegister(L);
+	cViewport::LuaRegister(L);
+	cRenderTexture::LuaRegister(L);
+	cSoundSource::LuaRegister(L);
+	cSpriteManager::LuaRegister(L);
+	cManualArtMaterialLoader::LuaRegister(L);
+	cSprite::LuaRegister(L);
+	Material_LuaRegister(L);
+	Granny_LuaRegister(L);
+	LuaRegisterData(L);
+	LuaRegisterBuilder(L);
+	LuaRegisterRadar(L);
+
+	cInput::GetSingleton().RegisterListener(this,kListenerBinding_Keys);
+
+	res =3D lua_dofile(L,szLuaMainPath);
+	if (res) {
+		MyCrash(&quot;error in main script-initialisation\n&quot;);
+		exit(-1);
+	}
+}
+
+cScripting::~cScripting	() { PROFILE
+	cInput::GetSingleton().UnRegisterListener(this,kListenerBinding_Keys);
+
+	assert(L);
+	lua_setgcthreshold(L, 0);  // collected garbage
+	lua_close(L);
+	L =3D 0;
+}

Modified: trunk/src/spritemanager.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/src/spritemanager.cpp (original)
+++ trunk/src/spritemanager.cpp Thu Aug  2 02:27:17 2007
@@ -1,7 +1,7 @@
-#include &quot;prefix.h&quot;
-#include &quot;spritemanager.h&quot;
-#include &quot;ogrewrapper.h&quot;
-#include &quot;shell.h&quot;
+#include &quot;prefix.h&quot;
+#include &quot;spritemanager.h&quot;
+#include &quot;ogrewrapper.h&quot;
+#include &quot;shell.h&quot;
 #include &lt;Ogre.h&gt;
 #include &lt;math.h&gt;
 =

@@ -60,30 +60,30 @@
 		return;
 	}
 =

-	Ogre::TexturePtr tp =3D Ogre::TextureManager::getSingleton().getByHandle(=
 mTexHandle );
-
-	if (tp.isNull()) {
-		return;
-	}
-
-	Ogre::RenderSystem* RenderSys =3D Ogre::Root::getSingleton().getRenderSys=
tem();
-
-	if (mChanged) {
-		UpdateBuffer();
-		mChanged =3D false;
-	}
-
+	Ogre::TexturePtr tp =3D Ogre::TextureManager::getSingleton().getByHandle(=
 mTexHandle );
+
+	if (tp.isNull()) {
+		return;
+	}
+
+	Ogre::RenderSystem* RenderSys =3D Ogre::Root::getSingleton().getRenderSys=
tem();
+
+	if (mChanged) {
+		UpdateBuffer();
+		mChanged =3D false;
+	}
+
 	if (!mRenderOp) {
 		return;
-	}
-
-	if (mUseNormals) {
-		mSpriteQueue-&gt;SpriteManager()-&gt;SetLightningEnabled( true );
-	} else {
-		mSpriteQueue-&gt;SpriteManager()-&gt;SetLightningEnabled( false );
-	}
-
-	RenderSys-&gt;_setTexture( 0, true, tp-&gt;getName() );
+	}
+
+	if (mUseNormals) {
+		mSpriteQueue-&gt;SpriteManager()-&gt;SetLightningEnabled( true );
+	} else {
+		mSpriteQueue-&gt;SpriteManager()-&gt;SetLightningEnabled( false );
+	}
+
+	RenderSys-&gt;_setTexture( 0, true, tp-&gt;getName() );
 	RenderSys-&gt;_render( *mRenderOp );
 }
 =

@@ -148,35 +148,35 @@
 		}
 };
 void cSpriteQueue::Execute() { PROFILE
-	if (!mListSorted &amp;&amp; cShell::GetTicks() - mLastSort &gt; 10 ) {
-		mLastSort =3D cShell::GetTicks();
-		mSpriteList.sort( CompareSprites() );
-		mListSorted =3D true;
-		printf( &quot;Sprites sortet in %d msec.\n&quot;, cShell::GetTicks() - mLastSort );
-
-		int Pos =3D 1;
-		for ( std::list&lt;cBaseSprite*&gt;::iterator itor=3DmSpriteList.begin(); itor=
!=3DmSpriteList.end(); ++itor ) {
-			if ((*itor)-&gt;GetPosition() !=3D Pos ) {
-				(*itor)-&gt;SetPosition( Pos );
-				mListResorted =3D true;
-			}
-			Pos++;
-		}
-	}
-
-	double ViewPortWidthHalf  =3D (double)cOgreWrapper::GetSingleton().mViewp=
ort-&gt;getActualWidth() / 2.0;
-	double ViewPortHeightHalf =3D (double)cOgreWrapper::GetSingleton().mViewp=
ort-&gt;getActualHeight() / 2.0;
-
-	//long StartTick =3D cShell::GetTicks();
-	if (mSpriteManager-&gt;UseWorldCam()) {
-		for ( std::list&lt;cBaseSprite*&gt;::reverse_iterator itor=3DmSpriteList.rbegi=
n(); itor!=3DmSpriteList.rend(); ++itor ) {
-			(*itor)-&gt;Execute( ViewPortWidthHalf, ViewPortHeightHalf, mSpriteManager=
-&gt;GetCam()-&gt;getPosition().x, mSpriteManager-&gt;GetCam()-&gt;getPosition().y );
-		}
-	} else {
-		for ( std::list&lt;cBaseSprite*&gt;::reverse_iterator itor=3DmSpriteList.rbegi=
n(); itor!=3DmSpriteList.rend(); ++itor ) {
-			(*itor)-&gt;Execute( ViewPortWidthHalf, ViewPortHeightHalf, 0, 0 );
-		}
-	}
+	if (!mListSorted &amp;&amp; cShell::GetTicks() - mLastSort &gt; 10 ) {
+		mLastSort =3D cShell::GetTicks();
+		mSpriteList.sort( CompareSprites() );
+		mListSorted =3D true;
+		//( &quot;%d sprites sortet in %d msec.\n&quot;, mSpriteList.size(), cShell::GetTi=
cks() - mLastSort );
+
+		int Pos =3D 1;
+		for ( std::list&lt;cBaseSprite*&gt;::iterator itor=3DmSpriteList.begin(); itor=
!=3DmSpriteList.end(); ++itor ) {
+			if ((*itor)-&gt;GetPosition() !=3D Pos ) {
+				(*itor)-&gt;SetPosition( Pos );
+				mListResorted =3D true;
+			}
+			Pos++;
+		}
+	}
+
+	double ViewPortWidthHalf  =3D (double)cOgreWrapper::GetSingleton().mViewp=
ort-&gt;getActualWidth() / 2.0;
+	double ViewPortHeightHalf =3D (double)cOgreWrapper::GetSingleton().mViewp=
ort-&gt;getActualHeight() / 2.0;
+
+	//long StartTick =3D cShell::GetTicks();
+	if (mSpriteManager-&gt;UseWorldCam()) {
+		for ( std::list&lt;cBaseSprite*&gt;::reverse_iterator itor=3DmSpriteList.rbegi=
n(); itor!=3DmSpriteList.rend(); ++itor ) {
+			(*itor)-&gt;Execute( ViewPortWidthHalf, ViewPortHeightHalf, mSpriteManager=
-&gt;GetCam()-&gt;getPosition().x, mSpriteManager-&gt;GetCam()-&gt;getPosition().y );
+		}
+	} else {
+		for ( std::list&lt;cBaseSprite*&gt;::reverse_iterator itor=3DmSpriteList.rbegi=
n(); itor!=3DmSpriteList.rend(); ++itor ) {
+			(*itor)-&gt;Execute( ViewPortWidthHalf, ViewPortHeightHalf, 0, 0 );
+		}
+	}
 	//printf( &quot;%d Sprites drawn in %d msec.\n&quot;, SpriteList.size(), cShell::Ge=
tTicks() - StartTick );*/
 }
 =

@@ -188,83 +188,83 @@
 	mUseWorldCam =3D UseCam;
 	mLightningEnabled =3D false;
 =

-	mSceneMan =3D SceneMan;
-	mTargetQueue =3D TargetQueue;
-	mAfterQueue =3D AfterQueue;
-
+	mSceneMan =3D SceneMan;
+	mTargetQueue =3D TargetQueue;
+	mAfterQueue =3D AfterQueue;
+
 	if (mUseWorldCam) {
 		mCam =3D cOgreWrapper::GetSingleton().mCamera;
-	} else {
-		mCam =3D 0;
-	}
-	=

+	} else {
+		mCam =3D 0;
+	}
+	=

 	mSceneMan-&gt;addRenderQueueListener( this );
 }
 =

 class cSpriteQueueDeletor { public : inline void operator () (std::pair&lt; i=
nt, cSpriteQueue*&gt; doomed) { delete doomed.second; } };
-cSpriteManager::~cSpriteManager() { PROFILE
+cSpriteManager::~cSpriteManager() { PROFILE
 	mSceneMan-&gt;removeRenderQueueListener( this );
 =

 	std::for_each( mSpriteQueues.begin(), mSpriteQueues.end(), cSpriteQueueDe=
letor() );
 }
 =

-void cSpriteManager::renderBuffer() { PROFILE
-	prepareForRender();
-	for ( std::map&lt;int, cSpriteQueue*&gt;::iterator itor=3DmSpriteQueues.begin()=
; itor!=3DmSpriteQueues.end(); ++itor ) {
-		(*itor).second-&gt;Execute();
-	}
-}
-
-void cSpriteManager::prepareForRender() { PROFILE
-	Ogre::TextureUnitState::UVWAddressingMode uvwAddressMode;
-
-	Ogre::RenderSystem* RenderSys =3D Ogre::Root::getSingleton().getRenderSys=
tem();
-	=

-	Ogre::LayerBlendModeEx colorBlendMode;
-	Ogre::LayerBlendModeEx alphaBlendMode;
-	=

-	colorBlendMode.blendType =3D Ogre::LBT_COLOUR;
-	colorBlendMode.source1 =3D Ogre::LBS_TEXTURE;
-	colorBlendMode.operation =3D Ogre::LBX_SOURCE1;
-
-	alphaBlendMode.blendType =3D Ogre::LBT_ALPHA;
-	alphaBlendMode.source1 =3D Ogre::LBS_TEXTURE;
-	alphaBlendMode.operation =3D Ogre::LBX_SOURCE1;
-
-	uvwAddressMode.u =3D Ogre::TextureUnitState::TAM_CLAMP;
-	uvwAddressMode.v =3D Ogre::TextureUnitState::TAM_CLAMP;
-	uvwAddressMode.w =3D Ogre::TextureUnitState::TAM_CLAMP;
-
-	RenderSys-&gt;_setWorldMatrix( Ogre::Matrix4::IDENTITY );
-	if (mUseWorldCam) {
-		RenderSys-&gt;_setViewMatrix( mCam-&gt;getViewMatrix() ); =

-		RenderSys-&gt;_setProjectionMatrix( mCam-&gt;getProjectionMatrixRS() );
-	} else {
-		int w =3D cOgreWrapper::GetSingleton().mViewport-&gt;getActualWidth();
-		int h =3D cOgreWrapper::GetSingleton().mViewport-&gt;getActualHeight();
-
-		Ogre::Matrix4 ViewportMatrix =3D Ogre::Matrix4::getScale( 2.0/w, -2.0/h,=
 1.0 );
-		RenderSys-&gt;_setViewMatrix( ViewportMatrix );
-		RenderSys-&gt;_setProjectionMatrix( Ogre::Matrix4::IDENTITY );
-	}
-
-	RenderSys-&gt;_setTextureMatrix( 0, Ogre::Matrix4::IDENTITY );
-	RenderSys-&gt;_setTextureCoordSet( 0, 0 );
-	RenderSys-&gt;_setTextureCoordCalculation( 0, Ogre::TEXCALC_NONE );
-	RenderSys-&gt;_setTextureUnitFiltering( 0, Ogre::FO_LINEAR, Ogre::FO_LINEAR,=
 Ogre::FO_NONE );
-	RenderSys-&gt;_setTextureBlendMode( 0, colorBlendMode );
-	RenderSys-&gt;_setTextureBlendMode( 0, alphaBlendMode );
-	RenderSys-&gt;_setTextureAddressingMode( 0, uvwAddressMode );
-	RenderSys-&gt;_disableTextureUnitsFrom( 1 );	=

-	RenderSys-&gt;_setFog( Ogre::FOG_NONE );
-	RenderSys-&gt;_setCullingMode( Ogre::CULL_NONE );
-	RenderSys-&gt;_setDepthBufferParams( false, false );
-	RenderSys-&gt;_setColourBufferWriteEnabled( true, true, true, false );
-	RenderSys-&gt;setShadingType( Ogre::SO_GOURAUD );
-	RenderSys-&gt;_setPolygonMode( Ogre::PM_SOLID );
-	RenderSys-&gt;unbindGpuProgram( Ogre::GPT_FRAGMENT_PROGRAM );
-	RenderSys-&gt;unbindGpuProgram( Ogre::GPT_VERTEX_PROGRAM );
-	RenderSys-&gt;_setSceneBlending( Ogre::SBF_SOURCE_ALPHA, Ogre::SBF_ONE_MINUS=
_SOURCE_ALPHA );
+void cSpriteManager::renderBuffer() { PROFILE
+	prepareForRender();
+	for ( std::map&lt;int, cSpriteQueue*&gt;::iterator itor=3DmSpriteQueues.begin()=
; itor!=3DmSpriteQueues.end(); ++itor ) {
+		(*itor).second-&gt;Execute();
+	}
+}
+
+void cSpriteManager::prepareForRender() { PROFILE
+	Ogre::TextureUnitState::UVWAddressingMode uvwAddressMode;
+
+	Ogre::RenderSystem* RenderSys =3D Ogre::Root::getSingleton().getRenderSys=
tem();
+	=

+	Ogre::LayerBlendModeEx colorBlendMode;
+	Ogre::LayerBlendModeEx alphaBlendMode;
+	=

+	colorBlendMode.blendType =3D Ogre::LBT_COLOUR;
+	colorBlendMode.source1 =3D Ogre::LBS_TEXTURE;
+	colorBlendMode.operation =3D Ogre::LBX_SOURCE1;
+
+	alphaBlendMode.blendType =3D Ogre::LBT_ALPHA;
+	alphaBlendMode.source1 =3D Ogre::LBS_TEXTURE;
+	alphaBlendMode.operation =3D Ogre::LBX_SOURCE1;
+
+	uvwAddressMode.u =3D Ogre::TextureUnitState::TAM_CLAMP;
+	uvwAddressMode.v =3D Ogre::TextureUnitState::TAM_CLAMP;
+	uvwAddressMode.w =3D Ogre::TextureUnitState::TAM_CLAMP;
+
+	RenderSys-&gt;_setWorldMatrix( Ogre::Matrix4::IDENTITY );
+	if (mUseWorldCam) {
+		RenderSys-&gt;_setViewMatrix( mCam-&gt;getViewMatrix() ); =

+		RenderSys-&gt;_setProjectionMatrix( mCam-&gt;getProjectionMatrixRS() );
+	} else {
+		int w =3D cOgreWrapper::GetSingleton().mViewport-&gt;getActualWidth();
+		int h =3D cOgreWrapper::GetSingleton().mViewport-&gt;getActualHeight();
+
+		Ogre::Matrix4 ViewportMatrix =3D Ogre::Matrix4::getScale( 2.0/w, -2.0/h,=
 1.0 );
+		RenderSys-&gt;_setViewMatrix( ViewportMatrix );
+		RenderSys-&gt;_setProjectionMatrix( Ogre::Matrix4::IDENTITY );
+	}
+
+	RenderSys-&gt;_setTextureMatrix( 0, Ogre::Matrix4::IDENTITY );
+	RenderSys-&gt;_setTextureCoordSet( 0, 0 );
+	RenderSys-&gt;_setTextureCoordCalculation( 0, Ogre::TEXCALC_NONE );
+	RenderSys-&gt;_setTextureUnitFiltering( 0, Ogre::FO_LINEAR, Ogre::FO_LINEAR,=
 Ogre::FO_NONE );
+	RenderSys-&gt;_setTextureBlendMode( 0, colorBlendMode );
+	RenderSys-&gt;_setTextureBlendMode( 0, alphaBlendMode );
+	RenderSys-&gt;_setTextureAddressingMode( 0, uvwAddressMode );
+	RenderSys-&gt;_disableTextureUnitsFrom( 1 );	=

+	RenderSys-&gt;_setFog( Ogre::FOG_NONE );
+	RenderSys-&gt;_setCullingMode( Ogre::CULL_NONE );
+	RenderSys-&gt;_setDepthBufferParams( false, false );
+	RenderSys-&gt;_setColourBufferWriteEnabled( true, true, true, false );
+	RenderSys-&gt;setShadingType( Ogre::SO_GOURAUD );
+	RenderSys-&gt;_setPolygonMode( Ogre::PM_SOLID );
+	RenderSys-&gt;unbindGpuProgram( Ogre::GPT_FRAGMENT_PROGRAM );
+	RenderSys-&gt;unbindGpuProgram( Ogre::GPT_VERTEX_PROGRAM );
+	RenderSys-&gt;_setSceneBlending( Ogre::SBF_SOURCE_ALPHA, Ogre::SBF_ONE_MINUS=
_SOURCE_ALPHA );
 	RenderSys-&gt;_setAlphaRejectSettings( Ogre::CMPF_GREATER, 128 );
 	RenderSys-&gt;setLightingEnabled( mLightningEnabled );
 }
@@ -301,14 +301,14 @@
 			delete SpriteQueue;
 		}
 	}
-}
-
-void cSpriteManager::renderQueueStarted( Ogre::uint8 queueGroupId, const O=
gre::String &amp;invocation, bool &amp;skipThisInvocation ) { PROFILE
-	if ( !mAfterQueue &amp;&amp; queueGroupId =3D=3D mTargetQueue )
-      renderBuffer();
-}
-
-void cSpriteManager::renderQueueEnded( Ogre::uint8 queueGroupId, const Ogr=
e::String &amp;invocation, bool &amp;repeatThisInvocation ) { PROFILE
-	if ( mAfterQueue &amp;&amp; queueGroupId =3D=3D mTargetQueue )
-      renderBuffer();
-}
+}
+
+void cSpriteManager::renderQueueStarted( Ogre::uint8 queueGroupId, const O=
gre::String &amp;invocation, bool &amp;skipThisInvocation ) { PROFILE
+	if ( !mAfterQueue &amp;&amp; queueGroupId =3D=3D mTargetQueue )
+      renderBuffer();
+}
+
+void cSpriteManager::renderQueueEnded( Ogre::uint8 queueGroupId, const Ogr=
e::String &amp;invocation, bool &amp;repeatThisInvocation ) { PROFILE
+	if ( mAfterQueue &amp;&amp; queueGroupId =3D=3D mTargetQueue )
+      renderBuffer();
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000138.html">[Iris-commit] [IRIS] r1324 - in /branches/knut/data/lua: net.customhouse.lua net.walk.lua net/net.mobile.lua net/net.multi.lua
</A></li>
	<LI>Next message: <A HREF="000144.html">[Iris-commit] [IRIS] r1326 - in /branches/knut/src: builder.cpp scripting.cpp spritemanager.cpp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#143">[ date ]</a>
              <a href="thread.html#143">[ thread ]</a>
              <a href="subject.html#143">[ subject ]</a>
              <a href="author.html#143">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/iris-commit">More information about the Iris-commit
mailing list</a><br>
</body></html>
