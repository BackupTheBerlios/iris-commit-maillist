<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Iris-commit] [IRIS] r1314 - in /branches/knut/src: Makefile.am builder.cpp builder_L.cpp data.cpp data_L.cpp gfx3D.cpp gfx3D_L.cpp grannyogreloader.cpp grannyparser.cpp meshshape.cpp net.cpp net_L.cpp ogrewrapper.cpp scripting.cpp sound_fmod.cpp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/iris-commit/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:iris-commit%40lists.berlios.de?Subject=Re%3A%20%5BIris-commit%5D%20%5BIRIS%5D%20r1314%20-%20in%20/branches/knut/src%3A%20Makefile.am%0A%20builder.cpp%20builder_L.cpp%20data.cpp%20data_L.cpp%20gfx3D.cpp%20gfx3D_L.cpp%0A%20grannyogreloader.cpp%20grannyparser.cpp%20meshshape.cpp%20net.cpp%20net_L.cpp%0A%20ogrewrapper.cpp%20scripting.cpp%20sound_fmod.cpp&In-Reply-To=%3C20070801185716.967ADB140B5%40localhost.localdomain%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000130.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Iris-commit] [IRIS] r1314 - in /branches/knut/src: Makefile.am builder.cpp builder_L.cpp data.cpp data_L.cpp gfx3D.cpp gfx3D_L.cpp grannyogreloader.cpp grannyparser.cpp meshshape.cpp net.cpp net_L.cpp ogrewrapper.cpp scripting.cpp sound_fmod.cpp</H1>
    <B>no-reply at zwischenwelt.org</B> 
    <A HREF="mailto:iris-commit%40lists.berlios.de?Subject=Re%3A%20%5BIris-commit%5D%20%5BIRIS%5D%20r1314%20-%20in%20/branches/knut/src%3A%20Makefile.am%0A%20builder.cpp%20builder_L.cpp%20data.cpp%20data_L.cpp%20gfx3D.cpp%20gfx3D_L.cpp%0A%20grannyogreloader.cpp%20grannyparser.cpp%20meshshape.cpp%20net.cpp%20net_L.cpp%0A%20ogrewrapper.cpp%20scripting.cpp%20sound_fmod.cpp&In-Reply-To=%3C20070801185716.967ADB140B5%40localhost.localdomain%3E"
       TITLE="[Iris-commit] [IRIS] r1314 - in /branches/knut/src: Makefile.am builder.cpp builder_L.cpp data.cpp data_L.cpp gfx3D.cpp gfx3D_L.cpp grannyogreloader.cpp grannyparser.cpp meshshape.cpp net.cpp net_L.cpp ogrewrapper.cpp scripting.cpp sound_fmod.cpp">no-reply at zwischenwelt.org
       </A><BR>
    <I>Wed Aug  1 20:57:15 CEST 2007</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000130.html">[Iris-commit] [IRIS] r1315 - in /branches/knut/include: ColourClipTextOverlay.h builder.h data.h gfx3D.h grannyparser.h meshshape.h net.h ogrewrapper.h prefix.h spritemanager.h
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#141">[ date ]</a>
              <a href="thread.html#141">[ thread ]</a>
              <a href="subject.html#141">[ subject ]</a>
              <a href="author.html#141">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ghoulsblade
Date: Wed Aug  1 20:57:14 2007
New Revision: 1314

Log:
ported changes from trunk to knut/src branch, r 1031:1313

Modified:
    branches/knut/src/Makefile.am
    branches/knut/src/builder.cpp
    branches/knut/src/builder_L.cpp
    branches/knut/src/data.cpp
    branches/knut/src/data_L.cpp
    branches/knut/src/gfx3D.cpp
    branches/knut/src/gfx3D_L.cpp
    branches/knut/src/grannyogreloader.cpp
    branches/knut/src/grannyparser.cpp
    branches/knut/src/meshshape.cpp
    branches/knut/src/net.cpp
    branches/knut/src/net_L.cpp
    branches/knut/src/ogrewrapper.cpp
    branches/knut/src/scripting.cpp
    branches/knut/src/sound_fmod.cpp

Modified: branches/knut/src/Makefile.am
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/Makefile.am (original)
+++ branches/knut/src/Makefile.am Wed Aug  1 20:57:14 2007
@@ -1,6 +1,6 @@
-INCLUDES =3D -I/usr/include -I/opt/fmod/api/inc @OGRE_CFLAGS@ @lua50_CFLAG=
S@ @lualib50_CFLAGS@ @openal_CFLAGS@ @vorbisfile_CFLAGS@ $(OIS_CFLAGS)
+INCLUDES =3D -I/usr/include -I/usr/local/include/fmodex @OGRE_CFLAGS@ @lua=
50_CFLAGS@ @lualib50_CFLAGS@ @openal_CFLAGS@ @vorbisfile_CFLAGS@ $(OIS_CFLA=
GS)
 =

-irisogre_LDFLAGS=3D -L/opt/fmod/api -lfmod-3.75 -lSDL @OGRE_LIBS@ @lua50_L=
IBS@ @lualib50_LIBS@ @openal_LIBS@ @alut_LIBS@ @vorbisfile_LIBS@ $(OIS_LIBS)
+irisogre_LDFLAGS=3D -L/usr/local/lib -lfmodex -lSDL @OGRE_LIBS@ @lua50_LIB=
S@ @lualib50_LIBS@ @openal_LIBS@ @alut_LIBS@ @vorbisfile_LIBS@ $(OIS_LIBS)
 =

 noinst_PROGRAMS=3Dirisogre
 =


Modified: branches/knut/src/builder.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/builder.cpp (original)
+++ branches/knut/src/builder.cpp Wed Aug  1 20:57:14 2007
@@ -275,7 +275,7 @@
 =

 =

 /// WARNING ! changes size to 2^n where n &gt;=3D 4
-bool	GenerateGumpMaterial	(cGumpLoader&amp; oGumpLoader,const char* szMatName,=
const int iID,const bool bHasAlpha,cHueLoader* pHueLoader,short iHue) { PRO=
FILE
+bool	GenerateGumpMaterial	(cGumpLoader&amp; oGumpLoader,const char* szMatName,=
const int iID,const bool bHasAlpha,cHueLoader* pHueLoader,const short iHue)=
 { PROFILE
 	cGump *gump =3D oGumpLoader.GetGump(iID);
 	if (gump =3D=3D 0) return false;
 	int iImgW =3D gump-&gt;GetWidth();
@@ -287,7 +287,6 @@
 		while (iTexW &lt; iImgW) iTexW &lt;&lt;=3D 1;
 		while (iTexH &lt; iImgH) iTexH &lt;&lt;=3D 1;
 	}
-
 	short *pImgRaw =3D new short[iTexW*iTexH] ;
 	memset(pImgRaw,0,2*iTexW*iTexH);
 	if( iHue &amp;&amp; pHueLoader ) {
@@ -547,24 +546,41 @@
 }*/
 =

 Ogre::FontPtr	GenerateUniFont	(cUniFontFileLoader&amp; oUniFontFileLoader, con=
st char *szName, =

+	const int code_first, const int code_last,
 	const float letter_r, const float letter_g, const float letter_b, const f=
loat letter_a,
 	const float border_r, const float border_g, const float border_b, const f=
loat border_a,
 	const float free_r, const float free_g, const float free_b, const float f=
ree_a){ PROFILE
+
+	int first =3D code_first,last =3D code_last;
+
+	// borders
+	if(first &lt; 0)first =3D 0;
+	if(last &gt;=3D oUniFontFileLoader.GetLetterNumbers())last =3D oUniFontFileL=
oader.GetLetterNumbers() - 1;
+	if(last &lt; first)last =3D first;
+	=

+	// number of letters to load
+	unsigned int letters =3D last - first + 1;
+
+	std::map&lt;int,Ogre::Rectangle&gt; lCache;
+
 	// max letter size (without border space)
 	unsigned int maxw =3D oUniFontFileLoader.GetMaxWidth();
 	unsigned int maxh =3D oUniFontFileLoader.GetMaxHeight();
 	// size + border (fontborder and freepixel)
-	unsigned int letw =3D maxw + 6 + 2;
-	unsigned int leth =3D maxh + 6 + 2;
+	// 6 + 2
+	unsigned int letw =3D maxw + 4;
+	unsigned int leth =3D maxh + 4;
 	// offset to the start of maxletter size
 	unsigned int letx =3D 4;
 	unsigned int lety =3D 4;
 	// size of the texture that stores all letter images (2^n)
 	unsigned int texw =3D 1;
 	unsigned int texh =3D 1;
-	// 16*16 is enough space to store all 255 letters
-	texw =3D Ogre::Bitwise::firstPO2From(letw * 16);
-	texh =3D Ogre::Bitwise::firstPO2From(leth * 16);
+	// OBSOLETE 16*16 is enough space to store all 255 letters
+	//int size =3D sqrt(float(oUniFontFileLoader.GetLetterNumbers())*oUniFont=
FileLoader.GetLetterUsage());
+	int size =3D mymax(letw,leth) * sqrt(float(letters));
+	texw =3D Ogre::Bitwise::firstPO2From(size);
+	texh =3D Ogre::Bitwise::firstPO2From(size);
 	=

 	// imagebuffer
 	unsigned int buffersize =3D Ogre::PixelUtil::getMemorySize(texw,texh,1,Og=
re::PF_A4R4G4B4);
@@ -587,58 +603,81 @@
 	const RawUniFontFileLetterHeader *hd;
 	const char *data;
 =

-	for(int i =3D 0;i &lt; cUniFontFileLoader::kLetterNumbers; ++i){
-		//printf(&quot;posx=3D%d posy=3D%d texw=3D%d texh=3D%d\n&quot;,posx,posy,texw,texh=
);
+	for(int i =3D first;i &lt;=3D last; ++i){
+		//if(i % 10 =3D=3D 0 || i =3D=3D first || i =3D=3D last)printf(&quot;[%05.1f%=
%] code=3D%d posx=3D%d posy=3D%d texw=3D%d texh=3D%d\n&quot;,100.0*float(i - cod=
e_first)/float(letters),i,posx,posy,texw,texh);
 =

 		// get letter data
 		hd =3D oUniFontFileLoader.GetLetterHeader(i);
 		data =3D oUniFontFileLoader.GetLetterData(i);
 =

-		// iterator over all pixels (letw,leth)
-		for(int x =3D 0;x &lt; letw; ++x)
-		for(int y =3D 0;y &lt; leth; ++y){
-			// calculate letter space to letter data buffer space
-			int dx =3D x - letx - hd-&gt;miXOffset;
-			int dy =3D y - lety - hd-&gt;miYOffset;
-			// calc position of the pixel in the image buffer
-			int ix =3D posx + x;
-			int iy =3D posy + y;
-			// read out pixel
-			float r,g,b,a;
+		//printf(&quot;check letter %i at %x\n&quot;,i,data);
+
+		// skip if invalid offset
+		if(data =3D=3D 0)continue;
+
+		// letter already rendered?
+		if(lCache.find(int(data)) =3D=3D lCache.end()){
+			// decode letter and store in image
+
+			// iterator over all pixels (letw,leth)
+			for(int x =3D 0;x &lt; letw; ++x)
+			for(int y =3D 0;y &lt; leth; ++y){
+				// calculate letter space to letter data buffer space
+				int dx =3D x - letx - hd-&gt;miXOffset;
+				int dy =3D y - lety - hd-&gt;miYOffset;
+				// calc position of the pixel in the image buffer
+				int ix =3D posx + x;
+				int iy =3D posy + y;
+				// read out pixel
+				float r,g,b,a;
+				=

+				if(cUniFontFileLoader::IsPixelBorder(data,hd-&gt;miWidth,hd-&gt;miHeight,dx,=
dy)){
+					r =3D border_r; g =3D border_g; b =3D border_b; a =3D border_a;
+				} else if(cUniFontFileLoader::IsPixelVisible(data,hd-&gt;miWidth,hd-&gt;miHe=
ight,dx,dy)){
+					r =3D letter_r; g =3D letter_g; b =3D letter_b; a =3D letter_a;
+				} else {
+					r =3D free_r; g =3D free_g; b =3D free_b; a =3D free_a;
+				}
+				=

+				// store color in image
+				Ogre::PixelUtil::packColour(r,g,b,a,Ogre::PF_A4R4G4B4,&amp;p[ix + iy*texw]=
);			=

+			}
 			=

-			if(cUniFontFileLoader::IsPixelBorder(data,hd-&gt;miWidth,hd-&gt;miHeight,dx,d=
y)){
-				r =3D border_r; g =3D border_g; b =3D border_b; a =3D border_a;
-			} else if(cUniFontFileLoader::IsPixelVisible(data,hd-&gt;miWidth,hd-&gt;miHei=
ght,dx,dy)){
-				r =3D letter_r; g =3D letter_g; b =3D letter_b; a =3D letter_a;
-			} else {
-				r =3D free_r; g =3D free_g; b =3D free_b; a =3D free_a;
-			}
+			// left and right borders of the letter in pixels
+			int l =3D posx + letx + hd-&gt;miXOffset - 1;
+			int r =3D posx + letx + hd-&gt;miXOffset + hd-&gt;miWidth + 1;
 			=

-			// store color in image
-			Ogre::PixelUtil::packColour(r,g,b,a,Ogre::PF_A4R4G4B4,&amp;p[ix + iy*texw])=
;			=

-		}
-		=

-		// left and right borders of the letter in pixels
-		int l =3D posx + letx + hd-&gt;miXOffset - 2;
-		int r =3D posx + letx + hd-&gt;miXOffset + hd-&gt;miWidth + 2;
-		=

-		// set glyphe text coords
-		float u1 =3D float(l)/float(texw);
-		float v1 =3D float(posy + lety - 2)/float(texh);
-		float u2 =3D float(r)/float(texw);
-		float v2 =3D float(posy + lety + maxh + 2)/float(texh);
-		font-&gt;setGlyphTexCoords(i,u1,v1,u2,v2,float(texw)/float(texh));  =

-		=

-		//printf(&quot;%c: u1=3D%f v1=3D%f u2=3D%f v2=3D%f\n&quot;,i,u1,v1,u2,v2);
-		//printf(&quot;   u1=3D%f v1=3D%f u2=3D%f v2=3D%f\n&quot;,u1*float(texw),v1*float(=
texh),u2*float(texw),v2*float(texh));
-		//printf(&quot;   h=3D%d\n&quot;,int((v2-v1)*float(texh)));
-		=

-		// move window in texture to next free space
-		posx +=3D letw;
-		if(posx + letw &gt;=3D texw){
-			// oki one line is full, so move the window to the next
-			posx =3D 0;
-			posy +=3D leth;
+			// set glyphe text coords
+			float u1 =3D float(l)/float(texw);
+			float v1 =3D float(posy + lety - 1)/float(texh);
+			float u2 =3D float(r)/float(texw);
+			float v2 =3D float(posy + lety + maxh + 1)/float(texh);
+			font-&gt;setGlyphTexCoords(i,u1,v1,u2,v2,float(texw)/float(texh));  =

+			=

+			//printf(&quot;%c: u1=3D%f v1=3D%f u2=3D%f v2=3D%f\n&quot;,i,u1,v1,u2,v2);
+			//printf(&quot;   u1=3D%f v1=3D%f u2=3D%f v2=3D%f\n&quot;,u1*float(texw),v1*float=
(texh),u2*float(texw),v2*float(texh));
+			//printf(&quot;   h=3D%d\n&quot;,int((v2-v1)*float(texh)));
+			=

+			// move window in texture to next free space
+			posx +=3D letw;
+			if(posx + letw &gt;=3D texw){
+				// oki one line is full, so move the window to the next
+				posx =3D 0;
+				posy +=3D leth;
+			}
+
+			// store generated rect under data pointer in cache
+			{
+				Ogre::Rectangle r;
+				r.left =3D u1;r.right =3D u2;
+				r.top =3D v1;r.bottom =3D v2;
+				lCache[int(data)] =3D r;
+			}
+		} else {
+			// use already written part if the image
+			Ogre::Rectangle r(lCache.find(int(data))-&gt;second);
+			// set glyphe text coords
+			font-&gt;setGlyphTexCoords(i,r.left,r.top,r.right,r.bottom,float(texw)/flo=
at(texh));
 		}
 	}
 =

@@ -648,10 +687,13 @@
 	=

 	//img.resize(texw*2,texh*2,Ogre::Image::FILTER_NEAREST);
 	=

-	=

 	// save on disk
-	//std::string filename =3D std::string(szName) + std::string(&quot;.png&quot;);
-	//img.save(filename);
+	/*
+	printf(&quot;save image...\n&quot;);
+	std::string filename =3D std::string(szName) + std::string(&quot;.png&quot;);
+	img.save(filename);
+	printf(&quot;done\n&quot;);
+	*/
 	=

 	// generate texture name from the fontname
 	std::string sTexName =3D std::string(szName) + std::string(&quot;_tex&quot;);

Modified: branches/knut/src/builder_L.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/builder_L.cpp (original)
+++ branches/knut/src/builder_L.cpp Wed Aug  1 20:57:14 2007
@@ -141,6 +141,7 @@
 			REGISTER_METHOD(Build);
 			REGISTER_METHOD(AddEntity);
 			REGISTER_METHOD(SetVisible);
+			REGISTER_METHOD(SetCastShadows);
 			#undef REGISTER_METHOD
 		}
 =

@@ -153,6 +154,14 @@
 		=

 	// object methods exported to lua
 =

+		=

+		/// void		SetCastShadows		(bool shadow)
+		static int		SetCastShadows		(lua_State *L) { PROFILE
+			Ogre::StaticGeometry* pOgreStaticGeom =3D checkudata_alive(L)-&gt;mpOgreSt=
aticGeom;
+			if (pOgreStaticGeom) pOgreStaticGeom-&gt;setCastShadows(lua_toboolean(L,2)=
);
+			return 0;
+		}
+		=

 		static int	Destroy		(lua_State *L) { PROFILE delete checkudata_alive(L);=
 return 0; }
 		static int	Build		(lua_State *L) { PROFILE checkudata_alive(L)-&gt;Build();=
 return 0; }
 		=


Modified: branches/knut/src/data.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/data.cpp (original)
+++ branches/knut/src/data.cpp Wed Aug  1 20:57:14 2007
@@ -592,7 +592,15 @@
 =

 cHueLoader	::cHueLoader	(const char* szDataFile) : cFullFileLoader(szDataF=
ile) {}
 	=

+int		cHueLoader::GetMaxHueID		() { =

+	// miFullFileSize =3D 265500
+	int eightblocks =3D (miFullFileSize - 4) / 708; // (265500 - 4) / 708 =3D=
 374.99...
+	int singles =3D ((miFullFileSize - 4) - 708*eightblocks) / 88;// ((265500=
 - 4) - 708*374)/ 88 =3D 704 / 88 =3D 8
+	return eightblocks*8 + singles; // 374*8 + 8 =3D 3000
+}
+
 cHue*	cHueLoader	::GetHue	(const int iID){
+	if (iID &lt; 0 || iID &gt;=3D GetMaxHueID()) return GetHue(0); // illegal hue a=
sked
 	mLastHue.miID =3D iID;
 	mLastHue.mpRawData =3D mpFullFileBuffer+((((8*88)+4)*(iID/8)) + 4 + (88*(=
iID%8)));
 	return &mLastHue;
@@ -819,6 +827,19 @@
 	*/
 }
 =

+const int cUniFontFileLoader::GetLetterNumbers(){return 0xFFFF;}
+const float cUniFontFileLoader::GetLetterUsage(){
+	std::map&lt;int,int&gt; lCache;
+	for(int i=3D0;i&lt;GetLetterNumbers();++i){
+		int data =3D int(GetLetterData(i));
+		if(lCache.find(data) =3D=3D lCache.end())lCache[data] =3D 1;
+		else lCache[data] =3D lCache[data] + 1;
+	}
+	float usage =3D float(lCache.size()) / float(GetLetterNumbers());
+	printf(&quot;usage=3D%f.2\n&quot;,usage);
+	return usage;
+}
+
 RawUniFontFileLetterHeader* cUniFontFileLoader::GetLetterHeader	(const uns=
igned int iCode){ PROFILE
 	// read out offset of letter header
 	int32 offset =3D ((int32 *)(mpFullFileBuffer))[iCode];
@@ -830,10 +851,8 @@
 }
 =

 const char* cUniFontFileLoader::GetLetterData	(const unsigned int iCode){ =
PROFILE
-	// read out offset of letter header
-	uint32 offset =3D *((uint32 *)(mpFullFileBuffer + iCode*4));
-	// valid?
-	if(offset + sizeof(RawUniFontFileLetterHeader) &lt; miFullFileSize)return mp=
FullFileBuffer + offset + sizeof(RawUniFontFileLetterHeader);
+	char *p =3D (char *)GetLetterHeader(iCode);
+	if(p)return p + sizeof(RawUniFontFileLetterHeader);
 	else return 0;
 }
 =

@@ -844,7 +863,7 @@
 char cUniFontFileLoader::GetMaxWidth(){ PROFILE
 	char m =3D 0;
 	const RawUniFontFileLetterHeader *h;
-	for(unsigned char i =3D 0;i &lt; kLetterNumbers; ++i){
+	for(unsigned int i =3D 0;i &lt; GetLetterNumbers(); ++i){
 		h =3D GetLetterHeader(i);
 		if(h){
 			// size
@@ -861,7 +880,7 @@
 char cUniFontFileLoader::GetMaxHeight(){ PROFILE
 	char m =3D 0;
 	const RawUniFontFileLetterHeader *h;
-	for(unsigned char i =3D 0;i &lt; kLetterNumbers; ++i){
+	for(unsigned int i =3D 0;i &lt; GetLetterNumbers(); ++i){
 		h =3D GetLetterHeader(i);
 		if(h){
 			// size

Modified: branches/knut/src/data_L.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/data_L.cpp (original)
+++ branches/knut/src/data_L.cpp Wed Aug  1 20:57:14 2007
@@ -134,6 +134,7 @@
 			REGISTER_METHOD(GetMaxWidth);
 			REGISTER_METHOD(GetMaxHeight);
 			REGISTER_METHOD(CountLetters);
+			REGISTER_METHOD(GetDefaultHeight);
 			REGISTER_METHOD(CreateOgreFont);
 			#undef REGISTER_METHOD
 		}
@@ -152,7 +153,8 @@
 		static int	Destroy				(lua_State *L) { PROFILE delete checkudata_alive(L=
); return 0; }
 		static int	GetMaxWidth			(lua_State *L) { PROFILE lua_pushnumber(L,check=
udata_alive(L)-&gt;GetMaxWidth()); return 1; }
 		static int	GetMaxHeight		(lua_State *L) { PROFILE lua_pushnumber(L,check=
udata_alive(L)-&gt;GetMaxHeight()); return 1; }	=

-		static int	CountLetters		(lua_State *L) { PROFILE lua_pushnumber(L,cUniF=
ontFileLoader::kLetterNumbers); return 1; }	=

+		static int	GetDefaultHeight	(lua_State *L) { PROFILE lua_pushnumber(L,ch=
eckudata_alive(L)-&gt;GetMaxHeight()+2); return 1; }	=

+		static int	CountLetters		(lua_State *L) { PROFILE lua_pushnumber(L,check=
udata_alive(L)-&gt;GetLetterNumbers()); return 1; }	=

 		=

 		/// for lua  xoffset,yoffset,w,h		GetLetterHeader		(code)
 		static int	GetLetterHeader				(lua_State *L) { PROFILE =

@@ -160,6 +162,7 @@
 			if (!target) return 0;
 			=

 			RawUniFontFileLetterHeader *h =3D target-&gt;GetLetterHeader(luaL_checkint=
(L,2));
+			if (!h) return 0;
 =

 			lua_pushnumber(L,h-&gt;miXOffset);
 			lua_pushnumber(L,h-&gt;miYOffset);
@@ -173,9 +176,10 @@
 			cUniFontFileLoader* target =3D checkudata_alive(L);
 			if (!target) return 0;
 			=

-			const char *szFontName =3D luaL_checkstring(L,2);
-			=

-			GenerateUniFont(*target,szFontName);
+			std::string sFontName =3D luaL_checkstring(L,2);
+			=

+			// load only ascii atm
+			GenerateUniFont(*target,sFontName.c_str(),0,255);
 			=

 			return 0; =

 		}	=

@@ -654,7 +658,7 @@
 		static int	GetStatic		(lua_State *L) { PROFILE =

 			cStaticBlock* pLastBlock =3D mLastBlock[checkudata_alive(L)];
 			int i =3D luaL_checkint(L,2);
-			if (!pLastBlock || i &lt; 0 || i &gt; pLastBlock-&gt;Count()) return 0;
+			if (!pLastBlock || i &lt; 0 || i &gt;=3D pLastBlock-&gt;Count()) return 0;
 			lua_pushnumber(L,pLastBlock-&gt;mpRawStaticList[i].miTileID); =

 			lua_pushnumber(L,pLastBlock-&gt;mpRawStaticList[i].miX); =

 			lua_pushnumber(L,pLastBlock-&gt;mpRawStaticList[i].miY); =


Modified: branches/knut/src/gfx3D.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/gfx3D.cpp (original)
+++ branches/knut/src/gfx3D.cpp Wed Aug  1 20:57:14 2007
@@ -394,6 +394,13 @@
 	if (mpParticleSystem) Clear();
 	mpParticleSystem =3D cOgreWrapper::GetSingleton().mSceneMgr-&gt;createPartic=
leSystem(cOgreWrapper::GetSingleton().GetUniqueName(),szTemplateName);
 	AttachObject(mpParticleSystem);
+}
+
+const unsigned int	cGfx3D::GetNumParticles	()	{ PROFILE
+	if (!mpSceneNode) return 0;
+	if (!mpParticleSystem) return 0;
+	=

+	return mpParticleSystem-&gt;getNumParticles();
 }
 =

 =


Modified: branches/knut/src/gfx3D_L.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/gfx3D_L.cpp (original)
+++ branches/knut/src/gfx3D_L.cpp Wed Aug  1 20:57:14 2007
@@ -76,6 +76,7 @@
 			REGISTER_METHOD(RenderableVertex);
 			REGISTER_METHOD(RenderableIndex);
 			REGISTER_METHOD(RenderableIndex3);
+			REGISTER_METHOD(RenderableIndex2);
 			REGISTER_METHOD(RenderableEnd);
 			REGISTER_METHOD(RenderableSkipVertices);
 			REGISTER_METHOD(RenderableSkipIndices);
@@ -84,9 +85,11 @@
 			REGISTER_METHOD(SetCastShadows);
 			=

 			REGISTER_METHOD(SetParticleSystem);
+			REGISTER_METHOD(SetParticleSystem);
 			REGISTER_METHOD(ParticleSystem_FastForward);
 			REGISTER_METHOD(ParticleSystem_SetNonVisibleUpdateTimeout);
 			REGISTER_METHOD(ParticleSystem_SetSpeedFactor);
+			REGISTER_METHOD(ParticleSystem_GetNumParticles);
 			=

 			REGISTER_METHOD(SetForcePosCam);
 			REGISTER_METHOD(SetForceRotCam);
@@ -390,6 +393,12 @@
 			Ogre::ParticleSystem* target =3D checkudata_alive(L)-&gt;mpParticleSystem;
 			if (target) target-&gt;setSpeedFactor(luaL_checknumber(L, 2));
 			return 0;
+		}
+		=

+		/// int			ParticleSystem_GetNumParticles			()
+		static int		ParticleSystem_GetNumParticles			(lua_State *L) { PROFILE
+			lua_pushnumber(L,checkudata_alive(L)-&gt;GetNumParticles());
+			return 1;
 		}
 		=

 		/// void		SetMesh			(udata_obj obj, string meshname=3D&quot;razor.mesh&quot;)
@@ -513,12 +522,20 @@
 			return 0;
 		}
 =

-		/// must be called between RenderableBegin and RenderableEnd
+		/// must be called between RenderableBegin and RenderableEnd, useful for=
 triangles
 		/// void		RenderableIndex3		(iIndex,iIndex,iIndex)
 		static int		RenderableIndex3		(lua_State *L) { PROFILE
 			checkudata_alive(L)-&gt;mpSimpleRenderable-&gt;Index(luaL_checkint(L,2));
 			checkudata_alive(L)-&gt;mpSimpleRenderable-&gt;Index(luaL_checkint(L,3));
 			checkudata_alive(L)-&gt;mpSimpleRenderable-&gt;Index(luaL_checkint(L,4));
+			return 0;
+		}
+
+		/// must be called between RenderableBegin and RenderableEnd, useful for=
 lines
+		/// void		RenderableIndex2		(iIndex,iIndex)
+		static int		RenderableIndex2		(lua_State *L) { PROFILE
+			checkudata_alive(L)-&gt;mpSimpleRenderable-&gt;Index(luaL_checkint(L,2));
+			checkudata_alive(L)-&gt;mpSimpleRenderable-&gt;Index(luaL_checkint(L,3));
 			return 0;
 		}
 		=


Modified: branches/knut/src/grannyogreloader.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/grannyogreloader.cpp (original)
+++ branches/knut/src/grannyogreloader.cpp Wed Aug  1 20:57:14 2007
@@ -52,14 +52,16 @@
 =

 =

 class cSubMeshConstructor { public:
+	int					miCurrentSubMesh;
+	int					miTargetSubMesh;
 	cGrannyLoader_i2*	mpGrannyLoader;
 	Ogre::MeshPtr&amp;		mpMesh;
 	Ogre::SkeletonPtr&amp;	mpSkeleton;
 	std::string			msMatName;
 	std::map&lt;int,int&gt;	mWeightBoneIndexMap; ///&lt; caches WeightBoneIndex2OgreBo=
neHandle results
 			=

-	cSubMeshConstructor	(cGrannyLoader_i2* pGrannyLoader,Ogre::MeshPtr&amp; mpMes=
h,Ogre::SkeletonPtr&amp; mpSkeleton,const char* szMatName)
-		: mpGrannyLoader(pGrannyLoader), mpMesh(mpMesh), mpSkeleton(mpSkeleton),=
 msMatName(szMatName) {}
+	cSubMeshConstructor	(cGrannyLoader_i2* pGrannyLoader,Ogre::MeshPtr&amp; mpMes=
h,Ogre::SkeletonPtr&amp; mpSkeleton,const char* szMatName,const int miTargetSub=
Mesh)
+		: mpGrannyLoader(pGrannyLoader), mpMesh(mpMesh), mpSkeleton(mpSkeleton),=
 msMatName(szMatName), miCurrentSubMesh(0), miTargetSubMesh(miTargetSubMesh=
) {}
 	=

 	/// translate weightindex to bone index using info from 0xCA5E0c0a (only =
in models, not in anims)
 	inline int		WeightBoneIndex2GrannyBoneID	(int iWeightBoneIndex) { PROFILE
@@ -110,6 +112,10 @@
 		// detect empty submesh
 		if (pLoaderSubMesh.mPolygons.second =3D=3D 0) return;
 			=

+		=

+		++miCurrentSubMesh;
+		if (miCurrentSubMesh - 1 !=3D miTargetSubMesh) return; // multiple subme=
shes not yet supported
+		=

 		/// if there was only one set of texcoord-or-color data, then it must ha=
ve been texcoords
 		if (!pLoaderSubMesh.mTexCoords.first &amp;&amp; pLoaderSubMesh.mColors.first) {
 			pLoaderSubMesh.mTexCoords =3D pLoaderSubMesh.mColors;
@@ -126,7 +132,7 @@
 		printf(&quot;mColors =3D %#08x %d\n&quot;,(int)pLoaderSubMesh.mColors.first,pLoade=
rSubMesh.mColors.second);
 		printf(&quot;mTexCoords =3D %#08x %d\n&quot;,(int)pLoaderSubMesh.mTexCoords.first,=
pLoaderSubMesh.mTexCoords.second);
 		printf(&quot;mPolygons =3D %#08x %d\n&quot;,(int)pLoaderSubMesh.mPolygons.first,pL=
oaderSubMesh.mPolygons.second);
-		*/
+		//*/
 		=

 		=

 		// TODO : collect combos for single indices
@@ -351,6 +357,8 @@
 		if (pGrannyLoader-&gt;mSubMeshes[i].mPolygons.second &gt; 0) bIsEmptyMesh =3D =
false;
 	}
 	=

+	//printf(&quot;LoadGrannyAsOgreMesh %s, submesh=3D%d\n&quot;,pGrannyLoader-&gt;mGranny=
.msFilePath.c_str(),pGrannyLoader-&gt;mSubMeshes.size());
+	=

 	// don't construct empty meshes
 	if (bIsEmptyMesh) return false;
 		=

@@ -375,7 +383,7 @@
 	}
 		=

 	//printf(&quot;cGrannyVisitor_OgreLoader::ConstructSubMeshes %d submeshes foun=
d\n&quot;,pGrannyLoader-&gt;mSubMeshes.size());
-	std::for_each(pGrannyLoader-&gt;mSubMeshes.begin(),pGrannyLoader-&gt;mSubMeshes=
.end(),cSubMeshConstructor(pGrannyLoader,pMesh,pSkeleton,szMatName));
+	std::for_each(pGrannyLoader-&gt;mSubMeshes.begin(),pGrannyLoader-&gt;mSubMeshes=
.end(),cSubMeshConstructor(pGrannyLoader,pMesh,pSkeleton,szMatName,0));
 	=

 			=

 	//Pose * 	Mesh::createPose (ushort target, const String &amp;name=3DStringUti=
l::BLANK)
@@ -400,13 +408,14 @@
 =

 /// constructs the animation and the bones used by it
 class cAnimationConstructor { public:
+	int					miCurrentSubMesh;
 	std::vector&lt;cGrannyLoader_i2*&gt;&amp; mlBodySamples;
 	cGrannyLoader_i2*	mpGrannyLoader;
 	Ogre::SkeletonPtr&amp;	mpSkeleton;
 	Ogre::Animation* 	mpAnim;
 	int					miAnimDataCounter;
 	cAnimationConstructor	(cGrannyLoader_i2* pGrannyLoader,Ogre::SkeletonPtr&amp;=
 mpSkeleton,Ogre::Animation* mpAnim,std::vector&lt;cGrannyLoader_i2*&gt; &amp;mlBodyS=
amples)
-		: mpGrannyLoader(pGrannyLoader), mpSkeleton(mpSkeleton), mpAnim(mpAnim),=
 mlBodySamples(mlBodySamples), miAnimDataCounter(0) {}
+		: mpGrannyLoader(pGrannyLoader), mpSkeleton(mpSkeleton), mpAnim(mpAnim),=
 mlBodySamples(mlBodySamples), miAnimDataCounter(0), miCurrentSubMesh(0) {}
 	=

 	/// param must be lowercased
 	const GrannyBone* GetSampleBone	(const std::string&amp; sBoneName) {
@@ -505,6 +514,10 @@
 	=

 	/// constructs the animation
 	void	operator ()	(cGrannyLoader_i2::cAnim&amp; pAnim) {
+		=

+		//printf(&quot;cAnimationConstructor::miCurrentSubMesh =3D %d\n&quot;,miCurrentSub=
Mesh);
+		++miCurrentSubMesh;
+		=

 		int iCurAnimDataNum =3D miAnimDataCounter++;
 		int iCurBoneNum =3D mpGrannyLoader-&gt;FindBone(mpGrannyLoader-&gt;GetBoneName=
2(pAnim.mpAnim-&gt;iID-1));
 		Ogre::Bone* pBone =3D GetOrCreateBone(iCurBoneNum);
@@ -678,6 +691,9 @@
 };
 =

 void	LoadGrannyAsOgreAnim	(cGrannyLoader_i2* pGrannyLoader, const char* sz=
SkeletonName,const char* szAnimName,std::vector&lt;cGrannyLoader_i2*&gt; &amp;lBodySa=
mples) {
+	=

+	//printf(&quot;LoadGrannyAsOgreAnim %s\n&quot;,pGrannyLoader-&gt;mGranny.msFilePath.c_=
str());
+	=

 	Ogre::SkeletonPtr pSkeleton =3D Ogre::SkeletonManager::getSingleton().loa=
d(szSkeletonName,Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
 	if (pSkeleton.isNull()) return;
 	=


Modified: branches/knut/src/grannyparser.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/grannyparser.cpp (original)
+++ branches/knut/src/grannyparser.cpp Wed Aug  1 20:57:14 2007
@@ -230,7 +230,7 @@
 	return mlTypeNames[iType].c_str();
 }
 =

-cGranny::cGranny	(const char* szFilePath) {
+cGranny::cGranny	(const char* szFilePath) : msFilePath(szFilePath) {
 	//printf(&quot;cGranny(%s)\n&quot;,szFilePath);
 	std::ifstream myFileStream(szFilePath,std::ios_base::binary);
 	if (!myFileStream) throw GrannyLoadException(strprintf(&quot;cGranny::cGranny =
file not found : '%s'&quot;,szFilePath));

Modified: branches/knut/src/meshshape.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/meshshape.cpp (original)
+++ branches/knut/src/meshshape.cpp Wed Aug  1 20:57:14 2007
@@ -7,6 +7,11 @@
 using namespace Ogre;
 =

 std::map&lt;std::string,MeshShape*&gt;	gMeshShapeCache;
+
+void	UnloadMeshShape		(const char* szMeshName) {
+	MeshShape*&amp; pShape =3D gMeshShapeCache[szMeshName];
+	if (pShape) { delete pShape; pShape =3D 0; }
+}
 =

 MeshShape*	MeshShape::GetMeshShape				(Ogre::Entity* pEntity) {
 	if (!pEntity) return 0;

Modified: branches/knut/src/net.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/net.cpp (original)
+++ branches/knut/src/net.cpp Wed Aug  1 20:57:14 2007
@@ -108,6 +108,21 @@
 =

 const bool	cConnection::IsConnected(){
 	return miSocket !=3D INVALID_SOCKET;
+}
+
+
+// resolves hostname to nummeric ip, 0 on error
+unsigned int cNet::GetHostByName	(const char *szHost) { PROFILE
+	// gethostbyname
+	hostent*		h;
+	h =3D gethostbyname(szHost);
+	if(h){
+		return *((uint32 *)h-&gt;h_addr);
+	} else if(inet_addr(szHost) !=3D INADDR_NONE){
+		return inet_addr(szHost);
+	} else {
+		return 0;
+	}
 }
 =

 /// outgoing connection

Modified: branches/knut/src/net_L.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/net_L.cpp (original)
+++ branches/knut/src/net_L.cpp Wed Aug  1 20:57:14 2007
@@ -17,7 +17,8 @@
 		virtual void RegisterMethods	(lua_State *L) { PROFILE
 			lua_register(L,&quot;NetConnect&quot;,		&amp;cConnection_L::NetConnect);
 			lua_register(L,&quot;NetReadAndWrite&quot;,	&amp;cConnection_L::NetReadAndWrite);
-			lua_register(L,&quot;NtoA&quot;,				&amp;cConnection_L::NtoA);
+			lua_register(L,&quot;NtoA&quot;,			&amp;cConnection_L::NtoA);
+			lua_register(L,&quot;GetHostByName&quot;,		&amp;cConnection_L::GetHostByName);
 			=

 			#define REGISTER_METHOD(methodname) mlMethod.push_back(make_luaL_reg(#m=
ethodname,&amp;cConnection_L::methodname));
 			REGISTER_METHOD(Destroy);
@@ -51,6 +52,24 @@
 			snprintf(buffer,16,&quot;%i.%i.%i.%i&quot;,(int)h[3],(int)h[2],(int)h[1],(int)h[0=
]);
 			lua_pushstring(L,buffer);
 			return 1;
+		}
+
+		/// converts a hostname to a ip as string or nil on error
+		/// for lua : int 	GetHostByName	(string hostname)
+		static int				GetHostByName	(lua_State *L) { PROFILE
+			unsigned int ip =3D cNet::GetHostByName(luaL_checkstring(L,1));
+			if(ip){
+				// TODO this could be system dependant, due to endianess
+				// probably use inet_ntop() ?
+				=

+				static char buffer[32];
+				unsigned char *h =3D (unsigned char *)&ip;
+				snprintf(buffer,16,&quot;%i.%i.%i.%i&quot;,(int)h[0],(int)h[1],(int)h[2],(int)h[=
3]);
+				lua_pushstring(L,buffer);
+				return 1;
+			} else {
+				return 0;
+			}
 		}
 =

 	// object methods exported to lua

Modified: branches/knut/src/ogrewrapper.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/ogrewrapper.cpp (original)
+++ branches/knut/src/ogrewrapper.cpp Wed Aug  1 20:57:14 2007
@@ -1,753 +1,770 @@
-#include &quot;prefix.h&quot;
-#include &quot;ogrewrapper.h&quot;
-#include &quot;input.h&quot;
-#include &quot;robstring1.2.h&quot;
-#include &lt;Ogre.h&gt;
-/*
-#include &lt;OgreInput.h&gt;
-#include &lt;OgreInputEvent.h&gt;
-#include &lt;OgreEventListeners.h&gt;
-#include &lt;OgreKeyEvent.h&gt;
-#include &lt;OgreOverlay.h&gt;
-#include &lt;OgreOverlayManager.h&gt;
-#include &lt;OgrePanelOverlayElement.h&gt;
-#include &lt;OgreTextAreaOverlayElement.h&gt;
-#include &lt;OgreWireBoundingBox.h&gt;
-#include &lt;SDL/SDL.h&gt;
-*/
-#include &lt;OIS/OIS.h&gt;
-#include &lt;map&gt;
-#include &quot;shell.h&quot;
-#include &quot;timer.h&quot;
-#include &quot;ColourClipPaneOverlay.h&quot;
-#include &quot;ColourClipTextOverlay.h&quot;
-#include &quot;BorderColourClipPaneOverlay.h&quot;
-#include &quot;SortedOverlayContainer.h&quot;
-#include &quot;RobRenderableOverlay.h&quot;
-#include &quot;widget.h&quot;
-#include &quot;meshshape.h&quot;
-#include &quot;game.h&quot;
-
-#include &quot;CompassOverlay.h&quot;
-
-using namespace OIS;
-using namespace Ogre;
-Ogre::LogManager* gLogMan =3D 0;
-
-
-void	DisplayErrorMessage		(const char* szMsg); ///&lt; defined in main.cpp, O=
S-specific
-
-cOgreUserObjectWrapper::cOgreUserObjectWrapper() : mpEntity(0), miType(0) =
{}
-cOgreUserObjectWrapper::~cOgreUserObjectWrapper() {}
-long cOgreUserObjectWrapper::getTypeID(void) const { return 23; }
-const Ogre::String&amp; cOgreUserObjectWrapper::getTypeName(void) const { stat=
ic Ogre::String eris(&quot;shiva&quot;); return eris; }
-
-	=

-cOgreWrapper::cOgreWrapper() : mRoot(0) {PROFILE
-    mCamera =3D 0;
-    mViewport =3D 0;
-    mSceneMgr =3D 0;
-    mWindow =3D 0;
-	mInputManager =3D 0;
-	mMouse =3D 0;
-	mKeyboard =3D 0;
-	mJoy =3D 0;
-}
-
-int gLastWinLeft =3D 0;
-int gLastWinTop =3D 0;
-
-/// warning, evil hack, since this is not really supported by ogre
-void	OgreForceCloseFullscreen () {
-	// found no other way to hide the window, setVisible and mWindow-&gt;destroy=
() didn't work
-	// arg, even mRoot-&gt;shutdown() didn't work
-	delete cOgreWrapper::GetSingleton().mRoot;
-    cOgreWrapper::GetSingleton().mCamera =3D 0;
-    cOgreWrapper::GetSingleton().mViewport =3D 0;
-    cOgreWrapper::GetSingleton().mSceneMgr =3D 0;
-    cOgreWrapper::GetSingleton().mWindow =3D 0;
-	cOgreWrapper::GetSingleton().mInputManager =3D 0;
-	cOgreWrapper::GetSingleton().mMouse =3D 0;
-	cOgreWrapper::GetSingleton().mKeyboard =3D 0;
-	cOgreWrapper::GetSingleton().mJoy =3D 0;
-	=

-	char* szPluginCfgPath =3D &quot;plugins.cfg&quot;;
-	#ifdef WIN32
-	#else
-	szPluginCfgPath =3D &quot;plugins_linux.cfg&quot;;
-	#endif
-	printf(&quot;ogre deinit ok, reinit...\n&quot;);
-	cOgreWrapper::GetSingleton().mRoot =3D new Root(szPluginCfgPath);
-}
-
-/// only call this once at startup
-bool	cOgreWrapper::Init			() {PROFILE
-	static bool bInitialised =3D false;
-	if (bInitialised) return false;
-	bInitialised =3D true;
-	=

-	// create custom logmanager so ogre doesn't dump all that junk onto the c=
onsole
-	gLogMan =3D new LogManager();
-	bool suppressFileOutput =3D false;
-	gLogMan-&gt;createLog(&quot;Ogre.log&quot;, true, false,suppressFileOutput);
-	//gLogMan-&gt;createLog(logFileName, true, true);
-
-	char* szPluginCfgPath =3D &quot;plugins.cfg&quot;;
-	#ifdef WIN32
-	#else
-	szPluginCfgPath =3D &quot;plugins_linux.cfg&quot;;
-	#endif
-	mRoot =3D new Root(szPluginCfgPath);
-	=

-	=

-	=

-	//setupResources();
-	{
-        // Load resource paths from config file
-        ConfigFile cf;
-        cf.load(&quot;resources.cfg&quot;);
-
-        // Go through all sections &amp; settings in the file
-        ConfigFile::SectionIterator seci =3D cf.getSectionIterator();
-
-        String secName, typeName, archName;
-        while (seci.hasMoreElements())
-        {
-            secName =3D seci.peekNextKey();
-            ConfigFile::SettingsMultiMap *settings =3D seci.getNext();
-            ConfigFile::SettingsMultiMap::iterator i;
-            for (i =3D settings-&gt;begin(); i !=3D settings-&gt;end(); ++i)
-            {
-                typeName =3D i-&gt;first;
-                archName =3D i-&gt;second;
-                ResourceGroupManager::getSingleton().addResourceLocation(
-                    archName, typeName, secName);
-            }
-        }
-	}
-	=

-	bool bWinDebug =3D false;
-	//bool carryOn =3D configure();
-	//if (!carryOn) return false;
-	if (!mRoot-&gt;restoreConfig() &amp;&amp; !mRoot-&gt;showConfigDialog()) return false;
-//	mRoot-&gt;getRenderSystem()-&gt;setConfigOption(&quot;RTT Preferred Mode&quot;,&quot;Copy&quot;);=
 // todo : set via lua ?
-	if (bWinDebug) printf(&quot;windebug safepoint -2\n&quot;); =

-	mRoot-&gt;getRenderSystem()-&gt;setWaitForVerticalBlank(false);
-	mWindow =3D mRoot-&gt;initialise(true,&quot;Iris2&quot;);
-	if (bWinDebug) printf(&quot;windebug safepoint -1\n&quot;); =

-	=

-	//printf(&quot;\n\n Ogre Root-Init Successful\n\n&quot;);
-	=

-	if (1) {
-		bool bufferedKeys =3D true;
-		bool bufferedMouse =3D true;
-		bool bufferedJoy =3D true;
-		ParamList pl;
-		size_t windowHnd =3D 0;
-		std::ostringstream windowHndStr;
-
-		mWindow-&gt;getCustomAttribute(&quot;WINDOW&quot;, &amp;windowHnd);
-		windowHndStr &lt;&lt; windowHnd;
-		pl.insert(std::make_pair(std::string(&quot;WINDOW&quot;), windowHndStr.str()));
-		#if defined OIS_WIN32_PLATFORM
-		//Default mode is foreground exclusive..but, we want to show mouse - so =
nonexclusive
-		pl.insert(std::make_pair(std::string(&quot;w32_mouse&quot;), std::string(&quot;DISCL_FO=
REGROUND&quot; )));
-		pl.insert(std::make_pair(std::string(&quot;w32_mouse&quot;), std::string(&quot;DISCL_NO=
NEXCLUSIVE&quot;)));
-		pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL=
_FOREGROUND&quot;)));
-		pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL=
_NONEXCLUSIVE&quot;)));
-		/*
-		temp[&quot;DISCL_BACKGROUND&quot;]	=3D DISCL_BACKGROUND;
-		temp[&quot;DISCL_EXCLUSIVE&quot;]		=3D DISCL_EXCLUSIVE;
-		temp[&quot;DISCL_FOREGROUND&quot;]	=3D DISCL_FOREGROUND;
-		temp[&quot;DISCL_NONEXCLUSIVE&quot;]	=3D DISCL_NONEXCLUSIVE;
-		temp[&quot;DISCL_NOWINKEY&quot;]		=3D DISCL_NOWINKEY;
-		*/
-		#elif defined OIS_LINUX_PLATFORM
-		//For this demo, show mouse and do not grab (confine to window)
-		pl.insert(std::make_pair(std::string(&quot;x11_mouse_grab&quot;), std::string(&quot;fal=
se&quot;)));
-		pl.insert(std::make_pair(std::string(&quot;x11_mouse_hide&quot;), std::string(&quot;fal=
se&quot;)));
-		pl.insert(std::make_pair(std::string(&quot;x11_keyboard_grab&quot;), std::string(&quot;=
false&quot;)));
-		pl.insert(std::make_pair(std::string(&quot;XAutoRepeatOn&quot;), std::string(&quot;true=
&quot;)));
-		#endif
-
-		mInputManager =3D InputManager::createInputSystem( pl );
-
-		//Create all devices (We only catch joystick exceptions here, as, most p=
eople have Key/Mouse)
-		mKeyboard =3D static_cast&lt;Keyboard*&gt;(mInputManager-&gt;createInputObject( O=
ISKeyboard, bufferedKeys ));
-		// init tranlation mode (Unicode or Ascii)
-		if (mKeyboard) {
-			OIS::Keyboard::TextTranslationMode myTextTranslationMode =3D OIS::Keybo=
ard::Ascii;
-			mKeyboard-&gt;setTextTranslation(myTextTranslationMode);
-			if (mKeyboard-&gt;getTextTranslation() !=3D myTextTranslationMode) {
-				DisplayErrorMessage(strprintf(&quot;failed initialising OIS TextTranslation=
Mode : %s\n&quot;,(myTextTranslationMode=3D=3DOIS::Keyboard::Ascii)?&quot;asci&quot;:&quot;unic=
ode&quot;).c_str());
-				exit(12);
-			}
-		}
-		mMouse =3D static_cast&lt;Mouse*&gt;(mInputManager-&gt;createInputObject( OISMous=
e, bufferedMouse ));
-		/*
-		try {
-			mJoy =3D static_cast&lt;JoyStick*&gt;(mInputManager-&gt;createInputObject( OISJo=
yStick, bufferedJoy ));
-		}
-		catch(...) {
-			mJoy =3D 0;
-		}
-		*/
-		=

-		class cMyOISListener : public KeyListener, public MouseListener { public:
-			cInput&amp; input;
-			cMyOISListener() : input(cInput::GetSingleton()) {}
-				=

-			bool keyPressed( const KeyEvent &amp;arg ) {
-				if (0) std::cout &lt;&lt; &quot;\nKeyPressed {&quot; &lt;&lt; arg.key
-					&lt;&lt; &quot;, &quot; &lt;&lt; ((Keyboard*)(arg.device))-&gt;getAsString(arg.key)
-					&lt;&lt; &quot;} || Character (&quot; &lt;&lt; (char)arg.text &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
-					=

-				input.KeyDown(input.KeyConvertOIS(arg.key),(char)arg.text);
-				=

-					=

-				return true;
-			}
-			bool keyReleased( const KeyEvent &amp;arg ) {
-				input.KeyUp( input.KeyConvertOIS(arg.key));
-				return true;
-			}
-			bool mouseMoved( const MouseEvent &amp;arg ) {
-				const OIS::MouseState&amp; s =3D arg.state;
-				if (0) std::cout &lt;&lt; &quot;\nMouseMoved: Abs(&quot;
-						  &lt;&lt; s.X.abs &lt;&lt; &quot;, &quot; &lt;&lt; s.Y.abs &lt;&lt; &quot;, &quot; &lt;&lt; s.Z.abs &lt;&lt; &quot;) Abs2(&quot;
-						  &lt;&lt; (s.X.abs-gLastWinLeft) &lt;&lt; &quot;, &quot; &lt;&lt; (s.Y.abs-gLastWinTop) &lt;&lt; &quot;, &quot;=
 &lt;&lt; s.Z.abs &lt;&lt; &quot;) Rel(&quot;
-						  &lt;&lt; s.X.rel &lt;&lt; &quot;, &quot; &lt;&lt; s.Y.rel &lt;&lt; &quot;, &quot; &lt;&lt; s.Z.rel &lt;&lt; &quot;)&quot;;
-				=

-				cInput::iMouse[0] =3D s.X.abs; //-gLastWinLeft;
-				cInput::iMouse[1] =3D s.Y.abs; //-gLastWinTop;
-				if (s.Z.rel &lt; 0) { input.KeyDown(cInput::kkey_wheelup); input.KeyUp(cI=
nput::kkey_wheelup); }
-				if (s.Z.rel &gt; 0) { input.KeyDown(cInput::kkey_wheeldown); input.KeyUp(=
cInput::kkey_wheeldown); }
-				return true;
-			}
-			bool mousePressed( const MouseEvent &amp;arg, MouseButtonID id ) {
-				if (0) std::cout &lt;&lt; &quot;\nMousePressed: &quot; &lt;&lt; id;
-				=

-				switch (id) {
-					case MB_Left: input.KeyDown(cInput::kkey_mouse1); break;
-					case MB_Right: input.KeyDown(cInput::kkey_mouse2); break;
-					case MB_Middle: input.KeyDown(cInput::kkey_mouse3); break;
-				}
-				=

-				return true;
-			}
-			bool mouseReleased( const MouseEvent &amp;arg, MouseButtonID id ) {
-				if (0) std::cout &lt;&lt; &quot;\nMouseReleased: &quot; &lt;&lt; id;
-					=

-				switch (id) {
-					case MB_Left: input.KeyUp(cInput::kkey_mouse1); break;
-					case MB_Right: input.KeyUp(cInput::kkey_mouse2); break;
-					case MB_Middle: input.KeyUp(cInput::kkey_mouse3); break;
-				}
-				=

-				return true;
-			}
-		};
-		cMyOISListener* pMyOISListener =3D new cMyOISListener();
-
-		mKeyboard-&gt;setEventCallback(pMyOISListener);
-		mMouse-&gt;setEventCallback(pMyOISListener);
-
-		class cMyWindowListener : public Ogre::WindowEventListener { public:
-			virtual void windowMoved(RenderWindow* rw) {
-				if ( !cOgreWrapper::GetSingleton().mInputManager ) return;
-				unsigned int width, height, depth;
-				int left, top;
-				rw-&gt;getMetrics(width, height, depth, left, top);
-				gLastWinLeft =3D left;
-				gLastWinTop =3D top;
-				//printf(&quot;windowMoved, l,t=3D%d,%d\n&quot;,left,top); commented out by spam=
filter...
-			}
-			=

-			//Adjust mouse clipping area
-			virtual void windowResized(RenderWindow* rw)
-			{
-				if ( !cOgreWrapper::GetSingleton().mInputManager ) return;
-				unsigned int width, height, depth;
-				int left, top;
-				rw-&gt;getMetrics(width, height, depth, left, top);
-
-				const OIS::MouseState &amp;ms =3D cOgreWrapper::GetSingleton().mMouse-&gt;get=
MouseState();
-				ms.width =3D width;
-				ms.height =3D height;
-				=

-				// notify game that window was resized
-				cGame::GetSingleton().NotifyMainWindowResized(width,height);
-			}
-			=

-			//Unattach OIS before window shutdown (very important under Linux)
-			virtual void windowClosed(RenderWindow* rw)
-			{
-				//Only close for window that created OIS (the main window in these dem=
os)
-				if( rw =3D=3D cOgreWrapper::GetSingleton().mWindow )
-				{
-					cShell::mbAlive =3D false;
-					if( cOgreWrapper::GetSingleton().mInputManager )
-					{
-						cOgreWrapper::GetSingleton().mInputManager-&gt;destroyInputObject( cOgr=
eWrapper::GetSingleton().mMouse );
-						cOgreWrapper::GetSingleton().mInputManager-&gt;destroyInputObject( cOgr=
eWrapper::GetSingleton().mKeyboard );
-						cOgreWrapper::GetSingleton().mInputManager-&gt;destroyInputObject( cOgr=
eWrapper::GetSingleton().mJoy );
-						cOgreWrapper::GetSingleton().mMouse =3D 0;
-						cOgreWrapper::GetSingleton().mKeyboard =3D 0;
-						cOgreWrapper::GetSingleton().mJoy =3D 0;
-
-						OIS::InputManager::destroyInputSystem(cOgreWrapper::GetSingleton().m=
InputManager);
-						cOgreWrapper::GetSingleton().mInputManager =3D 0;
-					}
-				}
-			}
-		};
-		cMyWindowListener* pMyWindowListener =3D new cMyWindowListener();
-
-		//Set initial mouse clipping size
-		pMyWindowListener-&gt;windowResized(mWindow);
-		=

-		//Register as a Window listener
-		// ogrenew/OgreMain/include/OgreWindowEventUtilities.h
-		// static void Ogre::WindowEventUtilities::addWindowEventListener(Ogre::=
RenderWindow*, Ogre::WindowEventListener*)
-		WindowEventUtilities::addWindowEventListener(mWindow, pMyWindowListener);
-	}
-		=

-	=

-	//printf(&quot;\n\n Ogre Event-Init Successful\n\n&quot;);
-	=

-	//chooseSceneManager();
-	//for ogre 1.0
-	//mSceneMgr =3D mRoot-&gt;getSceneManager(ST_GENERIC);
-	//for ogre 1.2
-	if (bWinDebug) printf(&quot;windebug safepoint 0\n&quot;); =

-	mSceneMgr =3D mRoot-&gt;createSceneManager(ST_GENERIC,&quot;main&quot;);
-	if (!mSceneMgr) { printf(&quot;COULDN'T CREATE SCENEMANAGER\n&quot;); exit(3); }
-	if (bWinDebug) printf(&quot;windebug safepoint 1\n&quot;); =

-	=

-
-	mpCamHolderSceneNode =3D mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneN=
ode(&quot;CamHolder&quot;);
-	mpCamPosSceneNode =3D mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode=
(&quot;CamPos&quot;);
-	=

-	//printf(&quot;\n\n Ogre SceneManager-Init Successful\n\n&quot;);
-	=

-	//createCamera();
-	{
-		// Create the camera
-		mCamera =3D mSceneMgr-&gt;createCamera(&quot;PlayerCam&quot;);
-
-		// Position it at 500 in Z direction
-		mCamera-&gt;setPosition(Vector3(0,0,40));
-		// Look back along -Z
-		//mCamera-&gt;lookAt(Vector3(0,0,0));
-		mCamera-&gt;setNearClipDistance(1);
-		//mCamera-&gt;setPolygonMode(PM_WIREFRAME);
-	}
-	if (bWinDebug) printf(&quot;windebug safepoint 2\n&quot;); =

-	=

-	//printf(&quot;\n\n Ogre Camera-Init Successful\n\n&quot;);
-	=

-	// TODO : redesign this for lua cam handling
-	mpCamHolderSceneNode-&gt;attachObject(mCamera);
-	// Create one viewport, entire window
-	mViewport =3D mWindow-&gt;addViewport(mCamera);
-	mViewport-&gt;setBackgroundColour(ColourValue(0,0,0));
-	=

-	if (bWinDebug) printf(&quot;windebug safepoint 3\n&quot;); =

-	// Alter the camera aspect ratio to match the viewport
-	mCamera-&gt;setAspectRatio(Real(mViewport-&gt;getActualWidth()) / Real(mViewpor=
t-&gt;getActualHeight()));
-	=

-	=

-	if (bWinDebug) printf(&quot;windebug safepoint 4\n&quot;); =

-	//printf(&quot;\n\n Ogre Viewport-Init Successful\n\n&quot;);
-	=

-	=

-	if (0) { // mbRttHack
-		// render to texture hack, required for hagish's weird gfx-setup only =
=3D)
-		RenderTexture* rttTex =3D mRoot-&gt;getRenderSystem()-&gt;createRenderTexture(=
 &quot;RttTex&quot;, 512, 512, TEX_TYPE_2D, PF_R8G8B8 );
-		Viewport* vp =3D rttTex-&gt;addViewport( mCamera );
-		vp-&gt;setOverlaysEnabled( false );
-		vp-&gt;setClearEveryFrame( true );
-		vp-&gt;setBackgroundColour( ColourValue::Black );
-		=

-		//printf(&quot;\n\n Ogre RTT-HACK-Init Successful\n\n&quot;);
-	}
-	=

-	if (bWinDebug) printf(&quot;windebug safepoint 5\n&quot;); =

-	// Set default mipmap level (NB some APIs ignore this)
-	TextureManager::getSingleton().setDefaultNumMipmaps(5);
-	Animation::setDefaultInterpolationMode(Animation::IM_SPLINE);
-
-	/*
-	mFiltering =3D TFO_TRILINEAR; mAniso =3D 1;
-	mFiltering =3D TFO_ANISOTROPIC; mAniso =3D 8;
-	mFiltering =3D TFO_BILINEAR; mAniso =3D 1;
-	MaterialManager::getSingleton().setDefaultTextureFiltering(mFiltering);
-	MaterialManager::getSingleton().setDefaultAnisotropy(mAniso);
-	*/
-	=

-	// TODO : Create any resource listeners (for loading screens)
-	=

-	// Load resources
-	// loadResources();
-	// Initialise, parse scripts etc
-	if (bWinDebug) printf(&quot;windebug safepoint 6\n&quot;); =

-	ResourceGroupManager::getSingleton().initialiseAllResourceGroups();
-
-	if (bWinDebug) printf(&quot;windebug safepoint 7\n&quot;); =

-	=

-	cCompassOverlay::RegisterFactory();
-	cRobRenderableOverlay::RegisterFactory();
-	cColourClipPaneOverlay::RegisterFactory();
-	cColourClipTextOverlay::RegisterFactory();
-	cBorderColourClipPaneOverlay::RegisterFactory();
-	cSortedOverlayContainer::RegisterFactory();
-	=

-	// sfzgui
-	if (1) {
-		class cSFZGUIEventPump : public cListener { public:
-			cDialogManager* mpDialogMan;
-			cSFZGUIEventPump() {
-				mpDialogMan =3D &amp;cDialogManager::GetSingleton();
-			}
-			=

-			enum {
-				kEventBinding_InputEvent,
-				kEventBinding_EveryFrame,
-			};
-			virtual	void	Listener_Notify (cListenable* pTarget,const size_t eventco=
de =3D 0,const size_t param =3D 0,const size_t userdata =3D 0) {
-				size_t key,c;
-				switch (userdata) {
-					case kEventBinding_EveryFrame:	// time,mousemovement
-						cDialogManager::GetSingleton().OnEnterFrame(cTimer::miCurFrameNum,cI=
nput::iMouse[0],cInput::iMouse[1]);
-					break;
-					case kEventBinding_InputEvent:
-						key =3D (size_t)(param &amp; 255);
-						c =3D (size_t)((param &gt;&gt; 8) &amp; 255);
-						switch (eventcode) {
-							case cInput::kListenerEvent_KeyPress:
-								mpDialogMan-&gt;InjectKey(key,c,true);
-							break;
-							case cInput::kListenerEvent_KeyRelease:
-								mpDialogMan-&gt;InjectKey(key,c,false);
-							break;
-						}
-					break;
-				}
-			}
-		};
-		cSFZGUIEventPump* pump =3D new cSFZGUIEventPump();
-		cInput::GetSingleton().RegisterListener(pump,(int)cSFZGUIEventPump::kEve=
ntBinding_InputEvent);
-		cTimer::GetSingletonPtr()-&gt;RegisterFrameIntervalListener(pump,0,(int)cSF=
ZGUIEventPump::kEventBinding_EveryFrame);
-	}
-	=

-	if (bWinDebug) printf(&quot;windebug safepoint 12\n&quot;); =

-	=

-	return true;
-}
-
-void	cOgreWrapper::RenderOneFrame	() {PROFILE
-	if (!mRoot) return;
-		=

-	// draw one frame
-	mRoot-&gt;renderOneFrame();
-	=

-	// update input
-	Ogre::WindowEventUtilities::messagePump();
-	if (mKeyboard) mKeyboard-&gt;capture();
-	if (mMouse) mMouse-&gt;capture();
-	=

-	=

-	if (0) {
-		// terminate the application after a few seconds, useful for experimenti=
ng with input
-		static int iDeadTime =3D 0;
-		if (iDeadTime =3D=3D 0) iDeadTime =3D cShell::GetTicks() + 1000*20;
-		if (iDeadTime &lt; cShell::GetTicks()) cShell::mbAlive =3D false;
-	}
-}
-
-void	cOgreWrapper::DeInit		() {PROFILE
-	if (mRoot) delete mRoot; mRoot =3D 0;
-}
-
-void	cOgreWrapper::SetSkybox	(const char* szMatName,const bool bFlip) { PR=
OFILE
-	// setSkyBox (bool enable, const String &amp;materialName, Real distance=3D50=
00, bool drawFirst=3Dtrue, const Quaternion &amp;orientation=3DQuaternion::IDEN=
TITY, const String &amp;groupName=3DResourceGroupManager::DEFAULT_RESOURCE_GROU=
P_NAME)
- 	if (szMatName) {
-		if (bFlip)
-				mSceneMgr-&gt;setSkyBox(true,szMatName,1000,true,Quaternion(Degree(90),Ve=
ctor3(1,0,0)));
-		else	mSceneMgr-&gt;setSkyBox(true,szMatName);
-	} else {
-		mSceneMgr-&gt;setSkyBox(false,&quot;&quot;);
-	}
-}
-
-Ogre::SceneManager*	cOgreWrapper::GetSceneManager	(const char* szSceneMgrN=
ame) {
-	return mRoot-&gt;getSceneManager(szSceneMgrName);
-}
-
-void	cOgreWrapper::AttachCamera	(SceneNode* pSceneNode) {PROFILE
-	if (pSceneNode) =

-			pSceneNode-&gt;attachObject(mCamera);
-	else	mSceneMgr-&gt;getRootSceneNode()-&gt;attachObject(mCamera);
-}
-
-void	cOgreWrapper::SetCameraPos		(const Vector3 vPos) {PROFILE
-	mCamera-&gt;setPosition(vPos);
-}
-
-void	cOgreWrapper::SetCameraRot		(const Quaternion qRot) {PROFILE
-	mCamera-&gt;setOrientation(qRot);
-}
-
-void	cOgreWrapper::CameraLookAt		(const Vector3 vPos) { PROFILE
-	mCamera-&gt;lookAt(vPos);  =

-}
-
-/// highres screenshot from wiki
-/// <A HREF="http://www.ogre3d.org/wiki/index.php/High_resolution_screenshots">http://www.ogre3d.org/wiki/index.php/High_resolution_screenshots</A>
-void cOgreWrapper::TakeGridScreenshot(/*Ogre::RenderWindow* mWindow, Ogre:=
:<i>Camera* mCamera, */const int&amp; pGridSize, const Ogre::String&amp; pFileName, co=
</I>nst Ogre::String&amp; pFileExtention, const bool&amp; pStitchGridImages)
-{
-  /* Parameters:
-   *  mWindow:    Pointer to the render window.  This could be &quot;mWindow&quot; f=
rom the ExampleApplication,
-   *              the window automatically created obtained when calling
-   *              Ogre::Root::getSingletonPtr()-&gt;initialise(false) and ret=
rieved by calling
-   *              &quot;Ogre::Root::getSingletonPtr()-&gt;getAutoCreatedWindow()&quot;,=
 or the manually created
-   *              window from calling &quot;mRoot-&gt;createRenderWindow()&quot;.
-   *  mCamera:      Pointer to the camera &quot;looking at&quot; the scene of intere=
st
-   *  pGridSize:      The magnification factor.  A 2 will create a 2x2 gri=
d, doubling the size of the
-                screenshot.  A 3 will create a 3x3 grid, tripling the size=
 of the screenshot.
-   *  pFileName:      The filename to generate, without an extention.  To =
generate &quot;MyScreenshot.png&quot; this
-   *              parameter would contain the value &quot;MyScreenshot&quot;.
-   *  pFileExtention:    The extention of the screenshot file name, hence =
the type of graphics file to generate.
-   *              To generate &quot;MyScreenshot.pnh&quot; this parameter would cont=
ain &quot;.png&quot;.
-   *  pStitchGridImages:  Determines whether the grid screenshots are (tru=
e) automatically stitched into a single
-   *              image (and discarded) or whether they should (false) rem=
ain in their unstitched
-   *              form.  In that case they are sequentially numbered from =
0 to
-   *              pGridSize * pGridSize - 1 (if pGridSize is 3 then from 0=
 to 8).
-   *              =

-  */
-	bool overlaysEnabled =3D mViewport-&gt;getOverlaysEnabled();
-	mViewport-&gt;setOverlaysEnabled(false);	=

-	=

-  Ogre::String gridFilename;
-
-  if(pGridSize &lt;=3D 1)
-  {
-    // Simple case where the contents of the screen are taken directly
-    // Also used when an invalid value is passed within pGridSize (zero or=
 negative grid size)
-    gridFilename =3D pFileName + pFileExtention;
-
-    mWindow-&gt;writeContentsToFile(gridFilename);
-  }
-  else
-  {
-    // Generate a grid of screenshots
-    mCamera-&gt;setCustomProjectionMatrix(false); // reset projection matrix
-    Ogre::Matrix4 standard =3D mCamera-&gt;getProjectionMatrix();
-    double nearDist =3D mCamera-&gt;getNearClipDistance();
-    double nearWidth =3D (mCamera-&gt;getWorldSpaceCorners()[0] - mCamera-&gt;ge=
tWorldSpaceCorners()[1]).length();
-    double nearHeight =3D (mCamera-&gt;getWorldSpaceCorners()[1] - mCamera-&gt;g=
etWorldSpaceCorners()[2]).length();
-    Ogre::Image sourceImage;
-    Ogre::uchar* stitchedImageData;
-
-    // Process each grid
-    for (int nbScreenshots =3D 0; nbScreenshots &lt; pGridSize * pGridSize; n=
bScreenshots++) =

-    { =

-      // Use asymmetrical perspective projection. For more explanations ch=
eck out:
-      // <A HREF="http://www.cs.kuleuven.ac.be/cwis/research/graphics/INFOTEC/viewi=">http://www.cs.kuleuven.ac.be/cwis/research/graphics/INFOTEC/viewi=</A>
ng-in-3d/node8.html =

-      int y =3D nbScreenshots / pGridSize; =

-      int x =3D nbScreenshots - y * pGridSize; =

-      Ogre::Matrix4 shearing( =

-        1, 0,(x - (pGridSize - 1) * 0.5) * nearWidth / nearDist, 0, =

-        0, 1, -(y - (pGridSize - 1) * 0.5) * nearHeight / nearDist, 0, =

-        0, 0, 1, 0, =

-        0, 0, 0, 1); =

-      Ogre::Matrix4 scale( =

-        pGridSize, 0, 0, 0, =

-        0, pGridSize, 0, 0, =

-        0, 0, 1, 0, =

-        0, 0, 0, 1); =

-      mCamera-&gt;setCustomProjectionMatrix(true, standard * shearing * scale=
);
-      Ogre::Root::getSingletonPtr()-&gt;renderOneFrame();
-      gridFilename =3D pFileName + Ogre::StringConverter::toString(nbScree=
nshots) + pFileExtention;
-
-
-      // Screenshot of the current grid
-      mWindow-&gt;writeContentsToFile(gridFilename);
-
-      if(pStitchGridImages)
-      {
-        // Automatically stitch the grid screenshots
-        sourceImage.load(gridFilename, &quot;General&quot;); // Assumes that the cur=
rent directory is within the &quot;General&quot; resource group
-        int sourceWidth =3D (int) sourceImage.getWidth();
-        int sourceHeight =3D (int) sourceImage.getHeight();
-        Ogre::ColourValue colourValue;
-        int stitchedX, stitchedY, stitchedIndex;
-
-        // Allocate memory for the stitched image when processing the scre=
enshot of the first grid
-        if(nbScreenshots =3D=3D 0)
-          stitchedImageData =3D new Ogre::uchar[(sourceImage.getWidth() * =
pGridSize) * (sourceImage.getHeight() * pGridSize) * 3]; // 3 colors per pi=
xel
-
-        // Copy each pixel within the grid screenshot to the proper positi=
on within the stitched image
-        for(int rawY =3D 0; rawY &lt; sourceHeight; rawY++)
-        {
-          for(int rawX =3D 0; rawX &lt; sourceWidth; rawX++)
-          {
-            colourValue =3D sourceImage.getColourAt(rawX, rawY, 0);
-            stitchedX =3D x * sourceWidth + rawX;
-            stitchedY =3D y * sourceHeight + rawY;
-            stitchedIndex =3D stitchedY * sourceWidth * pGridSize + stitch=
edX;
-            Ogre::PixelUtil::packColour(colourValue,
-                          Ogre::PF_R8G8B8,
-                          (void*) &amp;stitchedImageData[stitchedIndex * 3]);
-          }
-        }
-        // The screenshot of the grid is no longer needed
-        remove(gridFilename.c_str());
-      }
-    } =

-    mCamera-&gt;setCustomProjectionMatrix(false); // reset projection matrix =

-
-    if(pStitchGridImages)
-    {
-      // Save the stitched image to a file
-      Ogre::Image targetImage;
-      targetImage.loadDynamicImage(stitchedImageData,
-                    sourceImage.getWidth() * pGridSize,
-                    sourceImage.getHeight() * pGridSize,
-                    1, // depth
-                    Ogre::PF_R8G8B8,
-                    false);
-      targetImage.save(pFileName + pFileExtention);
-      delete[] stitchedImageData;
-    }
-  }
-	mViewport-&gt;setOverlaysEnabled(overlaysEnabled);	=

-} =

-
-void	cOgreWrapper::TakeScreenshot	(const char* szDirPath) {PROFILE
-	mWindow-&gt;writeContentsToFile( strprintf( &quot;%s%d.jpg&quot;, szDirPath, cShell::G=
etTicks() ) );
-}
-
-std::string		cOgreWrapper::GetUniqueName () {PROFILE
-	static int iLastName =3D 0;
-	return strprintf(&quot;n%04d&quot;,++iLastName);
-}
-
-/// avoid using OverlayManager::getSingleton().GetViewportHeight() as it i=
s one frame late
-int		cOgreWrapper::GetViewportHeight	() { return mViewport-&gt;getActualHeigh=
t(); }
-int		cOgreWrapper::GetViewportWidth	() { return mViewport-&gt;getActualWidth(=
); }
-
-bool	cOgreWrapper::RayAABBQuery	(const Ogre::Vector3&amp; vRayPos,const Ogre::=
Vector3&amp; vRayDir,const Ogre::AxisAlignedBox &amp;aabb,float* pfHitDist) { PROFI=
LE
-	static Ogre::Vector3 mlVertices[8];
-	static Ogre::Vector3 d,p000,p111,p100,p010,p001,p011,p101,p110;
-	p000 =3D aabb.getMinimum();
-	p111 =3D aabb.getMaximum();
-	d =3D p111-p000;
-	p100 =3D p000 + Ogre::Vector3(d.x,0,0);
-	p010 =3D p000 + Ogre::Vector3(0,d.y,0);
-	p001 =3D p000 + Ogre::Vector3(0,0,d.z);
-	p011 =3D p000 + Ogre::Vector3(0,d.y,d.z);
-	p101 =3D p000 + Ogre::Vector3(d.x,0,d.z);
-	p110 =3D p000 + Ogre::Vector3(d.x,d.y,0);
-	=

-	static int mlIndices[] =3D {
-		0,1,2, 3,1,2,	4,5,6, 7,5,6, // front, back
-		0,1,4, 5,1,4,	2,3,6, 7,3,6, // top, bottom
-		0,2,4, 6,2,4,	1,3,5, 7,3,5, // left, right
-		};
-	mlVertices[0] =3D p000;	mlVertices[1] =3D p100; // front
-	mlVertices[2] =3D p010;	mlVertices[3] =3D p110;	=

-	=

-	mlVertices[4] =3D p001;	mlVertices[5] =3D p101; // back
-	mlVertices[6] =3D p011;	mlVertices[7] =3D p111;
-	=

-	bool bHit =3D false;
-	float myHitDist;
-	=

-	for (int i=3D0;i&lt;6*6;i+=3D3) {
-		if (IntersectRayTriangle(vRayPos,vRayDir,
-			mlVertices[mlIndices[i+0]],
-			mlVertices[mlIndices[i+1]],
-			mlVertices[mlIndices[i+2]],&amp;myHitDist)) {
-			if (!bHit || myHitDist &lt; *pfHitDist) *pfHitDist =3D myHitDist;
-			bHit =3D true;
-		}
-	}
-	return bHit;
-}
-
-/// returns true if the ray intersects the entities triangles
-/// the resulting distance in the case of a hit is stored into pfHitDist
-/// see also OgreOpCode for more complex collision/intersection detection
-bool	cOgreWrapper::RayEntityQuery	(const Ogre::Vector3&amp; vRayPos,const Ogre=
::<i>Vector3&amp; vRayDir,Ogre::Entity* pEntity,const Ogre::Vector3&amp; vPos,const Og=
</I>re::Quaternion&amp; qRot,const Ogre::Vector3&amp; vScale,float* pfHitDist) { PROFILE
-	if (!pEntity) return false;
-	if (!pEntity-&gt;isVisible()) return false;
-		=

-	// get origin &amp; dir in coordinates local to the entity
-	MeshShape* myshape =3D MeshShape::GetMeshShape(pEntity);
-	if (!myshape) return false;
-	Ogre::Quaternion invrot =3D qRot.Inverse();
-	return myshape-&gt;RayIntersect((invrot*(vRayPos - vPos))/vScale,(invrot * v=
RayDir)/ vScale,pfHitDist);
-}
-
-/// extracs pos &amp; rot from scenenode, DOESNT WORK FOR entities in static g=
eometry (no scenenode)
-bool	cOgreWrapper::RayEntityQuery	(const Ogre::Vector3&amp; vRayPos,const Ogre=
::<i>Vector3&amp; vRayDir,Ogre::Entity* pEntity,float* pfHitDist) { PROFILE
</I>-	SceneNode* scenenode =3D pEntity ? pEntity-&gt;getParentSceneNode() : 0;
-	if (!scenenode) return false; // TODO : tagpoint (like knife in hand) att=
achment currently not supported...
-	return RayEntityQuery(vRayPos,vRayDir,pEntity,scenenode-&gt;_getDerivedPosit=
ion(),scenenode-&gt;_getDerivedOrientation(),scenenode-&gt;_getDerivedScale(),pfH=
itDist);
-}
-
-/// returns true if in front of cam, and fills x,y with clamped screencoor=
ds in [-1;1]
-/// and fills cx,cy with projected size on screen in [0;1]
-// cam-&gt;getProjectionMatrix() is cached inside ogre
-bool	cOgreWrapper::ProjectPos	(const Ogre::Vector3&amp; pos,Ogre::Real&amp; x,Ogre=
::<i>Real&amp; y) { PROFILE
</I>-	Camera* cam =3D mCamera;
-	Vector3 eyeSpacePos =3D cam-&gt;getViewMatrix(true) * pos;
-	// z &lt; 0 means in front of cam
-	if (eyeSpacePos.z &lt; 0) {
-		Vector3 screenSpacePos =3D cam-&gt;getProjectionMatrix() * eyeSpacePos;
-		x =3D screenSpacePos.x;
-		y =3D screenSpacePos.y;
-		bool bIsOnSreen =3D true;
-		if (x &lt; -1.0) { x =3D -1.0; bIsOnSreen =3D false; } if (x &gt; 1.0) { x =3D=
 1.0; bIsOnSreen =3D false; }
-		if (y &lt; -1.0) { y =3D -1.0; bIsOnSreen =3D false; } if (y &gt; 1.0) { y =3D=
 1.0; bIsOnSreen =3D false; }
-		return bIsOnSreen;
-	} else {
-		x =3D (-eyeSpacePos.x &gt; 0) ? -1 : 1;
-		y =3D (-eyeSpacePos.y &gt; 0) ? -1 : 1;
-		return false;
-	}
-}
-
-/// returns true if in front of cam, and fills x,y with clamped screencoor=
ds in [-1;1]
-/// and fills cx,cy with projected size on screen in [0;1]
-// cam-&gt;getProjectionMatrix() is cached inside ogre
-bool	cOgreWrapper::ProjectSizeAndPos	(const Ogre::Vector3&amp; pos,Ogre::Real&amp;=
 x,Ogre::Real&amp; y,const Ogre::Real rad,Ogre::Real&amp; cx,Ogre::Real&amp; cy) { PROF=
ILE
-	Camera* cam =3D mCamera;
-	Vector3 eyeSpacePos =3D cam-&gt;getViewMatrix(true) * pos;
-	// z &lt; 0 means in front of cam
-	if (eyeSpacePos.z &lt; 0) {
-		Vector3 screenSpacePos =3D cam-&gt;getProjectionMatrix() * eyeSpacePos;
-		x =3D screenSpacePos.x;
-		y =3D screenSpacePos.y;
-		bool bIsOnSreen =3D true;
-		if (x &lt; -1.0) { x =3D -1.0; bIsOnSreen =3D false; } if (x &gt; 1.0) { x =3D=
 1.0; bIsOnSreen =3D false; }
-		if (y &lt; -1.0) { y =3D -1.0; bIsOnSreen =3D false; } if (y &gt; 1.0) { y =3D=
 1.0; bIsOnSreen =3D false; }
-		if (bIsOnSreen) {
-			Vector3 spheresize(rad, rad, eyeSpacePos.z);
-			spheresize =3D cam-&gt;getProjectionMatrix() * spheresize;
-			cx =3D spheresize.x;
-			cy =3D spheresize.y;
-		} else {
-			cx =3D 0;
-			cy =3D 0;
-		}
-		return bIsOnSreen;
-	} else {
-		cx =3D 0;
-		cy =3D 0;
-		x =3D (-eyeSpacePos.x &gt; 0) ? -1 : 1;
-		y =3D (-eyeSpacePos.y &gt; 0) ? -1 : 1;
-		return false;
-	}
-}
+#include &quot;prefix.h&quot;
+#include &quot;ogrewrapper.h&quot;
+#include &quot;input.h&quot;
+#include &quot;robstring1.2.h&quot;
+#include &lt;Ogre.h&gt;
+/*
+#include &lt;OgreInput.h&gt;
+#include &lt;OgreInputEvent.h&gt;
+#include &lt;OgreEventListeners.h&gt;
+#include &lt;OgreKeyEvent.h&gt;
+#include &lt;OgreOverlay.h&gt;
+#include &lt;OgreOverlayManager.h&gt;
+#include &lt;OgrePanelOverlayElement.h&gt;
+#include &lt;OgreTextAreaOverlayElement.h&gt;
+#include &lt;OgreWireBoundingBox.h&gt;
+#include &lt;SDL/SDL.h&gt;
+*/
+#include &lt;OIS/OIS.h&gt;
+#include &lt;map&gt;
+#include &quot;shell.h&quot;
+#include &quot;timer.h&quot;
+#include &quot;ColourClipPaneOverlay.h&quot;
+#include &quot;ColourClipTextOverlay.h&quot;
+#include &quot;BorderColourClipPaneOverlay.h&quot;
+#include &quot;SortedOverlayContainer.h&quot;
+#include &quot;RobRenderableOverlay.h&quot;
+#include &quot;widget.h&quot;
+#include &quot;meshshape.h&quot;
+#include &quot;game.h&quot;
+
+#include &quot;CompassOverlay.h&quot;
+
+using namespace OIS;
+using namespace Ogre;
+Ogre::LogManager* gLogMan =3D 0;
+
+
+void	DisplayErrorMessage		(const char* szMsg); ///&lt; defined in main.cpp, O=
S-specific
+
+cOgreUserObjectWrapper::cOgreUserObjectWrapper() : mpEntity(0), miType(0) =
{}
+cOgreUserObjectWrapper::~cOgreUserObjectWrapper() {}
+long cOgreUserObjectWrapper::getTypeID(void) const { return 23; }
+const Ogre::String&amp; cOgreUserObjectWrapper::getTypeName(void) const { stat=
ic Ogre::String eris(&quot;shiva&quot;); return eris; }
+
+
+cOgreWrapper::cOgreWrapper() : mRoot(0) {PROFILE
+    mCamera =3D 0;
+    mViewport =3D 0;
+    mSceneMgr =3D 0;
+    mWindow =3D 0;
+	mInputManager =3D 0;
+	mMouse =3D 0;
+	mKeyboard =3D 0;
+	mJoy =3D 0;
+}
+
+int gLastWinLeft =3D 0;
+int gLastWinTop =3D 0;
+
+/// warning, evil hack, since this is not really supported by ogre
+void	OgreForceCloseFullscreen () {
+	// found no other way to hide the window, setVisible and mWindow-&gt;destroy=
() didn't work
+	// arg, even mRoot-&gt;shutdown() didn't work
+	delete cOgreWrapper::GetSingleton().mRoot;
+    cOgreWrapper::GetSingleton().mCamera =3D 0;
+    cOgreWrapper::GetSingleton().mViewport =3D 0;
+    cOgreWrapper::GetSingleton().mSceneMgr =3D 0;
+    cOgreWrapper::GetSingleton().mWindow =3D 0;
+	cOgreWrapper::GetSingleton().mInputManager =3D 0;
+	cOgreWrapper::GetSingleton().mMouse =3D 0;
+	cOgreWrapper::GetSingleton().mKeyboard =3D 0;
+	cOgreWrapper::GetSingleton().mJoy =3D 0;
+
+	char* szPluginCfgPath =3D &quot;plugins.cfg&quot;;
+	#ifdef WIN32
+	#else
+	szPluginCfgPath =3D &quot;plugins_linux.cfg&quot;;
+	#endif
+	printf(&quot;ogre deinit ok, reinit...\n&quot;);
+	cOgreWrapper::GetSingleton().mRoot =3D new Root(szPluginCfgPath);
+}
+
+/// only call this once at startup
+bool	cOgreWrapper::Init			() {PROFILE
+	static bool bInitialised =3D false;
+	if (bInitialised) return false;
+	bInitialised =3D true;
+
+	// create custom logmanager so ogre doesn't dump all that junk onto the c=
onsole
+	gLogMan =3D new LogManager();
+	bool suppressFileOutput =3D false;
+	gLogMan-&gt;createLog(&quot;Ogre.log&quot;, true, false,suppressFileOutput);
+	//gLogMan-&gt;createLog(logFileName, true, true);
+
+	char* szPluginCfgPath =3D &quot;plugins.cfg&quot;;
+	#ifdef WIN32
+	#else
+	szPluginCfgPath =3D &quot;plugins_linux.cfg&quot;;
+	#endif
+	mRoot =3D new Root(szPluginCfgPath);
+
+
+
+	//setupResources();
+	{
+        // Load resource paths from config file
+        ConfigFile cf;
+        cf.load(&quot;resources.cfg&quot;);
+
+        // Go through all sections &amp; settings in the file
+        ConfigFile::SectionIterator seci =3D cf.getSectionIterator();
+
+        String secName, typeName, archName;
+        while (seci.hasMoreElements())
+        {
+            secName =3D seci.peekNextKey();
+            ConfigFile::SettingsMultiMap *settings =3D seci.getNext();
+            ConfigFile::SettingsMultiMap::iterator i;
+            for (i =3D settings-&gt;begin(); i !=3D settings-&gt;end(); ++i)
+            {
+                typeName =3D i-&gt;first;
+                archName =3D i-&gt;second;
+                ResourceGroupManager::getSingleton().addResourceLocation(
+                    archName, typeName, secName);
+            }
+        }
+	}
+
+	bool bWinDebug =3D false;
+	//bool carryOn =3D configure();
+	//if (!carryOn) return false;
+	if (!mRoot-&gt;restoreConfig() &amp;&amp; !mRoot-&gt;showConfigDialog()) return false;
+//	mRoot-&gt;getRenderSystem()-&gt;setConfigOption(&quot;RTT Preferred Mode&quot;,&quot;Copy&quot;);=
 // todo : set via lua ?
+	if (bWinDebug) printf(&quot;windebug safepoint -2\n&quot;);
+	mRoot-&gt;getRenderSystem()-&gt;setWaitForVerticalBlank(false);
+	mWindow =3D mRoot-&gt;initialise(true,&quot;Iris2&quot;);
+	if (bWinDebug) printf(&quot;windebug safepoint -1\n&quot;);
+
+	//printf(&quot;\n\n Ogre Root-Init Successful\n\n&quot;);
+
+	if (1) {
+		bool bufferedKeys =3D true;
+		bool bufferedMouse =3D true;
+		bool bufferedJoy =3D true;
+		ParamList pl;
+		size_t windowHnd =3D 0;
+		std::ostringstream windowHndStr;
+
+		mWindow-&gt;getCustomAttribute(&quot;WINDOW&quot;, &amp;windowHnd);
+		windowHndStr &lt;&lt; windowHnd;
+		pl.insert(std::make_pair(std::string(&quot;WINDOW&quot;), windowHndStr.str()));
+		#if defined OIS_WIN32_PLATFORM
+		//Default mode is foreground exclusive..but, we want to show mouse - so =
nonexclusive
+		pl.insert(std::make_pair(std::string(&quot;w32_mouse&quot;), std::string(&quot;DISCL_FO=
REGROUND&quot; )));
+		pl.insert(std::make_pair(std::string(&quot;w32_mouse&quot;), std::string(&quot;DISCL_NO=
NEXCLUSIVE&quot;)));
+		pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL=
_FOREGROUND&quot;)));
+		pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL=
_NONEXCLUSIVE&quot;)));
+		/*
+		temp[&quot;DISCL_BACKGROUND&quot;]	=3D DISCL_BACKGROUND;
+		temp[&quot;DISCL_EXCLUSIVE&quot;]		=3D DISCL_EXCLUSIVE;
+		temp[&quot;DISCL_FOREGROUND&quot;]	=3D DISCL_FOREGROUND;
+		temp[&quot;DISCL_NONEXCLUSIVE&quot;]	=3D DISCL_NONEXCLUSIVE;
+		temp[&quot;DISCL_NOWINKEY&quot;]		=3D DISCL_NOWINKEY;
+		*/
+		#elif defined OIS_LINUX_PLATFORM
+		//For this demo, show mouse and do not grab (confine to window)
+		pl.insert(std::make_pair(std::string(&quot;x11_mouse_grab&quot;), std::string(&quot;fal=
se&quot;)));
+		pl.insert(std::make_pair(std::string(&quot;x11_mouse_hide&quot;), std::string(&quot;fal=
se&quot;)));
+		pl.insert(std::make_pair(std::string(&quot;x11_keyboard_grab&quot;), std::string(&quot;=
false&quot;)));
+		pl.insert(std::make_pair(std::string(&quot;XAutoRepeatOn&quot;), std::string(&quot;true=
&quot;)));
+		#endif
+
+		mInputManager =3D InputManager::createInputSystem( pl );
+
+		//Create all devices (We only catch joystick exceptions here, as, most p=
eople have Key/Mouse)
+		mKeyboard =3D static_cast&lt;Keyboard*&gt;(mInputManager-&gt;createInputObject( O=
ISKeyboard, bufferedKeys ));
+		// init tranlation mode (Unicode or Ascii)
+		if (mKeyboard) {
+			OIS::Keyboard::TextTranslationMode myTextTranslationMode =3D OIS::Keybo=
ard::Ascii;
+			mKeyboard-&gt;setTextTranslation(myTextTranslationMode);
+			if (mKeyboard-&gt;getTextTranslation() !=3D myTextTranslationMode) {
+				DisplayErrorMessage(strprintf(&quot;failed initialising OIS TextTranslation=
Mode : %s\n&quot;,(myTextTranslationMode=3D=3DOIS::Keyboard::Ascii)?&quot;asci&quot;:&quot;unic=
ode&quot;).c_str());
+				exit(12);
+			}
+		}
+		mMouse =3D static_cast&lt;Mouse*&gt;(mInputManager-&gt;createInputObject( OISMous=
e, bufferedMouse ));
+		/*
+		try {
+			mJoy =3D static_cast&lt;JoyStick*&gt;(mInputManager-&gt;createInputObject( OISJo=
yStick, bufferedJoy ));
+		}
+		catch(...) {
+			mJoy =3D 0;
+		}
+		*/
+
+		class cMyOISListener : public KeyListener, public MouseListener { public:
+			cInput&amp; input;
+			cMyOISListener() : input(cInput::GetSingleton()) {}
+
+			bool keyPressed( const KeyEvent &amp;arg ) {
+				if (0) std::cout &lt;&lt; &quot;\nKeyPressed {&quot; &lt;&lt; arg.key
+					&lt;&lt; &quot;, &quot; &lt;&lt; ((Keyboard*)(arg.device))-&gt;getAsString(arg.key)
+					&lt;&lt; &quot;} || Character (&quot; &lt;&lt; (char)arg.text &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+
+				input.KeyDown(input.KeyConvertOIS(arg.key),(char)arg.text);
+
+
+				return true;
+			}
+			bool keyReleased( const KeyEvent &amp;arg ) {
+				input.KeyUp( input.KeyConvertOIS(arg.key));
+				return true;
+			}
+			bool mouseMoved( const MouseEvent &amp;arg ) {
+				const OIS::MouseState&amp; s =3D arg.state;
+				if (0) std::cout &lt;&lt; &quot;\nMouseMoved: Abs(&quot;
+						  &lt;&lt; s.X.abs &lt;&lt; &quot;, &quot; &lt;&lt; s.Y.abs &lt;&lt; &quot;, &quot; &lt;&lt; s.Z.abs &lt;&lt; &quot;) Abs2(&quot;
+						  &lt;&lt; (s.X.abs-gLastWinLeft) &lt;&lt; &quot;, &quot; &lt;&lt; (s.Y.abs-gLastWinTop) &lt;&lt; &quot;, &quot;=
 &lt;&lt; s.Z.abs &lt;&lt; &quot;) Rel(&quot;
+						  &lt;&lt; s.X.rel &lt;&lt; &quot;, &quot; &lt;&lt; s.Y.rel &lt;&lt; &quot;, &quot; &lt;&lt; s.Z.rel &lt;&lt; &quot;)&quot;;
+
+				cInput::iMouse[0] =3D s.X.abs; //-gLastWinLeft;
+				cInput::iMouse[1] =3D s.Y.abs; //-gLastWinTop;
+				if (s.Z.rel &lt; 0) { input.KeyDown(cInput::kkey_wheelup); input.KeyUp(cI=
nput::kkey_wheelup); }
+				if (s.Z.rel &gt; 0) { input.KeyDown(cInput::kkey_wheeldown); input.KeyUp(=
cInput::kkey_wheeldown); }
+				return true;
+			}
+			bool mousePressed( const MouseEvent &amp;arg, MouseButtonID id ) {
+				if (0) std::cout &lt;&lt; &quot;\nMousePressed: &quot; &lt;&lt; id;
+
+				switch (id) {
+					case MB_Left: input.KeyDown(cInput::kkey_mouse1); break;
+					case MB_Right: input.KeyDown(cInput::kkey_mouse2); break;
+					case MB_Middle: input.KeyDown(cInput::kkey_mouse3); break;
+				}
+
+				return true;
+			}
+			bool mouseReleased( const MouseEvent &amp;arg, MouseButtonID id ) {
+				if (0) std::cout &lt;&lt; &quot;\nMouseReleased: &quot; &lt;&lt; id;
+
+				switch (id) {
+					case MB_Left: input.KeyUp(cInput::kkey_mouse1); break;
+					case MB_Right: input.KeyUp(cInput::kkey_mouse2); break;
+					case MB_Middle: input.KeyUp(cInput::kkey_mouse3); break;
+				}
+
+				return true;
+			}
+		};
+		cMyOISListener* pMyOISListener =3D new cMyOISListener();
+
+		mKeyboard-&gt;setEventCallback(pMyOISListener);
+		mMouse-&gt;setEventCallback(pMyOISListener);
+
+		class cMyWindowListener : public Ogre::WindowEventListener { public:
+			virtual void windowMoved(RenderWindow* rw) {
+				if ( !cOgreWrapper::GetSingleton().mInputManager ) return;
+				unsigned int width, height, depth;
+				int left, top;
+				rw-&gt;getMetrics(width, height, depth, left, top);
+				gLastWinLeft =3D left;
+				gLastWinTop =3D top;
+				//printf(&quot;windowMoved, l,t=3D%d,%d\n&quot;,left,top); commented out by spam=
filter...
+			}
+
+			//Adjust mouse clipping area
+			virtual void windowResized(RenderWindow* rw)
+			{
+				if ( !cOgreWrapper::GetSingleton().mInputManager ) return;
+				unsigned int width, height, depth;
+				int left, top;
+				rw-&gt;getMetrics(width, height, depth, left, top);
+
+				const OIS::MouseState &amp;ms =3D cOgreWrapper::GetSingleton().mMouse-&gt;get=
MouseState();
+				ms.width =3D width;
+				ms.height =3D height;
+
+				// notify game that window was resized
+				cGame::GetSingleton().NotifyMainWindowResized(width,height);
+			}
+
+			//Unattach OIS before window shutdown (very important under Linux)
+			virtual void windowClosed(RenderWindow* rw)
+			{
+				//Only close for window that created OIS (the main window in these dem=
os)
+				if( rw =3D=3D cOgreWrapper::GetSingleton().mWindow )
+				{
+					cShell::mbAlive =3D false;
+					if( cOgreWrapper::GetSingleton().mInputManager )
+					{
+						cOgreWrapper::GetSingleton().mInputManager-&gt;destroyInputObject( cOgr=
eWrapper::GetSingleton().mMouse );
+						cOgreWrapper::GetSingleton().mInputManager-&gt;destroyInputObject( cOgr=
eWrapper::GetSingleton().mKeyboard );
+						cOgreWrapper::GetSingleton().mInputManager-&gt;destroyInputObject( cOgr=
eWrapper::GetSingleton().mJoy );
+						cOgreWrapper::GetSingleton().mMouse =3D 0;
+						cOgreWrapper::GetSingleton().mKeyboard =3D 0;
+						cOgreWrapper::GetSingleton().mJoy =3D 0;
+
+						OIS::InputManager::destroyInputSystem(cOgreWrapper::GetSingleton().m=
InputManager);
+						cOgreWrapper::GetSingleton().mInputManager =3D 0;
+					}
+				}
+			}
+		};
+		cMyWindowListener* pMyWindowListener =3D new cMyWindowListener();
+
+		//Set initial mouse clipping size
+		pMyWindowListener-&gt;windowResized(mWindow);
+
+		//Register as a Window listener
+		// ogrenew/OgreMain/include/OgreWindowEventUtilities.h
+		// static void Ogre::WindowEventUtilities::addWindowEventListener(Ogre::=
RenderWindow*, Ogre::WindowEventListener*)
+		WindowEventUtilities::addWindowEventListener(mWindow, pMyWindowListener);
+	}
+
+
+	//printf(&quot;\n\n Ogre Event-Init Successful\n\n&quot;);
+
+	//chooseSceneManager();
+	//for ogre 1.0
+	//mSceneMgr =3D mRoot-&gt;getSceneManager(ST_GENERIC);
+	//for ogre 1.2
+	if (bWinDebug) printf(&quot;windebug safepoint 0\n&quot;);
+	mSceneMgr =3D mRoot-&gt;createSceneManager(ST_GENERIC,&quot;main&quot;);
+	if (!mSceneMgr) { printf(&quot;COULDN'T CREATE SCENEMANAGER\n&quot;); exit(3); }
+	if (bWinDebug) printf(&quot;windebug safepoint 1\n&quot;);
+
+
+	mpCamHolderSceneNode =3D mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneN=
ode(&quot;CamHolder&quot;);
+	mpCamPosSceneNode =3D mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode=
(&quot;CamPos&quot;);
+
+	//printf(&quot;\n\n Ogre SceneManager-Init Successful\n\n&quot;);
+
+	//createCamera();
+	{
+		// Create the camera
+		mCamera =3D mSceneMgr-&gt;createCamera(&quot;PlayerCam&quot;);
+
+		// Position it at 500 in Z direction
+		mCamera-&gt;setPosition(Ogre::Vector3(0,0,40));
+		// Look back along -Z
+		//mCamera-&gt;lookAt(Vector3(0,0,0));
+		mCamera-&gt;setNearClipDistance(1);
+		//mCamera-&gt;setPolygonMode(PM_WIREFRAME);
+	}
+	if (bWinDebug) printf(&quot;windebug safepoint 2\n&quot;);
+
+	//printf(&quot;\n\n Ogre Camera-Init Successful\n\n&quot;);
+
+	// TODO : redesign this for lua cam handling
+	mpCamHolderSceneNode-&gt;attachObject(mCamera);
+	// Create one viewport, entire window
+	mViewport =3D mWindow-&gt;addViewport(mCamera);
+	mViewport-&gt;setBackgroundColour(ColourValue(0,0,0));
+
+	if (bWinDebug) printf(&quot;windebug safepoint 3\n&quot;);
+	// Alter the camera aspect ratio to match the viewport
+	mCamera-&gt;setAspectRatio(Real(mViewport-&gt;getActualWidth()) / Real(mViewpor=
t-&gt;getActualHeight()));
+
+
+	if (bWinDebug) printf(&quot;windebug safepoint 4\n&quot;);
+	//printf(&quot;\n\n Ogre Viewport-Init Successful\n\n&quot;);
+
+
+	if (0) { // mbRttHack
+		// render to texture hack, required for hagish's weird gfx-setup only =
=3D)
+		RenderTexture* rttTex =3D mRoot-&gt;getRenderSystem()-&gt;createRenderTexture(=
 &quot;RttTex&quot;, 512, 512, TEX_TYPE_2D, PF_R8G8B8 );
+		Viewport* vp =3D rttTex-&gt;addViewport( mCamera );
+		vp-&gt;setOverlaysEnabled( false );
+		vp-&gt;setClearEveryFrame( true );
+		vp-&gt;setBackgroundColour( ColourValue::Black );
+
+		//printf(&quot;\n\n Ogre RTT-HACK-Init Successful\n\n&quot;);
+	}
+
+	if (bWinDebug) printf(&quot;windebug safepoint 5\n&quot;);
+	// Set default mipmap level (NB some APIs ignore this)
+	TextureManager::getSingleton().setDefaultNumMipmaps(5);
+	Animation::setDefaultInterpolationMode(Animation::IM_SPLINE);
+
+	/*
+	mFiltering =3D TFO_TRILINEAR; mAniso =3D 1;
+	mFiltering =3D TFO_ANISOTROPIC; mAniso =3D 8;
+	mFiltering =3D TFO_BILINEAR; mAniso =3D 1;
+	MaterialManager::getSingleton().setDefaultTextureFiltering(mFiltering);
+	MaterialManager::getSingleton().setDefaultAnisotropy(mAniso);
+	*/
+
+	// TODO : Create any resource listeners (for loading screens)
+
+	// Load resources
+	// loadResources();
+	// Initialise, parse scripts etc
+	if (bWinDebug) printf(&quot;windebug safepoint 6\n&quot;);
+	ResourceGroupManager::getSingleton().initialiseAllResourceGroups();
+
+	if (bWinDebug) printf(&quot;windebug safepoint 7\n&quot;);
+
+	cCompassOverlay::RegisterFactory();
+	cRobRenderableOverlay::RegisterFactory();
+	cColourClipPaneOverlay::RegisterFactory();
+	cColourClipTextOverlay::RegisterFactory();
+	cBorderColourClipPaneOverlay::RegisterFactory();
+	cSortedOverlayContainer::RegisterFactory();
+
+	// sfzgui
+	if (1) {
+		class cSFZGUIEventPump : public cListener { public:
+			cDialogManager* mpDialogMan;
+			cSFZGUIEventPump() {
+				mpDialogMan =3D &amp;cDialogManager::GetSingleton();
+			}
+
+			enum {
+				kEventBinding_InputEvent,
+				kEventBinding_EveryFrame,
+			};
+			virtual	void	Listener_Notify (cListenable* pTarget,const size_t eventco=
de =3D 0,const size_t param =3D 0,const size_t userdata =3D 0) {
+				size_t key,c;
+				switch (userdata) {
+					case kEventBinding_EveryFrame:	// time,mousemovement
+						cDialogManager::GetSingleton().OnEnterFrame(cTimer::miCurFrameNum,cI=
nput::iMouse[0],cInput::iMouse[1]);
+					break;
+					case kEventBinding_InputEvent:
+						key =3D (size_t)(param &amp; 255);
+						c =3D (size_t)((param &gt;&gt; 8) &amp; 255);
+						switch (eventcode) {
+							case cInput::kListenerEvent_KeyPress:
+								mpDialogMan-&gt;InjectKey(key,c,true);
+							break;
+							case cInput::kListenerEvent_KeyRelease:
+								mpDialogMan-&gt;InjectKey(key,c,false);
+							break;
+						}
+					break;
+				}
+			}
+		};
+		cSFZGUIEventPump* pump =3D new cSFZGUIEventPump();
+		cInput::GetSingleton().RegisterListener(pump,(int)cSFZGUIEventPump::kEve=
ntBinding_InputEvent);
+		cTimer::GetSingletonPtr()-&gt;RegisterFrameIntervalListener(pump,0,(int)cSF=
ZGUIEventPump::kEventBinding_EveryFrame);
+	}
+
+	if (bWinDebug) printf(&quot;windebug safepoint 12\n&quot;);
+
+	return true;
+}
+
+void	cOgreWrapper::RenderOneFrame	() {PROFILE
+	if (!mRoot) return;
+
+	// draw one frame
+	mRoot-&gt;renderOneFrame();
+
+	// update input
+	Ogre::WindowEventUtilities::messagePump();
+	if (mKeyboard) mKeyboard-&gt;capture();
+	if (mMouse) mMouse-&gt;capture();
+
+
+	if (0) {
+		// terminate the application after a few seconds, useful for experimenti=
ng with input
+		static int iDeadTime =3D 0;
+		if (iDeadTime =3D=3D 0) iDeadTime =3D cShell::GetTicks() + 1000*20;
+		if (iDeadTime &lt; cShell::GetTicks()) cShell::mbAlive =3D false;
+	}
+
+	if(1) {
+		// read out some statistics
+		const RenderTarget::FrameStats&amp; stats =3D mWindow-&gt;getStatistics();
+		mfLastFPS =3D stats.lastFPS;
+		mfAvgFPS =3D stats.avgFPS;
+		mfBestFPS =3D stats.bestFPS;
+		mfWorstFPS =3D stats.worstFPS;
+		miBestFrameTime =3D stats.bestFrameTime;
+		miWorstFrameTime =3D stats.worstFrameTime;
+		miTriangleCount =3D stats.triangleCount;
+		miBatchCount =3D stats.batchCount;
+	}
+}
+
+void	cOgreWrapper::DeInit		() {PROFILE
+	if (mRoot) delete mRoot; mRoot =3D 0;
+}
+
+void	cOgreWrapper::SetSkybox	(const char* szMatName,const bool bFlip) { PR=
OFILE
+	// setSkyBox (bool enable, const String &amp;materialName, Real distance=3D50=
00, bool drawFirst=3Dtrue, const Quaternion &amp;orientation=3DQuaternion::IDEN=
TITY, const String &amp;groupName=3DResourceGroupManager::DEFAULT_RESOURCE_GROU=
P_NAME)
+ 	if (szMatName) {
+		if (bFlip)
+				mSceneMgr-&gt;setSkyBox(true,szMatName,1000,true,Quaternion(Degree(90),Og=
re::Vector3(1,0,0)));
+		else	mSceneMgr-&gt;setSkyBox(true,szMatName);
+	} else {
+		mSceneMgr-&gt;setSkyBox(false,&quot;&quot;);
+	}
+}
+
+Ogre::SceneManager*	cOgreWrapper::GetSceneManager	(const char* szSceneMgrN=
ame) {
+	return mRoot-&gt;getSceneManager(szSceneMgrName);
+}
+
+void	cOgreWrapper::AttachCamera	(SceneNode* pSceneNode) {PROFILE
+	if (pSceneNode)
+			pSceneNode-&gt;attachObject(mCamera);
+	else	mSceneMgr-&gt;getRootSceneNode()-&gt;attachObject(mCamera);
+}
+
+void	cOgreWrapper::SetCameraPos		(const Ogre::Vector3 vPos) {PROFILE
+	mCamera-&gt;setPosition(vPos);
+}
+
+void	cOgreWrapper::SetCameraRot		(const Quaternion qRot) {PROFILE
+	mCamera-&gt;setOrientation(qRot);
+}
+
+void	cOgreWrapper::CameraLookAt		(const Ogre::Vector3 vPos) { PROFILE
+	mCamera-&gt;lookAt(vPos);
+}
+
+/// highres screenshot from wiki
+/// <A HREF="http://www.ogre3d.org/wiki/index.php/High_resolution_screenshots">http://www.ogre3d.org/wiki/index.php/High_resolution_screenshots</A>
+void cOgreWrapper::TakeGridScreenshot(/*Ogre::RenderWindow* mWindow, Ogre:=
:<i>Camera* mCamera, */const int&amp; pGridSize, const Ogre::String&amp; pFileName, co=
</I>nst Ogre::String&amp; pFileExtention, const bool&amp; pStitchGridImages)
+{
+  /* Parameters:
+   *  mWindow:    Pointer to the render window.  This could be &quot;mWindow&quot; f=
rom the ExampleApplication,
+   *              the window automatically created obtained when calling
+   *              Ogre::Root::getSingletonPtr()-&gt;initialise(false) and ret=
rieved by calling
+   *              &quot;Ogre::Root::getSingletonPtr()-&gt;getAutoCreatedWindow()&quot;,=
 or the manually created
+   *              window from calling &quot;mRoot-&gt;createRenderWindow()&quot;.
+   *  mCamera:      Pointer to the camera &quot;looking at&quot; the scene of intere=
st
+   *  pGridSize:      The magnification factor.  A 2 will create a 2x2 gri=
d, doubling the size of the
+                screenshot.  A 3 will create a 3x3 grid, tripling the size=
 of the screenshot.
+   *  pFileName:      The filename to generate, without an extention.  To =
generate &quot;MyScreenshot.png&quot; this
+   *              parameter would contain the value &quot;MyScreenshot&quot;.
+   *  pFileExtention:    The extention of the screenshot file name, hence =
the type of graphics file to generate.
+   *              To generate &quot;MyScreenshot.pnh&quot; this parameter would cont=
ain &quot;.png&quot;.
+   *  pStitchGridImages:  Determines whether the grid screenshots are (tru=
e) automatically stitched into a single
+   *              image (and discarded) or whether they should (false) rem=
ain in their unstitched
+   *              form.  In that case they are sequentially numbered from =
0 to
+   *              pGridSize * pGridSize - 1 (if pGridSize is 3 then from 0=
 to 8).
+   *
+  */
+	bool overlaysEnabled =3D mViewport-&gt;getOverlaysEnabled();
+	mViewport-&gt;setOverlaysEnabled(false);
+
+  Ogre::String gridFilename;
+
+  if(pGridSize &lt;=3D 1)
+  {
+    // Simple case where the contents of the screen are taken directly
+    // Also used when an invalid value is passed within pGridSize (zero or=
 negative grid size)
+    gridFilename =3D pFileName + pFileExtention;
+
+    mWindow-&gt;writeContentsToFile(gridFilename);
+  }
+  else
+  {
+    // Generate a grid of screenshots
+    mCamera-&gt;setCustomProjectionMatrix(false); // reset projection matrix
+    Ogre::Matrix4 standard =3D mCamera-&gt;getProjectionMatrix();
+    double nearDist =3D mCamera-&gt;getNearClipDistance();
+    double nearWidth =3D (mCamera-&gt;getWorldSpaceCorners()[0] - mCamera-&gt;ge=
tWorldSpaceCorners()[1]).length();
+    double nearHeight =3D (mCamera-&gt;getWorldSpaceCorners()[1] - mCamera-&gt;g=
etWorldSpaceCorners()[2]).length();
+    Ogre::Image sourceImage;
+    Ogre::uchar* stitchedImageData;
+
+    // Process each grid
+    for (int nbScreenshots =3D 0; nbScreenshots &lt; pGridSize * pGridSize; n=
bScreenshots++)
+    {
+      // Use asymmetrical perspective projection. For more explanations ch=
eck out:
+      // <A HREF="http://www.cs.kuleuven.ac.be/cwis/research/graphics/INFOTEC/viewi=">http://www.cs.kuleuven.ac.be/cwis/research/graphics/INFOTEC/viewi=</A>
ng-in-3d/node8.html
+      int y =3D nbScreenshots / pGridSize;
+      int x =3D nbScreenshots - y * pGridSize;
+      Ogre::Matrix4 shearing(
+        1, 0,(x - (pGridSize - 1) * 0.5) * nearWidth / nearDist, 0,
+        0, 1, -(y - (pGridSize - 1) * 0.5) * nearHeight / nearDist, 0,
+        0, 0, 1, 0,
+        0, 0, 0, 1);
+      Ogre::Matrix4 scale(
+        pGridSize, 0, 0, 0,
+        0, pGridSize, 0, 0,
+        0, 0, 1, 0,
+        0, 0, 0, 1);
+      mCamera-&gt;setCustomProjectionMatrix(true, standard * shearing * scale=
);
+      Ogre::Root::getSingletonPtr()-&gt;renderOneFrame();
+      gridFilename =3D pFileName + Ogre::StringConverter::toString(nbScree=
nshots) + pFileExtention;
+
+
+      // Screenshot of the current grid
+      mWindow-&gt;writeContentsToFile(gridFilename);
+
+      if(pStitchGridImages)
+      {
+        // Automatically stitch the grid screenshots
+        sourceImage.load(gridFilename, &quot;General&quot;); // Assumes that the cur=
rent directory is within the &quot;General&quot; resource group
+        int sourceWidth =3D (int) sourceImage.getWidth();
+        int sourceHeight =3D (int) sourceImage.getHeight();
+        Ogre::ColourValue colourValue;
+        int stitchedX, stitchedY, stitchedIndex;
+
+        // Allocate memory for the stitched image when processing the scre=
enshot of the first grid
+        if(nbScreenshots =3D=3D 0)
+          stitchedImageData =3D new Ogre::uchar[(sourceImage.getWidth() * =
pGridSize) * (sourceImage.getHeight() * pGridSize) * 3]; // 3 colors per pi=
xel
+
+        // Copy each pixel within the grid screenshot to the proper positi=
on within the stitched image
+        for(int rawY =3D 0; rawY &lt; sourceHeight; rawY++)
+        {
+          for(int rawX =3D 0; rawX &lt; sourceWidth; rawX++)
+          {
+            colourValue =3D sourceImage.getColourAt(rawX, rawY, 0);
+            stitchedX =3D x * sourceWidth + rawX;
+            stitchedY =3D y * sourceHeight + rawY;
+            stitchedIndex =3D stitchedY * sourceWidth * pGridSize + stitch=
edX;
+            Ogre::PixelUtil::packColour(colourValue,
+                          Ogre::PF_R8G8B8,
+                          (void*) &amp;stitchedImageData[stitchedIndex * 3]);
+          }
+        }
+        // The screenshot of the grid is no longer needed
+        remove(gridFilename.c_str());
+      }
+    }
+    mCamera-&gt;setCustomProjectionMatrix(false); // reset projection matrix
+
+    if(pStitchGridImages)
+    {
+      // Save the stitched image to a file
+      Ogre::Image targetImage;
+      targetImage.loadDynamicImage(stitchedImageData,
+                    sourceImage.getWidth() * pGridSize,
+                    sourceImage.getHeight() * pGridSize,
+                    1, // depth
+                    Ogre::PF_R8G8B8,
+                    false);
+      targetImage.save(pFileName + pFileExtention);
+      delete[] stitchedImageData;
+    }
+  }
+	mViewport-&gt;setOverlaysEnabled(overlaysEnabled);
+}
+
+void cOgreWrapper::TakeScreenshot (const char* szDirPath) {PROFILE
+ char mybuf[256];
+ time_t mytime;
+ time(&amp;mytime);
+ strftime(mybuf,255,&quot;%Y%m%d%H%M%S&quot;,localtime(&amp;mytime));
+ mWindow-&gt;writeContentsToFile( strprintf( &quot;%siris_%s_%03d.png&quot;, szDirPath,=
mybuf,cShell::GetTicks() % 1000 ) );
+} =

+
+std::string		cOgreWrapper::GetUniqueName () {PROFILE
+	static int iLastName =3D 0;
+	return strprintf(&quot;n%04d&quot;,++iLastName);
+}
+
+/// avoid using OverlayManager::getSingleton().GetViewportHeight() as it i=
s one frame late
+int		cOgreWrapper::GetViewportHeight	() { return mViewport-&gt;getActualHeigh=
t(); }
+int		cOgreWrapper::GetViewportWidth	() { return mViewport-&gt;getActualWidth(=
); }
+
+bool	cOgreWrapper::RayAABBQuery	(const Ogre::Vector3&amp; vRayPos,const Ogre::=
Vector3&amp; vRayDir,const Ogre::AxisAlignedBox &amp;aabb,float* pfHitDist) { PROFI=
LE
+	static Ogre::Vector3 mlVertices[8];
+	static Ogre::Vector3 d,p000,p111,p100,p010,p001,p011,p101,p110;
+	p000 =3D aabb.getMinimum();
+	p111 =3D aabb.getMaximum();
+	d =3D p111-p000;
+	p100 =3D p000 + Ogre::Vector3(d.x,0,0);
+	p010 =3D p000 + Ogre::Vector3(0,d.y,0);
+	p001 =3D p000 + Ogre::Vector3(0,0,d.z);
+	p011 =3D p000 + Ogre::Vector3(0,d.y,d.z);
+	p101 =3D p000 + Ogre::Vector3(d.x,0,d.z);
+	p110 =3D p000 + Ogre::Vector3(d.x,d.y,0);
+
+	static int mlIndices[] =3D {
+		0,1,2, 3,1,2,	4,5,6, 7,5,6, // front, back
+		0,1,4, 5,1,4,	2,3,6, 7,3,6, // top, bottom
+		0,2,4, 6,2,4,	1,3,5, 7,3,5, // left, right
+		};
+	mlVertices[0] =3D p000;	mlVertices[1] =3D p100; // front
+	mlVertices[2] =3D p010;	mlVertices[3] =3D p110;
+
+	mlVertices[4] =3D p001;	mlVertices[5] =3D p101; // back
+	mlVertices[6] =3D p011;	mlVertices[7] =3D p111;
+
+	bool bHit =3D false;
+	float myHitDist;
+
+	for (int i=3D0;i&lt;6*6;i+=3D3) {
+		if (IntersectRayTriangle(vRayPos,vRayDir,
+			mlVertices[mlIndices[i+0]],
+			mlVertices[mlIndices[i+1]],
+			mlVertices[mlIndices[i+2]],&amp;myHitDist)) {
+			if (!bHit || myHitDist &lt; *pfHitDist) *pfHitDist =3D myHitDist;
+			bHit =3D true;
+		}
+	}
+	return bHit;
+}
+
+/// returns true if the ray intersects the entities triangles
+/// the resulting distance in the case of a hit is stored into pfHitDist
+/// see also OgreOpCode for more complex collision/intersection detection
+bool	cOgreWrapper::RayEntityQuery	(const Ogre::Vector3&amp; vRayPos,const Ogre=
::<i>Vector3&amp; vRayDir,Ogre::Entity* pEntity,const Ogre::Vector3&amp; vPos,const Og=
</I>re::Quaternion&amp; qRot,const Ogre::Vector3&amp; vScale,float* pfHitDist) { PROFILE
+	if (!pEntity) return false;
+	if (!pEntity-&gt;isVisible()) return false;
+
+	// get origin &amp; dir in coordinates local to the entity
+	MeshShape* myshape =3D MeshShape::GetMeshShape(pEntity);
+	if (!myshape) return false;
+	Ogre::Quaternion invrot =3D qRot.Inverse();
+	return myshape-&gt;RayIntersect((invrot*(vRayPos - vPos))/vScale,(invrot * v=
RayDir)/ vScale,pfHitDist);
+}
+
+/// extracs pos &amp; rot from scenenode, DOESNT WORK FOR entities in static g=
eometry (no scenenode)
+bool	cOgreWrapper::RayEntityQuery	(const Ogre::Vector3&amp; vRayPos,const Ogre=
::<i>Vector3&amp; vRayDir,Ogre::Entity* pEntity,float* pfHitDist) { PROFILE
</I>+	SceneNode* scenenode =3D pEntity ? pEntity-&gt;getParentSceneNode() : 0;
+	if (!scenenode) return false; // TODO : tagpoint (like knife in hand) att=
achment currently not supported...
+	return RayEntityQuery(vRayPos,vRayDir,pEntity,scenenode-&gt;_getDerivedPosit=
ion(),scenenode-&gt;_getDerivedOrientation(),scenenode-&gt;_getDerivedScale(),pfH=
itDist);
+}
+
+/// returns true if in front of cam, and fills x,y with clamped screencoor=
ds in [-1;1]
+/// and fills cx,cy with projected size on screen in [0;1]
+// cam-&gt;getProjectionMatrix() is cached inside ogre
+bool	cOgreWrapper::ProjectPos	(const Ogre::Vector3&amp; pos,Ogre::Real&amp; x,Ogre=
::<i>Real&amp; y) { PROFILE
</I>+	Camera* cam =3D mCamera;
+	Ogre::Vector3 eyeSpacePos =3D cam-&gt;getViewMatrix(true) * pos;
+	// z &lt; 0 means in front of cam
+	if (eyeSpacePos.z &lt; 0) {
+		Ogre::Vector3 screenSpacePos =3D cam-&gt;getProjectionMatrix() * eyeSpacePo=
s;
+		x =3D screenSpacePos.x;
+		y =3D screenSpacePos.y;
+		bool bIsOnSreen =3D true;
+		if (x &lt; -1.0) { x =3D -1.0; bIsOnSreen =3D false; } if (x &gt; 1.0) { x =3D=
 1.0; bIsOnSreen =3D false; }
+		if (y &lt; -1.0) { y =3D -1.0; bIsOnSreen =3D false; } if (y &gt; 1.0) { y =3D=
 1.0; bIsOnSreen =3D false; }
+		return bIsOnSreen;
+	} else {
+		x =3D (-eyeSpacePos.x &gt; 0) ? -1 : 1;
+		y =3D (-eyeSpacePos.y &gt; 0) ? -1 : 1;
+		return false;
+	}
+}
+
+/// returns true if in front of cam, and fills x,y with clamped screencoor=
ds in [-1;1]
+/// and fills cx,cy with projected size on screen in [0;1]
+// cam-&gt;getProjectionMatrix() is cached inside ogre
+bool	cOgreWrapper::ProjectSizeAndPos	(const Ogre::Vector3&amp; pos,Ogre::Real&amp;=
 x,Ogre::Real&amp; y,const Ogre::Real rad,Ogre::Real&amp; cx,Ogre::Real&amp; cy) { PROF=
ILE
+	Camera* cam =3D mCamera;
+	Ogre::Vector3 eyeSpacePos =3D cam-&gt;getViewMatrix(true) * pos;
+	// z &lt; 0 means in front of cam
+	if (eyeSpacePos.z &lt; 0) {
+		Ogre::Vector3 screenSpacePos =3D cam-&gt;getProjectionMatrix() * eyeSpacePo=
s;
+		x =3D screenSpacePos.x;
+		y =3D screenSpacePos.y;
+		bool bIsOnSreen =3D true;
+		if (x &lt; -1.0) { x =3D -1.0; bIsOnSreen =3D false; } if (x &gt; 1.0) { x =3D=
 1.0; bIsOnSreen =3D false; }
+		if (y &lt; -1.0) { y =3D -1.0; bIsOnSreen =3D false; } if (y &gt; 1.0) { y =3D=
 1.0; bIsOnSreen =3D false; }
+		if (bIsOnSreen) {
+			Ogre::Vector3 spheresize(rad, rad, eyeSpacePos.z);
+			spheresize =3D cam-&gt;getProjectionMatrix() * spheresize;
+			cx =3D spheresize.x;
+			cy =3D spheresize.y;
+		} else {
+			cx =3D 0;
+			cy =3D 0;
+		}
+		return bIsOnSreen;
+	} else {
+		cx =3D 0;
+		cy =3D 0;
+		x =3D (-eyeSpacePos.x &gt; 0) ? -1 : 1;
+		y =3D (-eyeSpacePos.y &gt; 0) ? -1 : 1;
+		return false;
+	}
+}

Modified: branches/knut/src/scripting.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/scripting.cpp (original)
+++ branches/knut/src/scripting.cpp Wed Aug  1 20:57:14 2007
@@ -24,7 +24,8 @@
 #include &quot;camera.h&quot;
 #include &quot;viewport.h&quot;
 #include &quot;rendertexture.h&quot;
-#include &quot;sound.h&quot;
+#include &quot;sound.h&quot;
+#include &quot;meshshape.h&quot;
 #include &quot;terrain.h&quot;
 #include &quot;radar.h&quot;
 #include &lt;Ogre.h&gt;
@@ -41,8 +42,8 @@
 #ifdef PROFILE_LUACALLCOUNT
 std::map&lt;const char*,int&gt; gPROFILE_LUACALLCOUNT;
 struct cPROFILE_LUACALLCOUNTSetCmp {
-  inline bool operator() (const std::pair&lt;const char*,int&gt;&amp; x,const  std::=
pair&lt;const char*,int&gt;&amp; y) const { =

-	return x.second &gt; y.second; =

+  inline bool operator() (const std::pair&lt;const char*,int&gt;&amp; x,const  std::=
pair&lt;const char*,int&gt;&amp; y) const {
+	return x.second &gt; y.second;
   }
 };
 #endif
@@ -59,7 +60,7 @@
 	#include &quot;lualib.h&quot;
 }
 =

-void	DisplayNotice			(const char* szMsg); ///&lt; defined in main.cpp, OS-spe=
cific
+void	DisplayNotice			(const char* szMsg); ///&lt; defined in main.cpp, OS-spe=
cific
 void	DisplayErrorMessage		(const char* szMsg); ///&lt; defined in main.cpp, O=
S-specific
 void	Material_LuaRegister	(void *L);
 void	Granny_LuaRegister		(void *L);
@@ -82,7 +83,7 @@
 		std::string sMyStackTrace;
 		cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;_TRACEBACK&quot;,&quot;&gt;s&quot;,&amp;sMyStackTrace);
 		fprintf(f,&quot;%s\n&quot;,sMyStackTrace.c_str());
-		=

+
 		fclose(f);
 	}
 }
@@ -109,15 +110,15 @@
 /// called from lua : string keyname
 static int l_GetNamedKey (lua_State *L) { PROFILE
 	const char *keyname =3D luaL_checkstring(L, 1);
-	lua_pushnumber(L,cInput::GetSingleton().GetNamedKey(keyname));  // push r=
esult =

-	return 1;  // number of results =

+	lua_pushnumber(L,cInput::GetSingleton().GetNamedKey(keyname));  // push r=
esult
+	return 1;  // number of results
 }
 =

 /// called from lua : int keycode
 static int l_GetKeyName (lua_State *L) { PROFILE
 	int keycode =3D luaL_checkint(L, 1);
-	lua_pushstring(L,cInput::GetSingleton().GetKeyName(keycode));  // push re=
sult =

-	return 1;  // number of results =

+	lua_pushstring(L,cInput::GetSingleton().GetKeyName(keycode));  // push re=
sult
+	return 1;  // number of results
 }
 =

 /// terminates the application
@@ -142,7 +143,7 @@
 	lua_pushboolean(L,cShell::mbAlive);
 	return 1;
 }
-	=

+
 /// called from lua : no params, returns mousex,mousey,4xmousewheel info...
 static int l_PollInput (lua_State *L) { PROFILE
 	lua_pushnumber(L,cInput::iMouse[0]);
@@ -157,14 +158,14 @@
 =

 static int l_ProfileDumpCallCount (lua_State *L) { PROFILE
 	ProfileDumpCallCount();
-	=

+
 	#ifdef PROFILE_LUACALLCOUNT
 	printf(&quot;LuaCallCounts:\n\n&quot;);
-	=

+
 	std::multiset&lt;std::pair&lt;const char*,int&gt;,cPROFILE_LUACALLCOUNTSetCmp&gt; myC=
allCountProfileSet;
 	typedef std::multiset&lt;std::pair&lt;const char*,int&gt;,cPROFILE_LUACALLCOUNTSet=
Cmp&gt;::iterator tLuaCallCountProfileSetItor;
 	{ for (std::map&lt;const char*,int&gt;::iterator itor=3DgPROFILE_LUACALLCOUNT.b=
egin();itor !=3D gPROFILE_LUACALLCOUNT.end();++itor)
-		myCallCountProfileSet.insert(std::make_pair((*itor).first,(*itor).second=
)); =

+		myCallCountProfileSet.insert(std::make_pair((*itor).first,(*itor).second=
));
 	}
 	int i=3D0;
 	for (tLuaCallCountProfileSetItor itor=3DmyCallCountProfileSet.begin();ito=
r !=3D myCallCountProfileSet.end();++itor) {
@@ -210,7 +211,7 @@
 	if (ar.currentline &gt; 0)
 	  lua_pushfstring(L, &quot;%d:&quot;, ar.currentline);
 	switch (*ar.namewhat) {
-	  case 'g':  /* global */ =

+	  case 'g':  /* global */
 	  case 'l':  /* local */
 	  case 'f':  /* field */
 	  case 'm':  /* method */
@@ -252,16 +253,35 @@
 =

 /// void OgreAddCompositor(compositor script name)
 static int l_OgreAddCompositor (lua_State *L) { PROFILE
-	const char *name =3D luaL_checkstring(L,1);
-	Ogre::CompositorManager::getSingleton().addCompositor(cOgreWrapper::GetSi=
ngleton().mViewport, name);
-	return 0;
+	Ogre::Viewport* pViewport =3D cLuaBind&lt;cViewport&gt;::checkudata_alive(L,1)-=
&gt;<i>mpViewport;
</I>+//	printf(&quot;pViewport=3D%08x\n&quot;,pViewport);
+	if (pViewport)
+	{
+		const char *name =3D luaL_checkstring(L,2);
+		Ogre::CompositorManager::getSingleton().addCompositor(pViewport, name);
+		Ogre::CompositorManager::getSingleton().setCompositorEnabled(pViewport, =
name, true);
+	}
+	else
+	{
+		return false;
+	}
+	return true;
 }
 =

 /// void OgreRemoveCompositor(compositor script name)
 static int l_OgreRemoveCompositor (lua_State *L) { PROFILE
-	const char *name =3D luaL_checkstring(L,1);
-	Ogre::CompositorManager::getSingleton().removeCompositor(cOgreWrapper::Ge=
tSingleton().mViewport, name);
-	return 0;
+	Ogre::Viewport* pViewport =3D cLuaBind&lt;cViewport&gt;::checkudata_alive(L,1)-=
&gt;<i>mpViewport;
</I>+	if (pViewport)
+	{
+		const char *name =3D luaL_checkstring(L,2);
+		Ogre::CompositorManager::getSingleton().setCompositorEnabled(pViewport, =
name, false);
+		Ogre::CompositorManager::getSingleton().removeCompositor(pViewport, name=
);
+	}
+	else
+	{
+		return false;
+	}
+	return true;
 }
 =

 /// int =3D OgreMemoryUsage(part)
@@ -270,7 +290,7 @@
 static int l_OgreMemoryUsage (lua_State *L) { PROFILE
 	std::string part(luaL_checkstring(L,1));
 	size_t mem =3D 0;
-	=

+
 #ifdef OGRE_VERSION_SUFFIX
 	if(part.find(&quot;compositor&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=
=3D std::string::npos)mem +=3D Ogre::CompositorManager::getSingleton().getM=
emoryUsage();
 	if(part.find(&quot;font&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D std:=
:<i>string::npos)mem +=3D Ogre::FontManager::getSingleton().getMemoryUsage();
</I>@@ -281,7 +301,7 @@
 	if(part.find(&quot;skeleton&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D =
std::string::npos)mem +=3D Ogre::SkeletonManager::getSingleton().getMemoryU=
sage();
 	if(part.find(&quot;texture&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D s=
td::string::npos)mem +=3D Ogre::TextureManager::getSingleton().getMemoryUsa=
ge();
 #endif
-	=

+
 	lua_pushnumber(L, mem);
 	return 1;
 }
@@ -290,14 +310,14 @@
 static int l_OgreMeshAvailable (lua_State *L) { PROFILE
 	const char *name =3D luaL_checkstring(L,1);
 	bool ret;
-	=

+
 	try {
 		Ogre::MeshManager::getSingleton().load(name,Ogre::ResourceGroupManager::=
DEFAULT_RESOURCE_GROUP_NAME);
 		ret =3D true;
 	} catch (...) {
 			ret =3D false;
 	}
-	=

+
 	lua_pushboolean(L, ret);
 	return 1;
 }
@@ -317,20 +337,34 @@
 	return 1;
 }
 =

+/// see also OgreMaterialAvailable below
+/// bool =3D OgreMaterialNameKnown(ressourcename)
+/// returns false if name is empty string or nil
+static int l_OgreMaterialNameKnown (lua_State *L) { PROFILE
+	std::string sMatName =3D (lua_gettop(L) &gt;=3D 1 &amp;&amp; !lua_isnil(L,1)) ? luaL=
_checkstring(L,1) : &quot;&quot;;
+	if (sMatName.size() &gt; 0) {
+		Ogre::MaterialPtr pMaterial =3D Ogre::MaterialManager::getSingleton().ge=
tByName(sMatName.c_str());
+		lua_pushboolean(L,!pMaterial.isNull());
+	} else {
+		lua_pushboolean(L,false);
+	}
+	return 1;
+}
+
 /// bool =3D OgreMaterialAvailable(ressourcename)
 static int l_OgreMaterialAvailable (lua_State *L) { PROFILE
 	assert(0 &amp;&amp; &quot;DON'T USE ME, ALWAYS RETURNS TRUE&quot;); =

 	// TODO, this code does not work, use l_OgreMaterialNameKnown  above
 	const char *name =3D luaL_checkstring(L,1);
 	bool ret;
-	=

+
 	try {
 		Ogre::MaterialManager::getSingleton().load(name,Ogre::ResourceGroupManag=
er::DEFAULT_RESOURCE_GROUP_NAME);
 		ret =3D true;
 	} catch (...) {
 			ret =3D false;
 	}
-	=

+
 	lua_pushboolean(L, ret);
 	return 1;
 }
@@ -339,14 +373,14 @@
 static int l_OgreTextureAvailable (lua_State *L) { PROFILE
 	const char *name =3D luaL_checkstring(L,1);
 	bool ret;
-	=

+
 	try {
 		Ogre::TextureManager::getSingleton().load(name,Ogre::ResourceGroupManage=
r::DEFAULT_RESOURCE_GROUP_NAME);
 		ret =3D true;
 	} catch (...) {
 			ret =3D false;
 	}
-	=

+
 	lua_pushboolean(L, ret);
 	return 1;
 }
@@ -354,104 +388,109 @@
 /// r,g,b =3D Uo16Color2Rgb(color)
 static int l_Uo16Color2Rgb (lua_State *L) { PROFILE
 	unsigned short color =3D luaL_checkint(L,1);
-	=

+
 	float r =3D float((color &gt;&gt; 10) &amp; 0x1F)/float(0x1f);
 	float g =3D float((color &gt;&gt;  5) &amp; 0x1F)/float(0x1f);
 	float b =3D float((color &gt;&gt;  0) &amp; 0x1F)/float(0x1f);
-				=

+
 	lua_pushnumber(L, r);
 	lua_pushnumber(L, g);
 	lua_pushnumber(L, b);
 	return 3;
 }
-
-/// CreateGrannyHuedTexture(GrannyTextureHook(texturepath),GrannyTextureHo=
ok(texturepath),gHueLoader,hue)
-static int l_CreateGrannyHuedTexture (lua_State *L) { PROFILE
-	std::string sTexturePath	=3D luaL_checkstring(L,1);
-	std::string sMaskPath		=3D luaL_checkstring(L,2);
-	cHueLoader *hueLoader 		=3D cLuaBind&lt;cHueLoader&gt;::checkudata(L,3);
-	int iHue					=3D luaL_checkint(L,4);
-	=

-	if (iHue =3D=3D 0 || !hueLoader) {
-		lua_pushstring(L,sTexturePath.c_str());
-		return 1;
-	}
-	=

-	// load image
-	Ogre::Image myImage;
-	myImage.load(sTexturePath,Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GR=
OUP_NAME);
-	=

-	// get image infos
-	Ogre::PixelFormat myFormat =3D myImage.getFormat();
-	unsigned int size =3D myImage.getSize();
-	unsigned int w =3D myImage.getWidth();
-	unsigned int h =3D myImage.getHeight();
-	unsigned int rowspan =3D myImage.getRowSpan();
-	unsigned int pixelsize =3D Ogre::PixelUtil::getNumElemBytes(myFormat);
-	//Ogre::uchar* dst =3D new Ogre::uchar[size];
-	Ogre::uchar* src =3D myImage.getData();
-	//Ogre::uchar* dst_start =3D dst;
-	Ogre::uchar* src_start =3D src;
-	uint8 cr,cg,cb,ca1,ca2;
-	short col;
-	=

-	// debug info
-	//printf(&quot;image size=3D%d w=3D%d h=3D%d d=3D%d f=3D%d bpp=3D%d rowspan=3D=
%d bIsNonZero2=3D%d\n&quot;,size,w,h,
-	//	myImage.getDepth(),myImage.getNumFaces(),myImage.getBPP(),rowspan,bIsN=
onZero2?1:0);
-	=

-	// hue filter
-	cHueFilter Filter;
-	short* ColorTable =3D hueLoader-&gt;GetHue( iHue-1 )-&gt;GetColors();
-	=

-	// colorize the pixels
-	for(unsigned int y =3D 0; y &lt; h; y++){
+
+/// CreateGrannyHuedTexture(GrannyTextureHook(texturepath),GrannyTextureHo=
ok(texturepath),gHueLoader,hue)
+static int l_CreateGrannyHuedTexture (lua_State *L) { PROFILE
+	std::string sTexturePath	=3D luaL_checkstring(L,1);
+	std::string sMaskPath		=3D luaL_checkstring(L,2);
+	cHueLoader *hueLoader 		=3D cLuaBind&lt;cHueLoader&gt;::checkudata(L,3);
+	int iHue					=3D luaL_checkint(L,4);
+
+	if (iHue =3D=3D 0 || !hueLoader) {
+		lua_pushstring(L,sTexturePath.c_str());
+		return 1;
+	}
+
+	// load image
+	Ogre::Image myImage;
+	myImage.load(sTexturePath,Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GR=
OUP_NAME);
+
+	// get image infos
+	Ogre::PixelFormat myFormat =3D myImage.getFormat();
+	unsigned int size =3D myImage.getSize();
+	unsigned int w =3D myImage.getWidth();
+	unsigned int h =3D myImage.getHeight();
+	unsigned int rowspan =3D myImage.getRowSpan();
+	unsigned int pixelsize =3D Ogre::PixelUtil::getNumElemBytes(myFormat);
+	//Ogre::uchar* dst =3D new Ogre::uchar[size];
+	Ogre::uchar* src =3D myImage.getData();
+	//Ogre::uchar* dst_start =3D dst;
+	Ogre::uchar* src_start =3D src;
+	uint8 cr,cg,cb,ca1,ca2;
+	short col;
+
+	// debug info
+	//printf(&quot;image size=3D%d w=3D%d h=3D%d d=3D%d f=3D%d bpp=3D%d rowspan=3D=
%d bIsNonZero2=3D%d\n&quot;,size,w,h,
+	//	myImage.getDepth(),myImage.getNumFaces(),myImage.getBPP(),rowspan,bIsN=
onZero2?1:0);
+
+	// hue filter
+	cHueFilter Filter;
+	short* ColorTable =3D hueLoader-&gt;GetHue( iHue-1 )-&gt;GetColors();
+
+	// colorize the pixels
+	for(unsigned int y =3D 0; y &lt; h; y++){
 		for(unsigned int x =3D 0; x &lt; w; x++) {
-			// read out pixel in src graphic
-			Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca1,myFormat,src);
-			Ogre::PixelUtil::packColour(cr,cg,cb,ca1,Ogre::PF_A1R5G5B5,&amp;col);
-			// and hue the pixel
-			col =3D Filter( col, ColorTable );
-			// TODO ! respect mask instead of hueing the complete texture
-			// and store it in destination (ignoring the new alpha)
-			Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca2,Ogre::PF_A1R5G5B5,&amp;col);
-			Ogre::PixelUtil::packColour(cr,cg,cb,ca1,myFormat,src);
-			src +=3D pixelsize;
-			//dst +=3D pixelsize;
-		}
-		src +=3D rowspan - w*pixelsize;
-	}
-	=

-	// and make a texture
-	std::string newtextname =3D cOgreWrapper::GetSingleton().GetUniqueName();
-	//Ogre::DataStreamPtr texstream(new Ogre::MemoryDataStream(dst_start, siz=
e));
-	//Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().loadR=
awData(newtextname,
-	//	Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,texstream, w,h=
,myFormat);
-	=

-	Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().loadIma=
ge(newtextname,
-		Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,myImage,Ogre::TE=
X_TYPE_2D,-1,1.0f,true,Ogre::PF_UNKNOWN);
-	=

-	// free memory
-	//delete [] dst_start;
-
-	lua_pushstring(L,newtextname.c_str());
-	return 1;
-}
-	=

+			// read out pixel in src graphic
+			Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca1,myFormat,src);
+			Ogre::PixelUtil::packColour(cr,cg,cb,ca1,Ogre::PF_A1R5G5B5,&amp;col);
+			// and hue the pixel
+			col =3D Filter( col, ColorTable );
+			// TODO ! respect mask instead of hueing the complete texture
+			// and store it in destination (ignoring the new alpha)
+			Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca2,Ogre::PF_A1R5G5B5,&amp;col);
+			Ogre::PixelUtil::packColour(cr,cg,cb,ca1,myFormat,src);
+			src +=3D pixelsize;
+			//dst +=3D pixelsize;
+		}
+		src +=3D rowspan - w*pixelsize;
+	}
+
+	// and make a texture
+	std::string newtextname =3D cOgreWrapper::GetSingleton().GetUniqueName();
+	//Ogre::DataStreamPtr texstream(new Ogre::MemoryDataStream(dst_start, siz=
e));
+	//Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().loadR=
awData(newtextname,
+	//	Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,texstream, w,h=
,myFormat);
+
+	Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().loadIma=
ge(newtextname,
+		Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,myImage,Ogre::TE=
X_TYPE_2D,-1,1.0f,true,Ogre::PF_UNKNOWN);
+
+	// free memory
+	//delete [] dst_start;
+
+	lua_pushstring(L,newtextname.c_str());
+	return 1;
+}
+
 /// void HueMesh(meshname, hueloader, hue)
 static int l_HueMesh (lua_State *L) { PROFILE
-	const char *meshname =3D luaL_checkstring(L,1);
+	std::string sMeshName =3D luaL_checkstring(L,1);
+	const char *meshname =3D sMeshName.c_str();
 	cHueLoader *hueLoader =3D cLuaBind&lt;cHueLoader&gt;::checkudata(L,2);
 	int hue =3D luaL_checkint(L,3);
 =

 	//printf(&quot;HueMesh(%s,%i,%i)\n&quot;,meshname,hueLoader,hue);
 	if(hueLoader &amp;&amp; hue &amp;&amp; meshname){
 		try	{
-			cHueFilter Filter;
-			short* ColorTable =3D hueLoader-&gt;GetHue( hue-1 )-&gt;GetColors();
-		=

+			cHueFilter Filter;
+			cHue* pMyHue =3D hueLoader-&gt;GetHue( hue-1 );
+			if (!pMyHue) return 0;
+			short* ColorTable =3D pMyHue-&gt;GetColors();
+			if (!ColorTable) return 0;
+
 			// data seem ok, so read out the mesh
 			Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().load(meshname,=
Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
-			=

+			if (mesh.isNull()) return 0;
+
 			//printf(&quot;mesh=3D%s\n&quot;,mesh-&gt;getName().c_str());
 =

 			// and iterate over all submeshes
@@ -459,12 +498,13 @@
 			while(sit.hasMoreElements()){
 				Ogre::SubMesh *submesh =3D sit.getNext();
 				//printf(&quot;submesh=3D%i\n&quot;,submesh);
-				=

+
+				if(!submesh) continue;
 				if(!submesh-&gt;isMatInitialised())continue;
-				=

+
 				//printf(&quot;matname=3D%s\n&quot;,submesh-&gt;getMaterialName().c_str());
 =

-				// create hued texture in the current material and update the current =

+				// create hued texture in the current material and update the current
 				Ogre::MaterialPtr mat =3D Ogre::MaterialManager::getSingleton().load(s=
ubmesh-&gt;getMaterialName(),Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROU=
P_NAME);
 				if(mat.isNull()){
 					printf(&quot;ERROR HueMesh: material %s is null\n&quot;,submesh-&gt;getMaterialNam=
e().c_str());
@@ -475,6 +515,7 @@
 				std::string newname =3D cOgreWrapper::GetSingleton().GetUniqueName();
 				Ogre::MaterialPtr mat_hue =3D Ogre::MaterialManager::getSingleton().cr=
eate(newname, mat-&gt;getGroup());
 				//printf(&quot;mat=3D%s mat_hue=3D%s\n&quot;,mat-&gt;getName().c_str(),mat_hue-&gt;get=
Name().c_str());
+				if (mat_hue.isNull()) return 0;
 				mat-&gt;copyDetailsTo(mat_hue);
 =

 				// iterate over all techniques
@@ -482,46 +523,52 @@
 				Ogre::Material::TechniqueIterator tit_hue =3D mat_hue-&gt;getTechniqueIte=
rator();
 				while(tit.hasMoreElements()){
 					Ogre::Technique *tech =3D tit.getNext();
-					Ogre::Technique *tech_hue =3D tit_hue.getNext();
-					=

+					Ogre::Technique *tech_hue =3D tit_hue.getNext();
+					if (!tech || !tech_hue) continue;
+
 					// iterate over all passes
 					Ogre::Technique::PassIterator pit =3D tech-&gt;getPassIterator();
 					Ogre::Technique::PassIterator pit_hue =3D tech_hue-&gt;getPassIterator();
 					while(pit.hasMoreElements()){
 						Ogre::Pass *pass =3D pit.getNext();
-						Ogre::Pass *pass_hue =3D pit_hue.getNext();
-						=

+						Ogre::Pass *pass_hue =3D pit_hue.getNext();
+						if (!pass || !pass_hue) continue;
+
 						// iterate over all tex units
 						Ogre::Pass::TextureUnitStateIterator uit =3D pass-&gt;getTextureUnitSta=
teIterator();
 						Ogre::Pass::TextureUnitStateIterator uit_hue =3D pass_hue-&gt;getTextur=
eUnitStateIterator();
 						while(uit.hasMoreElements()){
 							Ogre::TextureUnitState *unit =3D uit.getNext();
-							Ogre::TextureUnitState *unit_hue =3D uit_hue.getNext();
+							Ogre::TextureUnitState *unit_hue =3D uit_hue.getNext();
+							if (!unit || !unit_hue) continue;
 =

 							// current texture
 							Ogre::TexturePtr tex =3D Ogre::TextureManager::getSingleton().load(=
unit-&gt;getTextureName(),Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_N=
AME);
+							if (tex.isNull()) continue;
 =

 							// lock and read access buffer
-							Ogre::HardwarePixelBufferSharedPtr b =3D tex-&gt;getBuffer();
+							Ogre::HardwarePixelBufferSharedPtr b =3D tex-&gt;getBuffer();
+							if (b.isNull()) continue;
 							// calc size of complete texture
 							Ogre::Image::Box area(0, 0, b-&gt;getWidth(), b-&gt;getHeight());
 							// and lock (ro)
 							const Ogre::PixelBox box =3D b-&gt;lock(area,Ogre::HardwareBuffer::HBL=
_READ_ONLY);
-							=

+
 							// size of one pixel in bytes
 							unsigned int pixelsize =3D Ogre::PixelUtil::getNumElemBytes(box.for=
mat);
 							// texture size in bytes
 							unsigned int size =3D box.getConsecutiveSize();
-							=

-							char *dst =3D new char[size];
+
+							char *dst =3D new char[size+1024*32]; // add a little security over=
size
 							char *src =3D static_cast&lt;char *&gt;(box.data);
 =

 							char *dst_start =3D dst;
 							char *src_start =3D src;
 =

 							uint8 cr,cg,cb,ca1,ca2;
-							short col;
-							=

+							short col;
+							int dummy =3D 0;
+
 							// colorize the pixels
 							for(unsigned int y =3D 0; y &lt; box.getHeight(); y++){
 								for(unsigned int x =3D 0; x &lt; box.getWidth(); x++){
@@ -545,22 +592,23 @@
 							Ogre::DataStreamPtr texstream(new Ogre::MemoryDataStream(dst_start,=
 size));
 							Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().c=
reate(cOgreWrapper::GetSingleton().GetUniqueName(),
 								Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
-							=

+							assert(!tex_hue.isNull() &amp;&amp; &quot;HueMesh bug&quot;);
 							tex_hue-&gt;loadRawData(texstream,box.getWidth(),box.getHeight(),box.f=
ormat);
-							=

+
 							// release the lock
 							b-&gt;unlock();
 =

-							// free memory
+							// set the texture
+							unit_hue-&gt;setTextureName(tex_hue-&gt;getName());
+
+							// free memory
 							delete [] dst_start;
-		=

-							// set the texture
-							unit_hue-&gt;setTextureName(tex_hue-&gt;getName());
 						}
 					}
 				}
 =

-				// set new material
+				// set new material
+				if (mat_hue.isNull()) continue;
 				submesh-&gt;setMaterialName(mat_hue-&gt;getName());
 			}
 		} catch (Ogre::FileNotFoundException e){
@@ -576,15 +624,15 @@
 static int l_CreateLookupTableFromFile (lua_State *L) { PROFILE
 	const char *filename =3D luaL_checkstring(L, 1);
 	lua_newtable(L);
-	=

+
 	cFullFileLoader f(filename);
-	=

+
 	const uint32 *buffer =3D (const uint32 *)f.mpFullFileBuffer;
-	=

+
 	for(int i =3D 0;i &lt; f.miFullFileSize / 4; ++i){
 		lua_pushnumber(L,i); lua_rawseti(L,-2,buffer[i]);
 	}
-	=

+
 	return 1;
 }
 =

@@ -606,7 +654,7 @@
 	Ogre::Real linearStart 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_che=
cknumber(L, ++i) : 0.0;
 	Ogre::Real linearEnd 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_check=
number(L, ++i) : 1.0;
 	/*
-	void 	setFog (FogMode mode=3DFOG_NONE, const ColourValue &amp;colour=3DColour=
Value::White, =

+	void 	setFog (FogMode mode=3DFOG_NONE, const ColourValue &amp;colour=3DColour=
Value::White,
 					Real expDensity=3D0.001, Real linearStart=3D0.0, Real linearEnd=3D1.0)
     0=3DFOG_NONE 	No fog. Duh.
     1=3DFOG_EXP 	Fog density increases exponentially from the camera (fog =
=3D 1/e^(distance * density)).
@@ -664,23 +712,36 @@
 =

 static int l_Client_AddPointLight (lua_State *L) { PROFILE
 	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
-	if (pSceneMgr) {
-		Ogre::Light* pLight =3D pSceneMgr-&gt;createLight( cOgreWrapper::GetSinglet=
on().GetUniqueName() );
-		pLight-&gt;setType( Ogre::Light::LT_POINT );
-		pLight-&gt;setPosition(luaL_checknumber(L,1),luaL_checknumber(L,2),luaL_che=
cknumber(L,3));
-	}
-	return 0;
-}
-
-static int l_Client_AddDirectionalLight (lua_State *L) { PROFILE
-	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
-	if (pSceneMgr) {
-		Ogre::Light* pLight =3D pSceneMgr-&gt;createLight( cOgreWrapper::GetSinglet=
on().GetUniqueName() );
-		pLight-&gt;setType( Ogre::Light::LT_DIRECTIONAL );
-		pLight-&gt;setDirection(luaL_checknumber(L,1),luaL_checknumber(L,2),luaL_ch=
ecknumber(L,3));
-	}
-	return 0;
-}
+	if (!pSceneMgr) return 0;
+	std::string sName =3D cOgreWrapper::GetSingleton().GetUniqueName();
+	Ogre::Light* pLight =3D pSceneMgr-&gt;createLight( sName );
+	pLight-&gt;setType( Ogre::Light::LT_POINT );
+	pLight-&gt;setPosition(luaL_checknumber(L,1),luaL_checknumber(L,2),luaL_chec=
knumber(L,3));
+	pLight-&gt;setDiffuseColour(luaL_checknumber(L,4),luaL_checknumber(L,5),luaL=
_checknumber(L,6));
+	pLight-&gt;setSpecularColour(luaL_checknumber(L,7),luaL_checknumber(L,8),lua=
L_checknumber(L,9));
+	pLight-&gt;setAttenuation(luaL_checknumber(L,10),luaL_checknumber(L,11),luaL=
_checknumber(L,12),luaL_checknumber(L,13));
+	pLight-&gt;setCastShadows(false);
+	lua_pushstring(L,sName.c_str());
+	return 1;
+}
+
+static int l_Client_AddDirectionalLight (lua_State *L) { PROFILE
+	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
+	if (!pSceneMgr) return 0;
+	std::string sName =3D cOgreWrapper::GetSingleton().GetUniqueName();
+	Ogre::Light* pLight =3D pSceneMgr-&gt;createLight( sName );
+	pLight-&gt;setType( Ogre::Light::LT_DIRECTIONAL );
+	pLight-&gt;setDirection(luaL_checknumber(L,1),luaL_checknumber(L,2),luaL_che=
cknumber(L,3));
+	lua_pushstring(L,sName.c_str());
+	return 1;
+}
+
+static int l_Client_DeleteLight (lua_State *L) { PROFILE
+	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
+	if (pSceneMgr) pSceneMgr-&gt;destroyLight(luaL_checkstring(L,1));
+	return 0;
+}
+
 =

 static int l_Client_GetPhysStepTime (lua_State *L) { PROFILE
 	lua_pushnumber(L,cTimer::mfPhysStepTime);
@@ -694,29 +755,29 @@
 	cOgreWrapper::GetSingleton().TakeGridScreenshot(3,filename,ext,true);
 	return 0;
 }
-
-/// saved in main directory
-static int l_Client_TakeScreenshot (lua_State *L) { PROFILE
-	cOgreWrapper::GetSingleton().TakeScreenshot();
-	return 0;
-}
-
-void	OgreForceCloseFullscreen ();
-
-/// shows ogre config dialog
-static int l_Client_ShowOgreConfig (lua_State *L) { PROFILE
-	bool bIsFullscreen =3D cOgreWrapper::GetSingleton().mWindow-&gt;isFullScreen=
();
-	printf(&quot;Client_ShowOgreConfig fullscreen=3D%d\n&quot;,bIsFullscreen);
-	bIsFullscreen =3D true; // detection fails in linux ?
-	if (bIsFullscreen) {
-		// hide window to make config window visible in fullscreen mode, evil ha=
ck since this is not supported by ogre
-		OgreForceCloseFullscreen();
-	}
-	lua_pushboolean(L,cOgreWrapper::GetSingleton().mRoot-&gt;showConfigDialog());
-	if (bIsFullscreen) cShell::mbAlive =3D false;
-	// the application shoudl terminate after this
-	// terminates the game if changes were made
-	return 1;
+
+/// saved in main directory
+static int l_Client_TakeScreenshot (lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().TakeScreenshot();
+	return 0;
+}
+
+void	OgreForceCloseFullscreen ();
+
+/// shows ogre config dialog
+static int l_Client_ShowOgreConfig (lua_State *L) { PROFILE
+	bool bIsFullscreen =3D cOgreWrapper::GetSingleton().mWindow-&gt;isFullScreen=
();
+	printf(&quot;Client_ShowOgreConfig fullscreen=3D%d\n&quot;,bIsFullscreen);
+	bIsFullscreen =3D true; // detection fails in linux ?
+	if (bIsFullscreen) {
+		// hide window to make config window visible in fullscreen mode, evil ha=
ck since this is not supported by ogre
+		OgreForceCloseFullscreen();
+	}
+	lua_pushboolean(L,cOgreWrapper::GetSingleton().mRoot-&gt;showConfigDialog());
+	if (bIsFullscreen) cShell::mbAlive =3D false;
+	// the application shoudl terminate after this
+	// terminates the game if changes were made
+	return 1;
 }
 =

 static int l_BuildTerrainEntity_Simple (lua_State *L) { PROFILE
@@ -744,18 +805,18 @@
 	lua_pushstring(L,meshname.c_str());
 	return 1;
 }
-
+
 /// OBSOLETED CODE ! don't use this, hasn't been adjusted to xmirror fix
 /// for lua : TerrainRayPick(GroundBlockLoader,blockx,blocky,vBlockPosX,vB=
lockPosY,vBlockPosZ,rx,ry,rz,rvx,rvy,rvz)  -- mainly for mousepicking
 static int l_TerrainRayPick (lua_State *L) { PROFILE
 	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
 	if (!pGroundBlockLoader) return 0;
-	=

+
 	// don't use ++i or something here, the compiler might mix the order
 	Ogre::Vector3 	vBlockPos(luaL_checknumber(L,4),luaL_checknumber(L,5),luaL=
_checknumber(L,6));
 	Ogre::Vector3	vRayPos(luaL_checknumber(L,7),luaL_checknumber(L,8),luaL_ch=
ecknumber(L,9));
 	Ogre::Vector3	vRayDir(luaL_checknumber(L,10),luaL_checknumber(L,11),luaL_=
checknumber(L,12));
-	=

+
 	// feedback via lua callback TerrainRayIntersect_Hit()
 	TerrainRayIntersect(pGroundBlockLoader,luaL_checkint(L,2),luaL_checkint(L=
,3),vRayPos-vBlockPos,vRayDir);
 	return 0;
@@ -768,7 +829,7 @@
 	float			fSphereRad =3D luaL_checknumber(L,4);
 	Ogre::Vector3	vRayPos(	luaL_checknumber(L,5),luaL_checknumber(L,6),luaL_c=
hecknumber(L,7));
 	Ogre::Vector3	vRayDir(	luaL_checknumber(L,8),luaL_checknumber(L,9),luaL_c=
hecknumber(L,10));
-	=

+
 	std::pair&lt;bool, Real&gt; hit =3D Ogre::Ray(vRayPos,vRayDir).intersects(Ogre:=
:<i>Sphere(vSpherePos,fSphereRad));
</I> 	if (!hit.first) return 0;
 	lua_pushnumber(L,hit.second);
@@ -776,8 +837,13 @@
 }
 =

 =

-static int l_UnloadMeshName (lua_State *L) { PROFILE
-	Ogre::MeshManager::getSingleton().unload(luaL_checkstring(L,1));
+static int l_UnloadMeshName (lua_State *L) { PROFILE
+	const char* szMeshName =3D luaL_checkstring(L,1);
+	Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().load(szMeshName,=
Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+	if (mesh.isNull()) return 0;
+	mesh-&gt;unload();
+	UnloadMeshShape(szMeshName);
+	//Ogre::MeshManager::getSingleton().unload(luaL_checkstring(L,1));
 	return 0;
 }
 =

@@ -830,12 +896,12 @@
 static int l_GetRandomHexString 	(lua_State *L) { PROFILE lua_pushstring( =
L, strprintf(&quot;0x%08x&quot;,rand()).c_str()); return 1; }
 =

 /// converts &quot;0x1234&quot; to a number
-static int l_Hex2Num 	(lua_State *L) { PROFILE =

+static int l_Hex2Num 	(lua_State *L) { PROFILE
 	std::string hexcode =3D luaL_checkstring(L,1);
 	uint32 res =3D 0;
 	sscanf(hexcode.c_str(),&quot;0x%x&quot;,&amp;res);
-	lua_pushnumber(L, res); =

-	return 1; =

+	lua_pushnumber(L, res);
+	return 1;
 }
 =

 // bitwise operations, used for networking, packet manipulation etc
@@ -844,9 +910,9 @@
 	double g =3D luaL_checknumber(L,1);
 	double h =3D luaL_checknumber(L,2);
 	uint32 a =3D uint32(g);
-	uint32 b =3D uint32(h);	=

+	uint32 b =3D uint32(h);
 	uint32 c =3D a &amp; b;
-	lua_pushnumber( L, c); =

+	lua_pushnumber( L, c);
 	return 1;
 }
 static int l_BitwiseOR 		(lua_State *L) { PROFILE
@@ -854,9 +920,9 @@
 	double g =3D luaL_checknumber(L,1);
 	double h =3D luaL_checknumber(L,2);
 	uint32 a =3D uint32(g);
-	uint32 b =3D uint32(h);	=

+	uint32 b =3D uint32(h);
 	uint32 c =3D a | b;
-	lua_pushnumber( L, c); =

+	lua_pushnumber( L, c);
 	return 1;
 }
 =

@@ -866,74 +932,74 @@
 	double g =3D luaL_checknumber(L,1);
 	double h =3D luaL_checknumber(L,2);
 	uint32 a =3D uint32(g);
-	uint32 b =3D uint32(h);	=

+	uint32 b =3D uint32(h);
 	uint32 c =3D a ^ b;
-	lua_pushnumber( L, c); =

-	return 1;
-}
-
-// bitwise operations, used for networking, packet manipulation etc =

-static int l_BitwiseSHL 	(lua_State *L) { PROFILE =

-	// keep this spread out like this to avoid strange, 32 bi =

-	double g =3D luaL_checknumber(L,1); =

-	double h =3D luaL_checknumber(L,2); =

-	uint32 a =3D uint32(g); =

-	uint32 b =3D uint32(h);	 =

-	uint32 c =3D a &lt;&lt; b; =

-	lua_pushnumber( L, c);  =

-	return 1; =

-} =

-// bitwise operations, used for networking, packet manipulation etc =

-static int l_BitwiseSHR 	(lua_State *L) { PROFILE =

-	// keep this spread out like this to avoid strange, 32 bi =

-	double g =3D luaL_checknumber(L,1); =

-	double h =3D luaL_checknumber(L,2); =

-	uint32 a =3D uint32(g); =

-	uint32 b =3D uint32(h);	 =

-	uint32 c =3D a &gt;&gt; b; =

-	lua_pushnumber( L, c);  =

-	return 1; =

+	lua_pushnumber( L, c);
+	return 1;
+}
+
+// bitwise operations, used for networking, packet manipulation etc
+static int l_BitwiseSHL 	(lua_State *L) { PROFILE
+	// keep this spread out like this to avoid strange, 32 bi
+	double g =3D luaL_checknumber(L,1);
+	double h =3D luaL_checknumber(L,2);
+	uint32 a =3D uint32(g);
+	uint32 b =3D uint32(h);
+	uint32 c =3D a &lt;&lt; b;
+	lua_pushnumber( L, c);
+	return 1;
+}
+// bitwise operations, used for networking, packet manipulation etc
+static int l_BitwiseSHR 	(lua_State *L) { PROFILE
+	// keep this spread out like this to avoid strange, 32 bi
+	double g =3D luaL_checknumber(L,1);
+	double h =3D luaL_checknumber(L,2);
+	uint32 a =3D uint32(g);
+	uint32 b =3D uint32(h);
+	uint32 c =3D a &gt;&gt; b;
+	lua_pushnumber( L, c);
+	return 1;
 }
 =

 =

 static int l_TestBit 		(lua_State *L) { PROFILE lua_pushboolean(L,(uint32(=
luaL_checknumber(L,1)) &amp; (uint32(1) &lt;&lt; luaL_checkint(L,2))) !=3D 0); return=
 1; }
 static int l_SetBit 		(lua_State *L) { PROFILE lua_pushnumber( L,(uint32(l=
uaL_checknumber(L,1)) | (uint32(1) &lt;&lt; luaL_checkint(L,2)))); return 1; }
-static int l_ClearBit 		(lua_State *L) { PROFILE =

+static int l_ClearBit 		(lua_State *L) { PROFILE
 	uint32 input =3D uint32(luaL_checknumber(L,1));
 	uint32 mask =3D 1L &lt;&lt; uint32(luaL_checknumber(L,2));
 	lua_pushnumber(L,(input &amp; mask)?(input ^ mask):(input));  // XOR =3D ^ =
=3D toggle bit... toggle only if set (&amp;) to clear
-	return 1; =

-}
-
-
-static int l_Exit		 		(lua_State *L) { PROFILE =

-	exit((lua_gettop(L) &gt;=3D 1 &amp;&amp; !lua_isnil(L,1)) ? luaL_checkint(L,1) : 0); =

-	return 0; =

+	return 1;
+}
+
+
+static int l_Exit		 		(lua_State *L) { PROFILE
+	exit((lua_gettop(L) &gt;=3D 1 &amp;&amp; !lua_isnil(L,1)) ? luaL_checkint(L,1) : 0);
+	return 0;
 }
 =

 void MyCrash		(const char* szMessage); // see main.cpp
 =

-static int l_Crash		 		(lua_State *L) { PROFILE =

+static int l_Crash		 		(lua_State *L) { PROFILE
 	MyCrash(&quot;CRASH triggered from script, see console for info (start with co=
mmandline option -c)&quot;); // does not return...
 	exit(88);  =

-	return 0; =

+	return 0; =

 }
 =

 /// triggers a segfault, for testing our segfault handlers lua stacktrace
-static int l_CrashSegFault		 		(lua_State *L) { PROFILE =

+static int l_CrashSegFault		 		(lua_State *L) { PROFILE
 	DisplayErrorMessage(&quot;testing segfault handler...&quot;);
 	*((char*)0) =3D 0; // trigger segfault
-	return 0; =

-}
-
-
-static int l_DisplayNotice	(lua_State *L) { PROFILE =

+	return 0;
+}
+
+
+static int l_DisplayNotice	(lua_State *L) { PROFILE
 	DisplayNotice(luaL_checkstring(L,1));
 	return 0;
 }
 =

 =

-static int l_FatalErrorMessage	(lua_State *L) { PROFILE =

+static int l_FatalErrorMessage	(lua_State *L) { PROFILE
 	DisplayErrorMessage(luaL_checkstring(L,1));
 	exit(77);
 	return 0;
@@ -941,19 +1007,19 @@
 =

 =

 /// for lua :   void  ExportMesh  (meshname,filename)
-static int l_ExportMesh		(lua_State *L) { PROFILE =

+static int l_ExportMesh		(lua_State *L) { PROFILE
 	Ogre::MeshPtr pMesh =3D Ogre::MeshManager::getSingleton().load(luaL_check=
string(L,1),
 					// autodetect group location
 					//Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
 					Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
 	Ogre::MeshSerializer myExporter;
 	//Ogre::Mesh* pMesh =3D pEntity-&gt;getMesh().get();
-	myExporter.exportMesh(pMesh.get(),luaL_checkstring(L,2)); =

+	myExporter.exportMesh(pMesh.get(),luaL_checkstring(L,2));
 	return 0;
 }
 =

 /// for lua :   x,y,z,vx,vy,vz  GetMouseRay  ()
-static int l_GetMouseRay		(lua_State *L) { PROFILE =

+static int l_GetMouseRay		(lua_State *L) { PROFILE
 	cOgreWrapper&amp; ogrewrapper =3D cOgreWrapper::GetSingleton();
 	Ogre::Ray myray(	ogrewrapper.mCamera-&gt;getCameraToViewportRay(
 				Ogre::Real(cInput::iMouse[0]) / Ogre::Real(ogrewrapper.mViewport-&gt;getA=
ctualWidth()),
@@ -968,14 +1034,14 @@
 }
 =

 /// for lua :   z  GetMaxZ  ()
-static int 		l_GetMaxZ		(lua_State *L) { PROFILE =

+static int 		l_GetMaxZ		(lua_State *L) { PROFILE
 	lua_pushnumber(L,Ogre::Root::getSingleton().getRenderSystem()-&gt;getMaximum=
DepthInputValue());
 	return 1;
 }
 =

 =

 /// for lua :   bIsInFront,px,py  ProjectPos  (x,y,z)
-static int l_ProjectPos		(lua_State *L) { PROFILE =

+static int l_ProjectPos		(lua_State *L) { PROFILE
 	bool 		bIsInFront;
 	Ogre::Real	fX,fY;
 	bIsInFront =3D cOgreWrapper::GetSingleton().ProjectPos(
@@ -987,7 +1053,7 @@
 }
 =

 /// for lua :   bIsInFront,px,py,cx,cy  ProjectSizeAndPos  (x,y,z,r)
-static int l_ProjectSizeAndPos		(lua_State *L) { PROFILE =

+static int l_ProjectSizeAndPos		(lua_State *L) { PROFILE
 	bool 		bIsInFront;
 	Ogre::Real	fX,fY,fCX,fCY;
 	bIsInFront =3D cOgreWrapper::GetSingleton().ProjectSizeAndPos(
@@ -1012,9 +1078,9 @@
 static int l_OgreMeshTextures	(lua_State *L) { PROFILE  // TODO : move to =
seperate file ?
 	Ogre::MeshSerializer* meshSerializer =3D new Ogre::MeshSerializer();
 	const char *szMeshName =3D luaL_checkstring(L,1);
-	=

+
 	lua_newtable(L);
-		=

+
 	//printf(&quot;open file: %s\n&quot;,szMeshName);
 	// model file
 	std::ifstream ifs;
@@ -1024,13 +1090,13 @@
 	if(ifs.is_open()){
 		//printf(&quot;create tmp mesh\n&quot;);
 		// create tmp mesh import resource
-		Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().create(&quot;l_OgreM=
eshTextureMissing_conversion&quot;, =

+		Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().create(&quot;l_OgreM=
eshTextureMissing_conversion&quot;,
 			Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
 =

 		//printf(&quot;import\n&quot;);
 		// import
 		meshSerializer-&gt;importMesh(stream, mesh.getPointer());
-		=

+
 		if(!mesh.isNull()){
 			// iterator over submeshes
 			Ogre::Mesh::SubMeshIterator it =3D mesh-&gt;getSubMeshIterator();
@@ -1043,51 +1109,161 @@
 				++i;
 			}
 		}
-		=

+
 		// remove all stuff
 		Ogre::MeshManager::getSingleton().remove(&quot;l_OgreMeshTextureMissing_conve=
rsion&quot;);
-		=

+
 		ifs.close();
 	} else {
 		printf(&quot;ERROR can't open file: %s\n&quot;,szMeshName);
 	}
 =

 	delete meshSerializer;
-		=

-	return 1;
+
+	return 1;
+}
+
+
+/// for lua :   void OgreShadowTechnique  (string techique)
+static int l_OgreShadowTechnique	(lua_State *L) { PROFILE  // TODO : move =
to seperate file ?
+	const char *tech =3D luaL_checkstring(L,1);
+	Ogre::SceneManager *p =3D cOgreWrapper::GetSingleton().mSceneMgr;
+
+	if(p){
+		if(strcmp(tech,&quot;stencil_modulative&quot;) =3D=3D 0)p-&gt;setShadowTechnique(Ogre=
::<i>SHADOWTYPE_STENCIL_MODULATIVE);
</I>+		else if(strcmp(tech,&quot;stencil_additive&quot;) =3D=3D 0)p-&gt;setShadowTechnique(O=
gre::SHADOWTYPE_STENCIL_ADDITIVE);
+		else if(strcmp(tech,&quot;texture_modulative&quot;) =3D=3D 0)p-&gt;setShadowTechnique=
(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE);
+		else if(strcmp(tech,&quot;texture_additive&quot;) =3D=3D 0)p-&gt;setShadowTechnique(O=
gre::SHADOWTYPE_TEXTURE_ADDITIVE);
+		else if(strcmp(tech,&quot;texture_additive_integrated&quot;) =3D=3D 0)p-&gt;setShadow=
Technique(Ogre::SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED);
+		else if(strcmp(tech,&quot;texture_modulative_integrated&quot;) =3D=3D 0)p-&gt;setShad=
owTechnique(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED);
+		else p-&gt;setShadowTechnique(Ogre::SHADOWTYPE_NONE);
+	}
+    return 0;
+}
+
+/// for lua :   void	  OgreSetShadowTextureSize  (int size)
+static int 				l_OgreSetShadowTextureSize	(lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureSize(luaL_checkin=
t(L,1));
+	return 0;
 }
 =

+
+
+/// for lua :   void	  OgreSetShadowFarDistance	(float x)
+static int 				l_OgreSetShadowFarDistance	(lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowFarDistance(luaL_checknu=
mber(L,1));
+	return 0;
+}
 =

-/// for lua :   void OgreShadowTechnique  (string techique)
-static int l_OgreShadowTechnique	(lua_State *L) { PROFILE  // TODO : move =
to seperate file ?
-	const char *tech =3D luaL_checkstring(L,1);
-	Ogre::SceneManager *p =3D cOgreWrapper::GetSingleton().mSceneMgr;
-	=

-	if(p){
-		if(strcmp(tech,&quot;stencil_modulative&quot;) =3D=3D 0)p-&gt;setShadowTechnique(Ogre=
::<i>SHADOWTYPE_STENCIL_MODULATIVE);
</I>-		else if(strcmp(tech,&quot;stencil_additive&quot;) =3D=3D 0)p-&gt;setShadowTechnique(O=
gre::SHADOWTYPE_STENCIL_ADDITIVE);
-		else if(strcmp(tech,&quot;texture_modulative&quot;) =3D=3D 0)p-&gt;setShadowTechnique=
(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE);
-		else if(strcmp(tech,&quot;texture_additive&quot;) =3D=3D 0)p-&gt;setShadowTechnique(O=
gre::SHADOWTYPE_TEXTURE_ADDITIVE);
-		else if(strcmp(tech,&quot;texture_additive_integrated&quot;) =3D=3D 0)p-&gt;setShadow=
Technique(Ogre::SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED);
-		else if(strcmp(tech,&quot;texture_modulative_integrated&quot;) =3D=3D 0)p-&gt;setShad=
owTechnique(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED);
-		else p-&gt;setShadowTechnique(Ogre::SHADOWTYPE_NONE);
-	}
-		=

+/// for lua :   void	  OgreSetShadowDirLightTextureOffset	(float x)
+static int 				l_OgreSetShadowDirLightTextureOffset	(lua_State *L) { PROFI=
LE
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowDirLightTextureOffset(lu=
aL_checknumber(L,1));
 	return 0;
 }
 =

+/// for lua :   void	  OgreSetShadowTextureFadeStart	(float x)
+static int 				l_OgreSetShadowTextureFadeStart	(lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureFadeStart(luaL_ch=
ecknumber(L,1));
+	return 0;
+}
+
+/// for lua :   void	  OgreSetShadowTextureFadeEnd	(float x)
+static int 				l_OgreSetShadowTextureFadeEnd	(lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureFadeEnd(luaL_chec=
knumber(L,1));
+	return 0;
+}
+
+/// for lua :   void	  OgreSetShadowTexturePixelFormat	()
+static int 				l_OgreSetShadowTexturePixelFormat	(lua_State *L) { PROFILE
+	Ogre::PixelFormat pf =3D (lua_gettop(L) &gt;=3D 2 &amp;&amp; !lua_isnil(L,1)) ? ((Og=
re::PixelFormat)luaL_checkint(L,1)) : Ogre::PF_FLOAT16_R;
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTexturePixelFormat(pf);
+	return 0;
+}
+
+
+/// for lua :   table	  OgrePixelFormatList  ()
+static int 				l_OgrePixelFormatList	(lua_State *L) { PROFILE
+	lua_newtable(L);
+	#define OgrePixelFormatList_REGISTER(pf) lua_pushstring(L,#pf); lua_rawse=
ti(L,-2,(int)Ogre::pf);
+	OgrePixelFormatList_REGISTER(PF_UNKNOWN)		// 	Unknown pixel format.
+	OgrePixelFormatList_REGISTER(PF_L8)				// 		8-bit pixel format, all bits =
luminace.
+	OgrePixelFormatList_REGISTER(PF_BYTE_L)			//
+	OgrePixelFormatList_REGISTER(PF_L16)			// 		16-bit pixel format, all bits=
 luminace.
+	OgrePixelFormatList_REGISTER(PF_SHORT_L)		//
+	OgrePixelFormatList_REGISTER(PF_A8)				// 		8-bit pixel format, all bits =
alpha.
+	OgrePixelFormatList_REGISTER(PF_BYTE_A)			//
+	OgrePixelFormatList_REGISTER(PF_A4L4)			// 	8-bit pixel format, 4 bits al=
pha, 4 bits luminace.
+	OgrePixelFormatList_REGISTER(PF_BYTE_LA)		// 	2 byte pixel format, 1 byte=
 luminance, 1 byte alpha
+	OgrePixelFormatList_REGISTER(PF_R5G6B5)			// 	16-bit pixel format, 5 bits=
 red, 6 bits green, 5 bits blue.
+	OgrePixelFormatList_REGISTER(PF_B5G6R5)			// 	16-bit pixel format, 5 bits=
 red, 6 bits green, 5 bits blue.
+	OgrePixelFormatList_REGISTER(PF_R3G3B2)			// 	8-bit pixel format, 2 bits =
blue, 3 bits green, 3 bits red.
+	OgrePixelFormatList_REGISTER(PF_A4R4G4B4)		// 	16-bit pixel format, 4 bit=
s for alpha, red, green and blue.
+	OgrePixelFormatList_REGISTER(PF_A1R5G5B5)		// 	16-bit pixel format, 5 bit=
s for blue, green, red and 1 for alpha.
+	OgrePixelFormatList_REGISTER(PF_R8G8B8)			// 	24-bit pixel format, 8 bits=
 for red, green and blue.
+	OgrePixelFormatList_REGISTER(PF_B8G8R8)			// 	24-bit pixel format, 8 bits=
 for blue, green and red.
+	OgrePixelFormatList_REGISTER(PF_A8R8G8B8)		// 	32-bit pixel format, 8 bit=
s for alpha, red, green and blue.
+	OgrePixelFormatList_REGISTER(PF_A8B8G8R8)		// 	32-bit pixel format, 8 bit=
s for blue, green, red and alpha.
+	OgrePixelFormatList_REGISTER(PF_B8G8R8A8)		// 	32-bit pixel format, 8 bit=
s for blue, green, red and alpha.
+	OgrePixelFormatList_REGISTER(PF_R8G8B8A8)		// 	32-bit pixel format, 8 bit=
s for red, green, blue and alpha.
+	OgrePixelFormatList_REGISTER(PF_X8R8G8B8)		// 	32-bit pixel format, 8 bit=
s for red, 8 bits for green, 8 bits for blue like PF_A8R8G8B8, but alpha wi=
ll get discarded
+	OgrePixelFormatList_REGISTER(PF_X8B8G8R8)		// 	32-bit pixel format, 8 bit=
s for blue, 8 bits for green, 8 bits for red like PF_A8B8G8R8, but alpha wi=
ll get discarded
+	OgrePixelFormatList_REGISTER(PF_BYTE_RGB)		// 	3 byte pixel format, 1 byt=
e for red, 1 byte for green, 1 byte for blue
+	OgrePixelFormatList_REGISTER(PF_BYTE_BGR)		// 	3 byte pixel format, 1 byt=
e for blue, 1 byte for green, 1 byte for red
+	OgrePixelFormatList_REGISTER(PF_BYTE_BGRA)		// 	4 byte pixel format, 1 by=
te for blue, 1 byte for green, 1 byte for red and one byte for alpha
+	OgrePixelFormatList_REGISTER(PF_BYTE_RGBA)		// 	4 byte pixel format, 1 by=
te for red, 1 byte for green, 1 byte for blue, and one byte for alpha
+	OgrePixelFormatList_REGISTER(PF_A2R10G10B10)	// 	32-bit pixel format, 2 b=
its for alpha, 10 bits for red, green and blue.
+	OgrePixelFormatList_REGISTER(PF_A2B10G10R10)	// 	32-bit pixel format, 10 =
bits for blue, green and red, 2 bits for alpha.
+	OgrePixelFormatList_REGISTER(PF_DXT1)			// 	DDS (DirectDraw Surface) DXT1=
 format.
+	OgrePixelFormatList_REGISTER(PF_DXT2)			// 	DDS (DirectDraw Surface) DXT2=
 format.
+	OgrePixelFormatList_REGISTER(PF_DXT3)			// 	DDS (DirectDraw Surface) DXT3=
 format.
+	OgrePixelFormatList_REGISTER(PF_DXT4)			// 	DDS (DirectDraw Surface) DXT4=
 format.
+	OgrePixelFormatList_REGISTER(PF_DXT5)			// 	DDS (DirectDraw Surface) DXT5=
 format.
+	OgrePixelFormatList_REGISTER(PF_FLOAT16_R)		//
+	OgrePixelFormatList_REGISTER(PF_FLOAT16_RGB)	//
+	OgrePixelFormatList_REGISTER(PF_FLOAT16_RGBA)	//
+	OgrePixelFormatList_REGISTER(PF_FLOAT32_R)		//
+	OgrePixelFormatList_REGISTER(PF_FLOAT32_RGB)	//
+	OgrePixelFormatList_REGISTER(PF_FLOAT32_RGBA)	//
+	OgrePixelFormatList_REGISTER(PF_FLOAT16_GR)		//
+	OgrePixelFormatList_REGISTER(PF_FLOAT32_GR)		//
+	OgrePixelFormatList_REGISTER(PF_DEPTH)			//
+	OgrePixelFormatList_REGISTER(PF_SHORT_RGBA)		//
+	OgrePixelFormatList_REGISTER(PF_SHORT_GR)		//
+	OgrePixelFormatList_REGISTER(PF_SHORT_RGB)		//
+	OgrePixelFormatList_REGISTER(PF_COUNT)			//
+	return 1;
+}
+
+
+/// for lua :   void	  OgreSetShadowTextureSelfShadow  (bool)
+static int 				l_OgreSetShadowTextureSelfShadow	(lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureSelfShadow(lua_to=
boolean(L,1));
+	return 0;
+}
+
+/// for lua :   void 	  OgreSetShadowTextureCasterMaterial  (sMatName)
+static int 				l_OgreSetShadowTextureCasterMaterial			(lua_State *L) { PRO=
FILE
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureCasterMaterial(lu=
aL_checkstring(L,1));
+	return 0;
+}
+
+/// for lua :   void	  OgreSetShadowTextureReceiverMaterial  (sMatName)
+static int 				l_OgreSetShadowTextureReceiverMaterial	(lua_State *L) { PRO=
FILE  // TODO : move to seperate file ?
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setShadowTextureReceiverMaterial(=
luaL_checkstring(L,1));
+	return 0;
+}
 =

 /// for lua :   void OgreAmbientLight  (r,g,b) [color value 0..1 each]
 static int l_OgreAmbientLight	(lua_State *L) { PROFILE  // TODO : move to =
seperate file ?
-	float r =3D luaL_checknumber(L,1);
-	float g =3D luaL_checknumber(L,2);
-	float b =3D luaL_checknumber(L,3);
-	Ogre::SceneManager *p =3D cOgreWrapper::GetSingleton().mSceneMgr;
-	=

-	if(p){
-		p-&gt;setAmbientLight( ColourValue( r, g, b ) );
-	}
-	=

+	float r =3D luaL_checknumber(L,1);
+	float g =3D luaL_checknumber(L,2);
+	float b =3D luaL_checknumber(L,3);
+	Ogre::SceneManager *p =3D cOgreWrapper::GetSingleton().mSceneMgr;
+
+	if(p){
+		p-&gt;setAmbientLight( ColourValue( r, g, b ) );
+	}
+
 	return 0;
 }
 =

@@ -1098,6 +1274,23 @@
 	return 1;
 }
 =

+
+/// for lua :   number OgreLastFPS  ()
+static int l_OgreLastFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWr=
apper::GetSingleton().mfLastFPS);return 1; }
+/// for lua :   number OgreAvgFPS  ()
+static int l_OgreAvgFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWra=
pper::GetSingleton().mfAvgFPS);return 1; }
+/// for lua :   number OgreBestFPS  ()
+static int l_OgreBestFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWr=
apper::GetSingleton().mfBestFPS);return 1; }
+/// for lua :   number OgreWorstFPS  ()
+static int l_OgreWorstFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreW=
rapper::GetSingleton().mfWorstFPS);return 1; }
+/// for lua :   number OgreBestFrameTime  ()
+static int l_OgreBestFrameTime	(lua_State *L) { PROFILE lua_pushnumber(L,c=
OgreWrapper::GetSingleton().miBestFrameTime);return 1; }
+/// for lua :   number OgreWorstFrameTime  ()
+static int l_OgreWorstFrameTime	(lua_State *L) { PROFILE lua_pushnumber(L,=
cOgreWrapper::GetSingleton().miWorstFrameTime);return 1; }
+/// for lua :   number OgreTriangleCount  ()
+static int l_OgreTriangleCount	(lua_State *L) { PROFILE lua_pushnumber(L,c=
OgreWrapper::GetSingleton().miTriangleCount);return 1; }
+/// for lua :   number OgreBatchCount  ()
+static int l_OgreBatchCount	(lua_State *L) { PROFILE lua_pushnumber(L,cOgr=
eWrapper::GetSingleton().miBatchCount);return 1; }
 =

 /*
 static int l_Client_SetMouseSensitivity (lua_State *L) { PROFILE
@@ -1166,44 +1359,44 @@
 /// don't use directly, used by LuaCall
 int 	PCallWithErrFuncWrapper (lua_State *L,int narg, int nret) { PROFILE
 	int status;
-	int base =3D lua_gettop(L) - narg;  // function index =

+	int base =3D lua_gettop(L) - narg;  // function index
 	lua_pushliteral(L, &quot;_TRACEBACK&quot;);
-	lua_rawget(L, LUA_GLOBALSINDEX); // get traceback function =

-	lua_insert(L, base);  // put it under chunk and args =

+	lua_rawget(L, LUA_GLOBALSINDEX); // get traceback function
+	lua_insert(L, base);  // put it under chunk and args
 	// signal(SIGINT, laction); // copyed from example, no idea what this is =
good for =3D(
 	status =3D lua_pcall(L, narg, (nret=3D=3D-1) ? LUA_MULTRET : nret, base);
-	=

+
 	//printf(&quot;pcall end, cleaning up....\n&quot;);
-	=

+
 	// signal(SIGINT, SIG_DFL); // copyed from example, no idea what this is =
good for =3D(
-	lua_remove(L, base);  // remove traceback function // TODO : this might c=
rash if error handler closed the lua state =

-	=

+	lua_remove(L, base);  // remove traceback function // TODO : this might c=
rash if error handler closed the lua state
+
 	//printf(&quot;pcall end\n&quot;);
-	=

+
 	return status;
 }
-
-
-void MyCrash				(const char* szMessage);
+
+
+void MyCrash				(const char* szMessage);
 =

 void LuaErrorHandler (lua_State *L, const char *fmt, ...) { PROFILE
 	printf(&quot;LuaErrorHandler start\n&quot;);
-	=

+
 	va_list argp;
-	va_start(argp, fmt);
-	gRobStringBuffer[0] =3D 0;
-	vsnprintf(gRobStringBuffer,kRobStringBufferSize-1,fmt, argp);
+	va_start(argp, fmt);
+	gRobStringBuffer[0] =3D 0;
+	vsnprintf(gRobStringBuffer,kRobStringBufferSize-1,fmt, argp);
 	std::string s(gRobStringBuffer);
-	va_end(argp);
-	=

-	std::string mystr(&quot;LuaError\n&quot;);
+	va_end(argp);
+
+	std::string mystr(&quot;LuaError\n&quot;);
 	mystr +=3D s;
-	=

+
 	printf(&quot;\nLuaErrorHandler end\n&quot;);
-	=

+
 	//lua_close(L);
 	MyCrash(mystr.c_str());
-	// todo : attempt recovery in case of protected function call ?
+	// todo : attempt recovery in case of protected function call ?
 	// todo : deinit ogre to free mouse here
 }
 =

@@ -1300,7 +1493,7 @@
 	//if (lua_pcall(L, narg, nres, 0) !=3D 0)  { // old
 		/* do the call */
 		LuaErrorHandler(L, &quot;error running function `%s': %s&quot;,func, lua_tostring(=
L, -1));
-		=

+
 		/*
 		doku for lua_pcall last argument (errorfunc)
 		if 0 ... else that argument should be the index in the stack where the e=
rror handler function is located. Notice that, in such cases, the handler m=
ust be pushed in the stack before the function to be called and its argumen=
ts.
@@ -1346,7 +1539,7 @@
 			}
 			nres++;
 		}
-		// pop stack    =

+		// pop stack
 		lua_pop(L, popamount);
 	}
 	va_end(vl);
@@ -1362,7 +1555,7 @@
 		DisplayErrorMessage(&quot;ERROR : lua-precision wrong&quot;);
 		exit(43);
 	}
-	=

+
 	L =3D lua_open();
 	assert(L);
 	luaopen_base(L);
@@ -1371,7 +1564,7 @@
 	luaopen_string(L);
 	luaopen_math(L);
 	luaopen_debug(L);
-	=

+
 	lua_register(L,&quot;GetNamedKey&quot;,		l_GetNamedKey);
 	lua_register(L,&quot;GetKeyName&quot;,		l_GetKeyName);
 	lua_register(L,&quot;PollInput&quot;,			l_PollInput);
@@ -1384,7 +1577,7 @@
 	//lua_register(L,&quot;SoundPlayAmbient&quot;,				l_SoundPlayAmbient);
 	//lua_register(L,&quot;Server_SetMaxResyncsPerSecond&quot;,	l_Server_SetMaxResyncsP=
erSecond);
 	//lua_register(L,&quot;Server_GetMaxResyncsPerSecond&quot;,	l_Server_GetMaxResyncsP=
erSecond);
-	lua_register(L,&quot;Client_ShowOgreConfig&quot;,			l_Client_ShowOgreConfig);
+	lua_register(L,&quot;Client_ShowOgreConfig&quot;,			l_Client_ShowOgreConfig);
 	lua_register(L,&quot;Client_TakeScreenshot&quot;,			l_Client_TakeScreenshot);
 	lua_register(L,&quot;Client_TakeGridScreenshot&quot;,			l_Client_TakeGridScreenshot=
);
 	//lua_register(L,&quot;Client_SetCamera&quot;,				l_Client_SetCamera);
@@ -1407,7 +1600,8 @@
 	lua_register(L,&quot;Client_SetAmbientLight&quot;,		l_Client_SetAmbientLight);
 	lua_register(L,&quot;Client_ClearLights&quot;,			l_Client_ClearLights);
 	lua_register(L,&quot;Client_AddPointLight&quot;,			l_Client_AddPointLight);
-	lua_register(L,&quot;Client_AddDirectionalLight&quot;,	l_Client_AddDirectionalLight=
);
+	lua_register(L,&quot;Client_AddDirectionalLight&quot;,	l_Client_AddDirectionalLight=
);
+	lua_register(L,&quot;Client_DeleteLight&quot;,			l_Client_DeleteLight);
 	lua_register(L,&quot;Client_GetPhysStepTime&quot;,		l_Client_GetPhysStepTime);
 	lua_register(L,&quot;BuildTerrainEntity_Simple&quot;,		l_BuildTerrainEntity_Simple);
 	lua_register(L,&quot;BuildTerrainEntity_Shaded&quot;,		l_BuildTerrainEntity_Shaded);
@@ -1431,7 +1625,7 @@
 	lua_register(L,&quot;ClearBit&quot;,						l_ClearBit);
 	lua_register(L,&quot;Exit&quot;,							l_Exit);
 	lua_register(L,&quot;Crash&quot;,							l_Crash);
-	lua_register(L,&quot;CrashSegFault&quot;,					l_CrashSegFault);
+	lua_register(L,&quot;CrashSegFault&quot;,					l_CrashSegFault);
 	lua_register(L,&quot;DisplayNotice&quot;,					l_DisplayNotice);
 	lua_register(L,&quot;FatalErrorMessage&quot;,				l_FatalErrorMessage);
 	lua_register(L,&quot;ExportMesh&quot;,					l_ExportMesh);
@@ -1444,20 +1638,40 @@
 	lua_register(L,&quot;_TRACEBACK&quot;,					l_TRACEBACK);
 	lua_register(L,&quot;ProfileDumpCallCount&quot;,			l_ProfileDumpCallCount);
 	lua_register(L,&quot;OgreMemoryUsage&quot;,				l_OgreMemoryUsage);
-	lua_register(L,&quot;OgreMeshAvailable&quot;,				l_OgreMeshAvailable);
+	lua_register(L,&quot;OgreMeshAvailable&quot;,				l_OgreMeshAvailable);
 	lua_register(L,&quot;OgreMaterialNameKnown&quot;,			l_OgreMaterialNameKnown);
 	lua_register(L,&quot;OgreMaterialAvailable&quot;,			l_OgreMaterialAvailable);
 	lua_register(L,&quot;OgreTextureAvailable&quot;,			l_OgreTextureAvailable);
 	lua_register(L,&quot;OgreMeshTextures&quot;,				l_OgreMeshTextures);
-	lua_register(L,&quot;CreateGrannyHuedTexture&quot;,		l_CreateGrannyHuedTexture);
+	// some statistic stuff
+	lua_register(L,&quot;OgreLastFPS&quot;,				l_OgreLastFPS);
+	lua_register(L,&quot;OgreAvgFPS&quot;,				l_OgreAvgFPS);
+	lua_register(L,&quot;OgreBestFPS&quot;,				l_OgreBestFPS);
+	lua_register(L,&quot;OgreWorstFPS&quot;,				l_OgreWorstFPS);
+	lua_register(L,&quot;OgreBestFrameTime&quot;,			l_OgreBestFrameTime);
+	lua_register(L,&quot;OgreWorstFrameTime&quot;,			l_OgreWorstFrameTime);
+	lua_register(L,&quot;OgreTriangleCount&quot;,			l_OgreTriangleCount);
+	lua_register(L,&quot;OgreBatchCount&quot;,			l_OgreBatchCount);
+
+	lua_register(L,&quot;CreateGrannyHuedTexture&quot;,		l_CreateGrannyHuedTexture);
 	lua_register(L,&quot;HueMesh&quot;,						l_HueMesh);
 	lua_register(L,&quot;OgreAddCompositor&quot;,						l_OgreAddCompositor);
 	lua_register(L,&quot;OgreRemoveCompositor&quot;,						l_OgreRemoveCompositor);
 	lua_register(L,&quot;CreateLookupTableFromFile&quot;,			l_CreateLookupTableFromFile=
);
 	lua_register(L,&quot;Uo16Color2Rgb&quot;,			l_Uo16Color2Rgb);
-	// shadow stuff
-	lua_register(L,&quot;OgreShadowTechnique&quot;,				l_OgreShadowTechnique);
-	lua_register(L,&quot;OgreAmbientLight&quot;,				l_OgreAmbientLight);
+	// shadow stuff
+	lua_register(L,&quot;OgreSetShadowTextureFadeStart&quot;,						l_OgreSetShadowTextu=
reFadeStart);
+	lua_register(L,&quot;OgreSetShadowTextureFadeEnd&quot;,						l_OgreSetShadowTexture=
FadeEnd);
+	lua_register(L,&quot;OgreSetShadowDirLightTextureOffset&quot;,				l_OgreSetShadowDi=
rLightTextureOffset);
+	lua_register(L,&quot;OgreSetShadowFarDistance&quot;,							l_OgreSetShadowFarDistan=
ce);
+	lua_register(L,&quot;OgreSetShadowTextureSize&quot;,							l_OgreSetShadowTextureSi=
ze);
+	lua_register(L,&quot;OgreSetShadowTexturePixelFormat&quot;,					l_OgreSetShadowText=
urePixelFormat);
+	lua_register(L,&quot;OgrePixelFormatList&quot;,								l_OgrePixelFormatList);
+	lua_register(L,&quot;OgreSetShadowTextureSelfShadow&quot;,					l_OgreSetShadowTextu=
reSelfShadow);
+	lua_register(L,&quot;OgreSetShadowTextureCasterMaterial&quot;,				l_OgreSetShadowTe=
xtureCasterMaterial);
+	lua_register(L,&quot;OgreSetShadowTextureReceiverMaterial&quot;,				l_OgreSetShadow=
TextureReceiverMaterial);
+	lua_register(L,&quot;OgreShadowTechnique&quot;,				l_OgreShadowTechnique);
+	lua_register(L,&quot;OgreAmbientLight&quot;,				l_OgreAmbientLight);
 =

 	// file paths for init
 	const char* szLuaUDataPath =3D &quot;../data/lua/udata.lua&quot;;
@@ -1471,13 +1685,13 @@
 		exit(34);
 	}
 	myFileStream.close();
-	=

+
 	// load utils
 	int res;
 	res	=3D lua_dofile(L,szLuaUDataPath); // loads function used for register=
ing udatatypes
-	if (res) { =

-		MyCrash(&quot;error in udata script-initialisation\n&quot;); =

-		exit(44); =

+	if (res) {
+		MyCrash(&quot;error in udata script-initialisation\n&quot;);
+		exit(44);
 	}
 =

 	RegisterLuaXML(L);
@@ -1502,11 +1716,11 @@
 	LuaRegisterRadar(L);
 =

 	cInput::GetSingleton().RegisterListener(this,kListenerBinding_Keys);
-
-	res =3D lua_dofile(L,szLuaMainPath);
-	if (res) {
-		MyCrash(&quot;error in main script-initialisation\n&quot;); =

-		exit(-1); =

+
+	res =3D lua_dofile(L,szLuaMainPath);
+	if (res) {
+		MyCrash(&quot;error in main script-initialisation\n&quot;);
+		exit(-1);
 	}
 }
 =


Modified: branches/knut/src/sound_fmod.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/src/sound_fmod.cpp (original)
+++ branches/knut/src/sound_fmod.cpp Wed Aug  1 20:57:14 2007
@@ -1,8 +1,17 @@
 #include &quot;sound.h&quot;
-#include &quot;data.h&quot;
 =

 #include &lt;fmod.h&gt;
 #include &lt;fmod_errors.h&gt;
+
+// ################## global stuff #######################
+FMOD_RESULT result;
+
+void ERRCHECK(FMOD_RESULT result){
+	if (result !=3D FMOD_OK){
+		printf(&quot;FMOD error! (%d) %s\n&quot;, result, FMOD_ErrorString(result));
+	}
+}
+// #################################################
 =

 class cSoundSourceFmod;
 =

@@ -25,112 +34,99 @@
 	virtual cSoundSource *CreateSoundSource3D(const float x, const float y, c=
onst float z, const char *buffer, const int size, const int channels, const=
 int bitrate, const int frequency);
 	virtual void Step();
 =

-private:	=

+private:
+	/// stores current coordinates info fmod
+	void UpdatePositionAndVelocity();
+
 	/// number of max channels?
 	int miMaxChannels;
 	/// distance factor
 	float mfDistanceFactor;
 	/// listener position and velocity (extern distance WITH mfDistanceFactor=
 factor applied
-	float mlPos[3];
-	float mlVel[3];
+	FMOD_VECTOR mlPos;
+	FMOD_VECTOR mlVel;
+	=

+	/// fmod sound system
+	FMOD_SYSTEM *mpSystem;
 };
 =

 /// a sound source (no 3d, just omi) playing something
 class cSoundSourceFmod : public cSoundSource {
 public:
-	cSoundSourceFmod(cSoundSystemFmod *soundsystem, const char *filename) : m=
SoundSystem(soundsystem), miChannel(-1), mb3D(false), mpStream(0), mpSample=
(0) {
-		mpStream =3D FSOUND_Stream_Open(filename,FSOUND_2D | FSOUND_LOOP_OFF,0,0=
);
+	cSoundSourceFmod(cSoundSystemFmod *soundsystem, const char *filename) : m=
SoundSystem(soundsystem), mpChannel(0), mb3D(false), mpSound(0), mfMinDista=
nce(100.0f), mfMaxDistance(100000.0f) {
+		if(mSoundSystem &amp;&amp; mSoundSystem-&gt;mpSystem){
+			result =3D FMOD_System_CreateStream(mSoundSystem-&gt;mpSystem,filename, (F=
MOD_MODE)(FMOD_SOFTWARE | FMOD_2D), 0, &amp;mpSound);
+			ERRCHECK(result);
+			=

+			SetPosition(0.0f,0.0f,0.0f);
+			SetVelocity(0.0f,0.0f,0.0f);
+		}
+	}
+	cSoundSourceFmod(cSoundSystemFmod *soundsystem, const char *buffer, const=
 int size, const int channels, const int bitrate, const int frequency) : mS=
oundSystem(soundsystem), mpChannel(0), mb3D(false), mpSound(0), mfMinDistan=
ce(100.0f), mfMaxDistance(100000.0f) {
+		if(mSoundSystem &amp;&amp; mSoundSystem-&gt;mpSystem){
+			FMOD_CREATESOUNDEXINFO exinfo;
+			=

+			memset(&amp;exinfo, 0, sizeof(FMOD_CREATESOUNDEXINFO));
+			exinfo.cbsize =3D sizeof(FMOD_CREATESOUNDEXINFO);
+			exinfo.length =3D size;
+			exinfo.numchannels =3D channels;
+			exinfo.defaultfrequency =3D frequency;
+			=

+			switch(bitrate){
+				case 8:exinfo.format =3D FMOD_SOUND_FORMAT_PCM8;break;
+				case 16:exinfo.format =3D FMOD_SOUND_FORMAT_PCM16;break;
+				case 24:exinfo.format =3D FMOD_SOUND_FORMAT_PCM24;break;
+				case 32:exinfo.format =3D FMOD_SOUND_FORMAT_PCM32;break;
+			}
+			=

+			result =3D FMOD_System_CreateStream(mSoundSystem-&gt;mpSystem, buffer, (FM=
OD_MODE)(FMOD_OPENRAW | FMOD_OPENMEMORY | FMOD_SOFTWARE | FMOD_2D), &amp;exinfo=
, &amp;mpSound);
+			ERRCHECK(result);
+		}
+		=

 		SetPosition(0.0f,0.0f,0.0f);
 		SetVelocity(0.0f,0.0f,0.0f);
 	}
-	cSoundSourceFmod(cSoundSystemFmod *soundsystem, const char *buffer, const=
 int size, const int channels, const int bitrate, const int frequency) : mS=
oundSystem(soundsystem), miChannel(-1), mb3D(false), mpStream(0), mpSample(=
0) {
-		// calc mode flags and sample size
-		unsigned int mode =3D FSOUND_2D | FSOUND_SIGNED | FSOUND_LOOP_OFF;
-		int samplesize =3D 1;
-		=

-		if(channels =3D=3D 1){
-			mode |=3D FSOUND_MONO;
-		} else {
-			samplesize *=3D 2;
-			mode |=3D FSOUND_STEREO;
-		}
-		=

-		if(bitrate =3D=3D 8){
-			mode |=3D FSOUND_8BITS;
-		} else {
-			mode |=3D FSOUND_16BITS;
-			samplesize *=3D 2;
-		}
-		=

-		// create userbuffer fmod sample
-		mpSample =3D FSOUND_Sample_Alloc(FSOUND_FREE,size / samplesize,mode,freq=
uency,255,128,128);
-		if(mpSample){
-			// fill sample buffer
-			void *p1,*p2;
-			unsigned int l1,l2;
-			if(FSOUND_Sample_Lock(mpSample,0,size,&amp;p1,&amp;p2,&amp;l1,&amp;l2)){
-				memcpy(p1,buffer,mymin(l1,size));
-				FSOUND_Sample_Unlock(mpSample,p1,p2,l1,l2);
+
+	cSoundSourceFmod(cSoundSystemFmod *soundsystem, const float x, const floa=
t y, const float z, const char *filename) : mSoundSystem(soundsystem), mpCh=
annel(0), mb3D(true), mpSound(0), mfMinDistance(100.0f), mfMaxDistance(1000=
00.0f) {
+		if(mSoundSystem &amp;&amp; mSoundSystem-&gt;mpSystem){
+			result =3D FMOD_System_CreateStream(mSoundSystem-&gt;mpSystem, filename, (=
FMOD_MODE)(FMOD_SOFTWARE | FMOD_3D), 0, &amp;mpSound);
+			ERRCHECK(result);
+			=

+			SetPosition(x,y,z);
+			SetVelocity(0,0,0);
+		}
+	}
+
+	cSoundSourceFmod(cSoundSystemFmod *soundsystem, const float x, const floa=
t y, const float z, const char *buffer, const int size, const int channels,=
 const int bitrate, const int frequency) : mSoundSystem(soundsystem), mpCha=
nnel(0), mb3D(true), mpSound(0), mfMinDistance(100.0f), mfMaxDistance(10000=
0.0f) {
+		if(mSoundSystem &amp;&amp; mSoundSystem-&gt;mpSystem){
+			FMOD_CREATESOUNDEXINFO exinfo;
+			=

+			memset(&amp;exinfo, 0, sizeof(FMOD_CREATESOUNDEXINFO));
+			exinfo.cbsize =3D sizeof(FMOD_CREATESOUNDEXINFO);
+			exinfo.length =3D size;
+			exinfo.numchannels =3D channels;
+			exinfo.defaultfrequency =3D frequency;
+			=

+			switch(bitrate){
+				case 8:exinfo.format =3D FMOD_SOUND_FORMAT_PCM8;break;
+				case 16:exinfo.format =3D FMOD_SOUND_FORMAT_PCM16;break;
+				case 24:exinfo.format =3D FMOD_SOUND_FORMAT_PCM24;break;
+				case 32:exinfo.format =3D FMOD_SOUND_FORMAT_PCM32;break;
 			}
-		}
-		SetPosition(0.0f,0.0f,0.0f);
-		SetVelocity(0.0f,0.0f,0.0f);
-	}
-
-	cSoundSourceFmod(cSoundSystemFmod *soundsystem, const float x, const floa=
t y, const float z, const char *filename) : mSoundSystem(soundsystem), miCh=
annel(-1), mb3D(true), mpStream(0), mpSample(0) {
-		mpStream =3D FSOUND_Stream_Open(filename,FSOUND_LOOP_OFF | FSOUND_HW3D,0=
,0);
-		SetPosition(x,y,z);
-		SetVelocity(0,0,0);
-	}
-
-	cSoundSourceFmod(cSoundSystemFmod *soundsystem, const float x, const floa=
t y, const float z, const char *buffer, const int size, const int channels,=
 const int bitrate, const int frequency) : mSoundSystem(soundsystem), miCha=
nnel(-1), mb3D(true), mpStream(0), mpSample(0) {
-		// calc mode flags and sample size
-		printdebug(&quot;sound&quot;,&quot;cSoundSourceFmod(%f,%f,%f,%i,%i,%i,%i%,%i);\n&quot;,x,y,z=
,buffer,size,channels,bitrate,frequency);
-		unsigned int mode =3D FSOUND_SIGNED | FSOUND_LOOP_OFF | FSOUND_HW3D;
-
-		int samplesize =3D 1;
-		=

-		if(channels =3D=3D 1){
-			mode |=3D FSOUND_MONO;
-		} else {
-			samplesize *=3D 2;
-			mode |=3D FSOUND_STEREO;
-		}
-		=

-		if(bitrate =3D=3D 8){
-			mode |=3D FSOUND_8BITS;
-		} else {
-			mode |=3D FSOUND_16BITS;
-			samplesize *=3D 2;
-		}
-
-		//printf(&quot;samplesize =3D %i samples =3D %i\n&quot;,samplesize,size / samplesi=
ze);
-		=

-		// create userbuffer fmod sample
-		mpSample =3D FSOUND_Sample_Alloc(FSOUND_FREE,size / samplesize,mode,freq=
uency,255,128,128);
-		if(mpSample){
-			// fill sample buffer
-			void *p1,*p2;
-			unsigned int l1,l2;
-			if(FSOUND_Sample_Lock(mpSample,0,size,&amp;p1,&amp;p2,&amp;l1,&amp;l2)){
-				memcpy(p1,buffer,mymin(l1,size));
-				FSOUND_Sample_Unlock(mpSample,p1,p2,l1,l2);
-			}
-		}
+			=

+			result =3D FMOD_System_CreateStream(mSoundSystem-&gt;mpSystem, buffer, (FM=
OD_MODE)(FMOD_OPENRAW | FMOD_OPENMEMORY | FMOD_SOFTWARE | FMOD_3D), &amp;exinfo=
, &amp;mpSound);
+			ERRCHECK(result);
+		}
+		=

 		SetPosition(x,y,z);
 		SetVelocity(0.0f,0.0f,0.0f);
 	}
 =

 	virtual ~cSoundSourceFmod(){
-		if(mpSample){
-			// free usergenerated buffer
-			FSOUND_Sample_Free(mpSample);
-			mpSample =3D 0;
-		}
-		if(mpStream){
-			// free usergenerated buffer
-			FSOUND_Stream_Close(mpStream);
-			mpStream =3D 0;
+		if(mpSound){
+			// free buffer
+			FMOD_Sound_Release(mpSound);
+			mpSound =3D 0;
 		}
 	}
 =

@@ -138,19 +134,34 @@
 	virtual const bool Play(){
 		if(IsPlaying())return true;
 		if(IsPaused()){
-			// unhause sound
-			return FSOUND_SetPaused(miChannel,false);
+			// unpause sound
+			if(mpChannel){
+				result =3D FMOD_Channel_SetPaused(mpChannel,false);
+				ERRCHECK(result);
+			}
 		} else {
 			// start playing
-			miChannel =3D -1;
+			mpChannel =3D 0;
 			// alloc channel
-			if(mpStream)miChannel =3D FSOUND_Stream_Play(FSOUND_FREE,mpStream);
-			else if(mpSample)miChannel =3D FSOUND_PlaySound(FSOUND_FREE,mpSample);
-			// channel free?
-			//printf(&quot;PLAY @ %i\n&quot;,miChannel);
-			if(miChannel !=3D -1){
-				// set 3d position and velocity data
-				if(!FSOUND_3D_SetAttributes(miChannel,mlPos,mlVel))printf(&quot;ERROR set 3=
d data failed: %s\n&quot;, FMOD_ErrorString(FSOUND_GetError()));
+			if(mpSound &amp;&amp; mSoundSystem &amp;&amp; mSoundSystem-&gt;mpSystem){
+				result =3D FMOD_System_PlaySound(mSoundSystem-&gt;mpSystem, FMOD_CHANNEL_=
FREE, mpSound, true, &amp;mpChannel);
+				ERRCHECK(result);
+			}
+			=

+			// channel free and working?
+			if(mpChannel){
+				=

+				if(mb3D){
+					// set 3d position and velocity data
+					result =3D FMOD_Channel_Set3DAttributes(mpChannel, &amp;mlPos, &amp;mlVel);
+					ERRCHECK(result);
+					// set currently set minmax distances
+					SetMinMaxDistance(mfMinDistance,mfMaxDistance);
+				} =

+				=

+				result =3D FMOD_Channel_SetPaused(mpChannel,false);
+				ERRCHECK(result);
+				=

 				return true;
 			} else return false;
 		}
@@ -159,50 +170,79 @@
 =

 	/// is this source playing at the moment? (paused is playing, isplaying=
=3Dfalse =3D&gt; sound completly played or unplayable)
 	virtual const bool IsPlaying(){
-		if(miChannel =3D=3D -1)return false;
-		return FSOUND_IsPlaying(miChannel);
+		FMOD_BOOL b;
+		if(mpChannel =3D=3D 0)return false;
+		else {
+			FMOD_Channel_IsPlaying(mpChannel,&amp;b);
+			if(b)return true;
+			else return false;
+		}
 	}
 	/// is the sound currently paused
 	virtual const bool IsPaused(){
-		if(miChannel =3D=3D -1)return false;
-		return FSOUND_GetPaused(miChannel);
+		FMOD_BOOL b;
+		if(mpChannel =3D=3D 0)return false;
+		else {
+			FMOD_Channel_GetPaused(mpChannel,&amp;b);
+			if(b)return true;
+			else return false;
+		}
 	}
 	=

 	/// stops playing, play will start at the beginning of the sound =

 	virtual void Stop(){
-		if(miChannel =3D=3D -1)return;
-		FSOUND_StopSound(miChannel);
-		miChannel =3D -1;
+		if(mpChannel =3D=3D 0)return;
+		=

+		result =3D FMOD_Channel_Stop(mpChannel);
+		ERRCHECK(result);
 	}
 =

 	/// pause playing, =

 	virtual void Pause(){
-		if(miChannel =3D=3D -1)return;
-		FSOUND_SetPaused(miChannel,true);
+		if(mpChannel =3D=3D 0)return;
+		=

+		result =3D FMOD_Channel_SetPaused(mpChannel, true);
+		ERRCHECK(result);
 	}
 =

 	/// sets/gets the source volume, from 0.0 (silent) to 1.0 (max)
 	virtual void SetVolume(const float volume){
-		if(miChannel =3D=3D -1)return;
-		FSOUND_SetVolume(miChannel,char(volume * 255));
+		if(mpChannel =3D=3D 0)return;
+		=

+		result =3D FMOD_Channel_SetVolume(mpChannel, volume);
+		ERRCHECK(result);
 	}
 	=

 	virtual const float GetVolume(){
-		if(miChannel =3D=3D -1)return 0;
-		else return float(FSOUND_GetVolume(miChannel)) / 255.0f;
+		float b;
+		if(mpChannel =3D=3D 0)return 0.0f;
+		else {
+			FMOD_Channel_GetVolume(mpChannel, &amp;b);
+			return b;
+		}
 	}
 =

 	/// sets/gets the source min/max distance
 	virtual void SetMinMaxDistance(const float min, const float max){
-		if(miChannel =3D=3D -1 || !Is3D())return;
-		FSOUND_3D_SetMinMaxDistance(miChannel,min * mSoundSystem-&gt;mfDistanceFact=
or,max * mSoundSystem-&gt;mfDistanceFactor);
+		mfMinDistance =3D min;
+		mfMaxDistance =3D max;
+
+		if(mpChannel =3D=3D 0 || !Is3D())return;
+		=

+		result =3D FMOD_Channel_Set3DMinMaxDistance(mpChannel, min * mSoundSyste=
m-&gt;mfDistanceFactor,max * mSoundSystem-&gt;mfDistanceFactor);
+		ERRCHECK(result);
 	}
 	=

 	virtual void GetMinMaxDistance(float &amp;min, float &amp;max){
-		if(miChannel =3D=3D -1 || !Is3D())return;
-		FSOUND_3D_GetMinMaxDistance(miChannel,&amp;min,&amp;max);
-		min /=3D mSoundSystem-&gt;mfDistanceFactor;
-		max /=3D mSoundSystem-&gt;mfDistanceFactor;
+		if(mpChannel =3D=3D 0 || !Is3D())return;
+		//result =3D FMOD_Channel_Get3DMinMaxDistance(mpChannel, &amp;min,&amp;max);
+		//ERRCHECK(result);
+			=

+		min =3D mfMinDistance;
+		max =3D mfMaxDistance;
+			=

+		//min /=3D mSoundSystem-&gt;mfDistanceFactor;
+		//max /=3D mSoundSystem-&gt;mfDistanceFactor;
 	}
 =

 	=

@@ -214,102 +254,136 @@
 	/// sets position of the soundsource
 	virtual void SetPosition(const float x, const float y, const float z){
 		if(!Is3D())return;
-		mlPos[0] =3D x * mSoundSystem-&gt;mfDistanceFactor;
-		mlPos[1] =3D y * mSoundSystem-&gt;mfDistanceFactor;
-		mlPos[2] =3D z * mSoundSystem-&gt;mfDistanceFactor;
-		if(miChannel =3D=3D -1)return;
-		if(!FSOUND_3D_SetAttributes(miChannel,mlPos,0))printf(&quot;ERROR SetAttribut=
es: %s\n&quot;, FMOD_ErrorString(FSOUND_GetError()));
+		mlPos.x =3D x * mSoundSystem-&gt;mfDistanceFactor;
+		mlPos.y =3D y * mSoundSystem-&gt;mfDistanceFactor;
+		mlPos.z =3D z * mSoundSystem-&gt;mfDistanceFactor;
+		if(mpChannel =3D=3D 0)return;
+		=

+		result =3D FMOD_Channel_Set3DAttributes(mpChannel, &amp;mlPos, &amp;mlVel);
+		ERRCHECK(result);
 	}
 =

 	/// sets velocity of the soundsource
 	virtual void SetVelocity(const float x, const float y, const float z){
 		if(!Is3D())return;
-		mlVel[0] =3D x * mSoundSystem-&gt;mfDistanceFactor;
-		mlVel[1] =3D y * mSoundSystem-&gt;mfDistanceFactor;
-		mlVel[2] =3D z * mSoundSystem-&gt;mfDistanceFactor;
-		if(miChannel =3D=3D -1)return;
-		if(!FSOUND_3D_SetAttributes(miChannel,mlVel,0))printf(&quot;ERROR SetAttribut=
es: %s\n&quot;, FMOD_ErrorString(FSOUND_GetError()));
+		mlVel.x =3D x * mSoundSystem-&gt;mfDistanceFactor;
+		mlVel.y =3D y * mSoundSystem-&gt;mfDistanceFactor;
+		mlVel.z =3D z * mSoundSystem-&gt;mfDistanceFactor;
+		if(mpChannel =3D=3D 0)return;
+
+		result =3D FMOD_Channel_Set3DAttributes(mpChannel, &amp;mlPos, &amp;mlVel);
+		ERRCHECK(result);
 	}
 =

 	/// gets position of the soundsource
 	virtual void GetPosition(float &amp;x, float &amp;y, float &amp;z){
 		if(!Is3D())return;
-		x =3D mlPos[0] / mSoundSystem-&gt;mfDistanceFactor;
-		y =3D mlPos[1] / mSoundSystem-&gt;mfDistanceFactor;
-		z =3D mlPos[2] / mSoundSystem-&gt;mfDistanceFactor;
+		x =3D mlPos.x / mSoundSystem-&gt;mfDistanceFactor;
+		y =3D mlPos.y / mSoundSystem-&gt;mfDistanceFactor;
+		z =3D mlPos.z / mSoundSystem-&gt;mfDistanceFactor;
 	}
 	=

 	/// gets velocity of the soundsource
 	virtual void GetVelocity(float &amp;x, float &amp;y, float &amp;z){
 		if(!Is3D())return;
-		x =3D mlVel[0] / mSoundSystem-&gt;mfDistanceFactor;
-		y =3D mlVel[1] / mSoundSystem-&gt;mfDistanceFactor;
-		z =3D mlVel[2] / mSoundSystem-&gt;mfDistanceFactor;
-	}
-
-	/// channel used for playback, -1 is no channel
-	int miChannel;
-	/// sample storing the sound stuff
-	FSOUND_SAMPLE *mpSample;
-	/// stream used in this source, use either sample or stream, but never bo=
th
-	FSOUND_STREAM *mpStream;
+		x =3D mlVel.x / mSoundSystem-&gt;mfDistanceFactor;
+		y =3D mlVel.y / mSoundSystem-&gt;mfDistanceFactor;
+		z =3D mlVel.z / mSoundSystem-&gt;mfDistanceFactor;
+	}
+
+private:
+	FMOD_SOUND     *mpSound;
+	FMOD_CHANNEL   *mpChannel;
+	=

 	/// sound system this source belongs to
 	cSoundSystemFmod *mSoundSystem;
 	/// is 3d?
 	bool mb3D;
 	=

+	/// min,max distance for 3d sound (unchanged as given from the user)
+	float mfMinDistance,mfMaxDistance;
+	=

 	/// sound position and velocity
-	float mlPos[3];
-	float mlVel[3];
+	FMOD_VECTOR mlPos;
+	FMOD_VECTOR mlVel;
 };
 =

 // -----------------------------------------------------------------------=
-------------------
 // -----------------------------------------------------------------------=
-------------------
 =

-cSoundSystemFmod::cSoundSystemFmod(const int frequency, const int maxchann=
els) : miMaxChannels(maxchannels), mfDistanceFactor(1.0f) {
-	FSOUND_SetMixer(FSOUND_MIXER_AUTODETECT);
-	FSOUND_SetMinHardwareChannels(maxchannels);
-	FSOUND_Init(frequency,maxchannels,0);
+cSoundSystemFmod::cSoundSystemFmod(const int frequency, const int maxchann=
els) : mpSystem(0), miMaxChannels(maxchannels), mfDistanceFactor(1.0f) {
+	result =3D FMOD_System_Create(&amp;mpSystem);
+	ERRCHECK(result);
+
+	if(mpSystem){
+		unsigned int version;
+		result =3D FMOD_System_GetVersion(mpSystem, &amp;version);
+		ERRCHECK(result);
+
+		if (version &lt; FMOD_VERSION){
+			printf(&quot;Error!  You are using an old version of FMOD %08x.  This progra=
m requires %08x\n&quot;, version, FMOD_VERSION);
+		}
+
+		//result =3D FMOD_System_SetDriver(mpSystem,0);
+		//ERRCHECK(result);
+		result =3D FMOD_System_Init(mpSystem, miMaxChannels, FMOD_INIT_NORMAL, 0=
);
+		ERRCHECK(result);
+	}
+
 	SetListenerPosition(0.0f,0.0f,0.0f);
 	SetListenerVelocity(0.0f,0.0f,0.0f);
 }
 =

 cSoundSystemFmod::~cSoundSystemFmod(){
-	FSOUND_Close();
-}
+	if(mpSystem){
+		result =3D FMOD_System_Close(mpSystem);
+		ERRCHECK(result);
+		result =3D FMOD_System_Release(mpSystem);
+		ERRCHECK(result);
+	}
+}
+
+
+void cSoundSystemFmod::UpdatePositionAndVelocity(){
+	if(mpSystem){
+		result =3D FMOD_System_Set3DListenerAttributes(mpSystem, 0, &amp;mlPos, &amp;mlV=
el, 0, 0);//&amp;forward, &amp;up);
+		ERRCHECK(result);
+	}
+}
+
 =

 /// sets position of the listener
 void cSoundSystemFmod::SetListenerPosition(const float x, const float y, c=
onst float z){
-	mlPos[0] =3D x * mfDistanceFactor;
-	mlPos[1] =3D y * mfDistanceFactor;
-	mlPos[2] =3D z * mfDistanceFactor;
-	FSOUND_3D_Listener_SetAttributes(mlPos,mlVel,1.0f,0,0,1.0f,0,0);
+	mlPos.x =3D x * mfDistanceFactor;
+	mlPos.y =3D y * mfDistanceFactor;
+	mlPos.z =3D z * mfDistanceFactor;
+
+	UpdatePositionAndVelocity();
 }
 =

 /// sets velocity of the listener
 void cSoundSystemFmod::SetListenerVelocity(const float x, const float y, c=
onst float z){
-	mlVel[0] =3D x * mfDistanceFactor;
-	mlVel[1] =3D y * mfDistanceFactor;
-	mlVel[2] =3D z * mfDistanceFactor;
-	FSOUND_3D_Listener_SetAttributes(mlPos,mlVel,1.0f,0,0,1.0f,0,0);
+	mlVel.x =3D x * mfDistanceFactor;
+	mlVel.y =3D y * mfDistanceFactor;
+	mlVel.z =3D z * mfDistanceFactor;
+
+	UpdatePositionAndVelocity();
 }
 =

 /// gets position of the listener
 void cSoundSystemFmod::GetListenerPosition(float &amp;x, float &amp;y, float &amp;z){
 	//float v[3];
-	//FSOUND_3D_Listener_GetAttributes(v,0,0,0,0,0,0,0);
-	x =3D mlPos[0] / mfDistanceFactor;
-	y =3D mlPos[1] / mfDistanceFactor;
-	z =3D mlPos[2] / mfDistanceFactor;
+	x =3D mlPos.x / mfDistanceFactor;
+	y =3D mlPos.y / mfDistanceFactor;
+	z =3D mlPos.z / mfDistanceFactor;
 }
 =

 /// gets velocity of the listener
 void cSoundSystemFmod::GetListenerVelocity(float &amp;x, float &amp;y, float &amp;z){
 	//float v[3];
-	//FSOUND_3D_Listener_GetAttributes(0,v,0,0,0,0,0,0);
-	x =3D mlVel[0] / mfDistanceFactor;
-	y =3D mlVel[1] / mfDistanceFactor;
-	z =3D mlVel[2] / mfDistanceFactor;
+	x =3D mlVel.x / mfDistanceFactor;
+	y =3D mlVel.y / mfDistanceFactor;
+	z =3D mlVel.z / mfDistanceFactor;
 }
 =

 /// sets/gets the sound system volume, from 0.0 (silent) to 1.0 (max)
@@ -317,7 +391,20 @@
 const float cSoundSystemFmod::GetVolume(){return 1.0f;}
 =

 /// factor to multiply every coordinate with to adjust local space to musi=
c space
-void cSoundSystemFmod::SetDistanceFactor(const float s){mfDistanceFactor =
=3D s;}
+/// IMPORTANT call this prior to sound creation !!!!!!!
+void cSoundSystemFmod::SetDistanceFactor(const float s){
+	// adjust the current coordinates
+	for(int i =3D 0;i &lt; 3;++i){
+		mlPos.x =3D mlPos.x / mfDistanceFactor * s;
+		mlPos.y =3D mlPos.y / mfDistanceFactor * s;
+		mlPos.z =3D mlPos.z / mfDistanceFactor * s;
+		mlVel.x =3D mlVel.x / mfDistanceFactor * s;
+		mlVel.y =3D mlVel.y / mfDistanceFactor * s;
+		mlVel.z =3D mlVel.z / mfDistanceFactor * s;
+	}
+
+	mfDistanceFactor =3D s;	=

+}
 const float cSoundSystemFmod::GetDistanceFactor(){return mfDistanceFactor;}
 =

 /// creates 2d sound from file or null on error
@@ -339,13 +426,13 @@
 }
 =

 /// stepper, if the underlying sound system needs this
-void cSoundSystemFmod::Step(){FSOUND_Update();}
+void cSoundSystemFmod::Step(){if(mpSystem)FMOD_System_Update(mpSystem);}
 =

 // -----------------------------------------------------------------------=
-------------------
 // -----------------------------------------------------------------------=
-------------------
 	=

 cSoundSystem *CreateSoundSystemFmod(const int frequency){
 	// TODO dont need frequency????
-	int channels =3D 16;
+	int channels =3D 64;
 	return new cSoundSystemFmod(frequency,channels);
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000130.html">[Iris-commit] [IRIS] r1315 - in /branches/knut/include: ColourClipTextOverlay.h builder.h data.h gfx3D.h grannyparser.h meshshape.h net.h ogrewrapper.h prefix.h spritemanager.h
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#141">[ date ]</a>
              <a href="thread.html#141">[ thread ]</a>
              <a href="subject.html#141">[ subject ]</a>
              <a href="author.html#141">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/iris-commit">More information about the Iris-commit
mailing list</a><br>
</body></html>
