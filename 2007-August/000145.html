<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Iris-commit] [IRIS] r1329 - in /branches/knut/data/lua: ./ gui/	net/ obj/
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/iris-commit/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:iris-commit%40lists.berlios.de?Subject=Re%3A%20%5BIris-commit%5D%20%5BIRIS%5D%20r1329%20-%20in%20/branches/knut/data/lua%3A%20./%20gui/%0A%09net/%20obj/&In-Reply-To=%3C20070802151226.AB966B140B5%40localhost.localdomain%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000140.html">
   <LINK REL="Next"  HREF="000146.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Iris-commit] [IRIS] r1329 - in /branches/knut/data/lua: ./ gui/	net/ obj/</H1>
    <B>no-reply at zwischenwelt.org</B> 
    <A HREF="mailto:iris-commit%40lists.berlios.de?Subject=Re%3A%20%5BIris-commit%5D%20%5BIRIS%5D%20r1329%20-%20in%20/branches/knut/data/lua%3A%20./%20gui/%0A%09net/%20obj/&In-Reply-To=%3C20070802151226.AB966B140B5%40localhost.localdomain%3E"
       TITLE="[Iris-commit] [IRIS] r1329 - in /branches/knut/data/lua: ./ gui/	net/ obj/">no-reply at zwischenwelt.org
       </A><BR>
    <I>Thu Aug  2 17:12:25 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000140.html">[Iris-commit] [IRIS] r1328 - in /trunk/data/lua: gui/gui.main.lua gui/gui.status.lua lib.charcreate.lua lib.debug.lua lib.guimaker.lua lib.listener.lua lib.loading.lua lib.skill.lua lib.test.lua lib.util.lua net/net.multi.lua net/net.uodragdrop.lua
</A></li>
        <LI>Next message: <A HREF="000146.html">[Iris-commit] [IRIS] r1330 - in /trunk/data/lua: ./ gui/ net/ obj/
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#145">[ date ]</a>
              <a href="thread.html#145">[ thread ]</a>
              <a href="subject.html#145">[ subject ]</a>
              <a href="author.html#145">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ghoulsblade
Date: Thu Aug  2 17:12:24 2007
New Revision: 1329

Log:
syncing with trunk

Modified:
    branches/knut/data/lua/gui/gui.gumpmanager.lua
    branches/knut/data/lua/lib.3d.combat.lua
    branches/knut/data/lua/lib.3d.map.lua
    branches/knut/data/lua/lib.3d.mobileanim.lua
    branches/knut/data/lua/lib.3d.mousepick.lua
    branches/knut/data/lua/lib.3d.renderer.lua
    branches/knut/data/lua/lib.debugmenu.lua
    branches/knut/data/lua/lib.devtool.lua
    branches/knut/data/lua/lib.fallback.lua
    branches/knut/data/lua/lib.modelanim.lua
    branches/knut/data/lua/lib.models.lua
    branches/knut/data/lua/lib.mousepick.lua
    branches/knut/data/lua/lib.protocol.lua
    branches/knut/data/lua/lib.walking2.lua
    branches/knut/data/lua/main.lua
    branches/knut/data/lua/net.login.lua
    branches/knut/data/lua/net.other.lua
    branches/knut/data/lua/net.trade.lua
    branches/knut/data/lua/net.uodragdrop.lua
    branches/knut/data/lua/net.walk.lua
    branches/knut/data/lua/net/net.main.lua
    branches/knut/data/lua/net/net.mobile.lua
    branches/knut/data/lua/net/net.object.lua
    branches/knut/data/lua/obj/obj.dynamic.lua
    branches/knut/data/lua/obj/obj.main.lua
    branches/knut/data/lua/obj/obj.player.lua

Modified: branches/knut/data/lua/gui/gui.gumpmanager.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/gui/gui.gumpmanager.lua (original)
+++ branches/knut/data/lua/gui/gui.gumpmanager.lua Thu Aug  2 17:12:24 2007
@@ -804,51 +804,6 @@
 	return textfield
 end
 =

--- TODO : add this everywhere
--- TODO : Add sepearate FILTER : for several Clientside GFX manipulation (=
Game Pieces &amp; Gold,Silver,...)
-function ApplyArtidStackManipulation (item)
-	item.baseartid =3D item.artid
-	=

-	-- from varan
-	-- gold
-	if (item.baseartid =3D=3D hex2num(&quot;0xEED&quot;) and item.amount &gt;=3D 2) then i=
tem.artid =3D hex2num(&quot;0xEEE&quot;) end
-	if (item.baseartid =3D=3D hex2num(&quot;0xEED&quot;) and item.amount &gt;=3D 6) then i=
tem.artid =3D hex2num(&quot;0xEEF&quot;) end
-	-- gold
-	if (item.baseartid =3D=3D hex2num(&quot;0xEEA&quot;) and item.amount &gt;=3D 2) then i=
tem.artid =3D hex2num(&quot;0xEEB&quot;) end
-	if (item.baseartid =3D=3D hex2num(&quot;0xEEA&quot;) and item.amount &gt;=3D 6) then i=
tem.artid =3D hex2num(&quot;0xEEC&quot;) end
-	-- Silver
-	if (item.baseartid =3D=3D hex2num(&quot;0xEF0&quot;) and item.amount &gt;=3D 2) then i=
tem.artid =3D hex2num(&quot;0xEF1&quot;) end
-	if (item.baseartid =3D=3D hex2num(&quot;0xEF0&quot;) and item.amount &gt;=3D 6) then i=
tem.artid =3D hex2num(&quot;0xEF2&quot;) end
-	-- cannonball
-	if (item.baseartid =3D=3D hex2num(&quot;0xE73&quot;) and item.amount &gt;=3D 4) then i=
tem.artid =3D hex2num(&quot;0xE74&quot;) end
-
-	--TODO : if not in this list, and amount &gt; 0 : draw the graphic 2 times
-	--for example: if (item.baseartid =3D=3D hex2num(&quot;0xE73&quot;) and item.amount=
 &gt; 0) then item.artid =3D hex2num(&quot;0xE74&quot;) item.drawcount=3D2 end
-
-	-- ART -&gt; GUMP
-	-- white backgammon game piece
-	if (item.baseartid =3D=3D hex2num(&quot;0x3584&quot;)) then item.artid =3D hex2num(=
&quot;0x91B&quot;) item.usegump=3Dtrue end
-	-- brown backgammon game piece
-	if (item.baseartid =3D=3D hex2num(&quot;0x358b&quot;)) then item.artid =3D hex2num(=
&quot;0x922&quot;) item.usegump=3Dtrue end
-	-- brown chess pieces
-	if (item.baseartid =3D=3D hex2num(&quot;0x3590&quot;)) then item.artid =3D hex2num(=
&quot;0x927&quot;) item.yloc=3Ditem.yloc-20 item.usegump=3Dtrue end
-	if (item.baseartid =3D=3D hex2num(&quot;0x358d&quot;)) then item.artid =3D hex2num(=
&quot;0x924&quot;) item.yloc=3Ditem.yloc-20 item.usegump=3Dtrue end
-	if (item.baseartid =3D=3D hex2num(&quot;0x358f&quot;)) then item.artid =3D hex2num(=
&quot;0x926&quot;) item.yloc=3Ditem.yloc-20 item.usegump=3Dtrue end
-	if (item.baseartid =3D=3D hex2num(&quot;0x358c&quot;)) then item.artid =3D hex2num(=
&quot;0x923&quot;) item.yloc=3Ditem.yloc-20 item.usegump=3Dtrue end
-	if (item.baseartid =3D=3D hex2num(&quot;0x3591&quot;)) then item.artid =3D hex2num(=
&quot;0x928&quot;) item.yloc=3Ditem.yloc-20 item.usegump=3Dtrue end
-	if (item.baseartid =3D=3D hex2num(&quot;0x358e&quot;)) then item.artid =3D hex2num(=
&quot;0x925&quot;) item.yloc=3Ditem.yloc-20 item.usegump=3Dtrue end
-	-- white chess pieces
-	if (item.baseartid =3D=3D hex2num(&quot;0x3589&quot;)) then item.artid =3D hex2num(=
&quot;0x920&quot;) item.yloc=3Ditem.yloc-20 item.usegump=3Dtrue end
-	if (item.baseartid =3D=3D hex2num(&quot;0x3586&quot;)) then item.artid =3D hex2num(=
&quot;0x91D&quot;) item.yloc=3Ditem.yloc-20 item.usegump=3Dtrue end
-	if (item.baseartid =3D=3D hex2num(&quot;0x3588&quot;)) then item.artid =3D hex2num(=
&quot;0x91F&quot;) item.yloc=3Ditem.yloc-20 item.usegump=3Dtrue end
-	if (item.baseartid =3D=3D hex2num(&quot;0x3585&quot;)) then item.artid =3D hex2num(=
&quot;0x91C&quot;) item.yloc=3Ditem.yloc-20 item.usegump=3Dtrue end
-	if (item.baseartid =3D=3D hex2num(&quot;0x358a&quot;)) then item.artid =3D hex2num(=
&quot;0x921&quot;) item.yloc=3Ditem.yloc-20 item.usegump=3Dtrue end
-	if (item.baseartid =3D=3D hex2num(&quot;0x3587&quot;)) then item.artid =3D hex2num(=
&quot;0x91E&quot;) item.yloc=3Ditem.yloc-20 item.usegump=3Dtrue end
-
-	-- just for testing, remove me
-	--if (item.artid_addstack ~=3D 0) then print(&quot;unexpected item.artid_addst=
ack&quot;,item.artid_addstack) Crash() end
-end
-
 function gGumpmanager._GumpAddImage( gump, x, y, id, hue, page )
 	local material		=3D GetGumpMat( id, hue )
 	local width, height	=3D GetGumpSize( id )

Modified: branches/knut/data/lua/lib.3d.combat.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.3d.combat.lua (original)
+++ branches/knut/data/lua/lib.3d.combat.lua Thu Aug  2 17:12:24 2007
@@ -39,7 +39,7 @@
 =

 -- helper to plop hp adds and damage
 function Renderer3D:NotifyHPChange (serial, oldhp, newhp)
-	local mobile =3D gObjectList[serial]
+	local mobile =3D GetMobile(serial)
 	if mobile and oldhp and newhp then
 		local r,g,b =3D 0.0, 0.0, 0.0
 		-- hp change, d&lt;0 means damage, d&gt;0 hp gain

Modified: branches/knut/data/lua/lib.3d.map.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.3d.map.lua (original)
+++ branches/knut/data/lua/lib.3d.map.lua Thu Aug  2 17:12:24 2007
@@ -245,12 +245,7 @@
 =

 function Renderer3D:UpdateStaticVisibility	(entity) =

 	if (entity and entity.gfx and entity.gfx.billboard) then
-		-- evil fix
-		if (entity.zloc) then
-			entity.gfx.billboard:SetVisible(self:IsZLayerVisible(entity.zloc))
-		else
-			entity.gfx.billboard:SetVisible(self:IsZLayerVisible(entity.z))
-		end
+		entity.gfx.billboard:SetVisible(self:IsZLayerVisible(entity.zloc))
 	end
 end
 =

@@ -262,13 +257,13 @@
 		end
 	elseif (dynamic.gfx) then
 		-- normal item
-		dynamic.gfx:SetVisible(self:IsZLayerVisible(dynamic.z))
-		if (dynamic.gfx.billboard) then dynamic.gfx.billboard:SetVisible(self:Is=
ZLayerVisible(dynamic.z)) end
+		dynamic.gfx:SetVisible(self:IsZLayerVisible(dynamic.zloc))
+		if (dynamic.gfx.billboard) then dynamic.gfx.billboard:SetVisible(self:Is=
ZLayerVisible(dynamic.zloc)) end
 	end
 end
 =

 function Renderer3D:UpdateMobileVisibility (mobile) =

-	self:MobileSetVisible(mobile,self:IsZLayerVisible(mobile.z))
+	self:MobileSetVisible(mobile,self:IsZLayerVisible(mobile.zloc))
 end
 =

 -- TODO: blend out mounts
@@ -307,14 +302,11 @@
 		end
 		=

 		-- check dynamics for multis to detect house roofs and stuff like this		=

-		for k,object in pairs(gObjectList) do =

-			if (object.isdynamic) then
-				local dynamic =3D object
-				if (dynamic.lMultiChildGfx) then
-					for k,child in pairs(dynamic.lMultiChildGfx) do
-						if (x =3D=3D dynamic.x+child.xloc and y =3D=3D dynamic.y+child.yloc =
and dynamic.z+child.zloc &gt; playerheadpos) then
-							playerIsInside =3D true =

-						end	=

+		for k,dynamic in pairs(GetDynamicList()) do
+			if (dynamic.lMultiChildGfx) then
+				for k,child in pairs(dynamic.lMultiChildGfx) do
+					if (x =3D=3D dynamic.xloc+child.xloc and y =3D=3D dynamic.yloc+child.=
yloc and dynamic.zloc+child.zloc &gt; playerheadpos) then
+						playerIsInside =3D true
 					end
 				end
 			end
@@ -356,11 +348,10 @@
 			end
 		end
 		=

-		-- update mobiles abd dynamics
-		for k,object in pairs(gObjectList) do
-			if (object.isdynamic) then self:UpdateDynamicVisibility(object) end
-			if (object.ismobile) then self:UpdateMobileVisibility(object) end
-		end
+		-- update dynamics
+		for k,dynamic in pairs(GetDynamicList()) do self:UpdateDynamicVisibility=
(dynamic) end
+		-- update mobiles
+		for k,mobile in pairs(GetMobileList()) do self:UpdateMobileVisibility(mo=
bile) end
 	end
 end
 =


Modified: branches/knut/data/lua/lib.3d.mobileanim.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.3d.mobileanim.lua (original)
+++ branches/knut/data/lua/lib.3d.mobileanim.lua Thu Aug  2 17:12:24 2007
@@ -40,7 +40,7 @@
 =

 =

 function Renderer3D:MobileStartServerSideAnim (anim) =

-	local mobile =3D gObjectList[anim.mobileserial]	=

+	local mobile =3D GetMobile(anim.mobileserial)
 	if (not mobile) then return end
 	=

 	anim.repeatcount =3D (anim.m_repeatFlag =3D=3D 0) and 1 or (1 + anim.m_re=
peat) -- here -1 for infinite
@@ -48,6 +48,8 @@
 	MobileStartAnim(mobile,mobile.modelparts,anim.m_animation,bDoLoop)
 	mobile.lastserveranim =3D anim
 	mobile.lastclientanim =3D nil
+	--mobile.dir =3D anim.m_direction -- this is wrong : runuo sends (short) =
frameCount  =

+	UpdateMobile(mobile) -- if dir changed
 	-- todo : remaining anim options (m_animForward, m_frameDelay)
 end
 =

@@ -55,11 +57,11 @@
 function Renderer3D:MobileStartClientSideAnim (mobile)
 	if (not mobile.equipment) then return end
 	mobile.animinit =3D true
-	local bodyid =3D MobileArtId2BodyId(mobile.body)
+	local bodyid =3D MobileArtId2BodyId(mobile.artid)
 	=

 	-- detect animation modifiers : staff, mount=3Dhorse, combat
-	local mount		=3D mobile:getequipment(kLayer_Mount)
-	local twohand	=3D mobile:getequipment(kLayer_TwoHanded) -- staff
+	local mount		=3D GetMobileEquipmentItem(mobile,kLayer_Mount)
+	local twohand	=3D GetMobileEquipmentItem(mobile,kLayer_TwoHanded) -- staff
 	local bHasStaff =3D twohand and BitwiseAND(GetStaticTileTypeFlags(twohand=
.artid) or 0,kTileDataFlag_Weapon) ~=3D 0
 	local bWarMode 	=3D BitwiseAND(mobile.flag,kMobileFlag_WarMode) ~=3D 0 --=
 combat
 	local bRunning 	=3D mobile.walksmooth_moving and (BitwiseAND(mobile.dir,k=
WalkFlag_Run) ~=3D 0)
@@ -145,9 +147,9 @@
 	-- handles clientside anim stuff together with walksmooth to detect run, =
turn etc efficiently
 	=

 	-- walksmooth
-	if (mobile.x ~=3D mobile.gfx3d_walksmooth_last_xloc or
-		mobile.y ~=3D mobile.gfx3d_walksmooth_last_yloc or
-		mobile.z ~=3D mobile.gfx3d_walksmooth_last_zloc or
+	if (mobile.xloc ~=3D mobile.gfx3d_walksmooth_last_xloc or
+		mobile.yloc ~=3D mobile.gfx3d_walksmooth_last_yloc or
+		mobile.zloc ~=3D mobile.gfx3d_walksmooth_last_zloc or
 		mobile.dir  ~=3D mobile.gfx3d_walksmooth_last_dir) then =

 		=

 		mobile.gfx3d_walksmooth_prelast_xloc =3D mobile.gfx3d_walksmooth_last_xl=
oc
@@ -156,9 +158,9 @@
 		mobile.gfx3d_walksmooth_prelast_dir  =3D mobile.gfx3d_walksmooth_last_dir
 		mobile.gfx3d_walksmooth_prelast_time =3D mobile.gfx3d_walksmooth_last_ti=
me
 		=

-		mobile.gfx3d_walksmooth_last_xloc =3D mobile.x
-		mobile.gfx3d_walksmooth_last_yloc =3D mobile.y
-		mobile.gfx3d_walksmooth_last_zloc =3D mobile.z
+		mobile.gfx3d_walksmooth_last_xloc =3D mobile.xloc
+		mobile.gfx3d_walksmooth_last_yloc =3D mobile.yloc
+		mobile.gfx3d_walksmooth_last_zloc =3D mobile.zloc
 		mobile.gfx3d_walksmooth_last_dir  =3D mobile.dir =

 		mobile.gfx3d_walksmooth_last_time =3D gMyTicks
 		local timediff =3D mobile.gfx3d_walksmooth_last_time - (mobile.gfx3d_wal=
ksmooth_prelast_time or 0)
@@ -262,7 +264,7 @@
 end
 =

 function Renderer3D:SetSimpleMobilePos (mobile)
-	local x,y,z =3D Renderer3D:UOPosToLocal(mobile.x,mobile.y,mobile.z * 0.1)
+	local x,y,z =3D Renderer3D:UOPosToLocal(mobile.xloc,mobile.yloc,mobile.zl=
oc * 0.1)
 	local ang_in_degrees =3D (mobile.dir + 0) * 45.0
 	local qw,qx,qy,qz =3D Quaternion.fromAngleAxis(- gfDeg2Rad * ang_in_degre=
es,0,0,1)
 	Renderer3D:UpdateMobilePos(mobile,x,y,z,qw,qx,qy,qz)

Modified: branches/knut/data/lua/lib.3d.mousepick.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.3d.mousepick.lua (original)
+++ branches/knut/data/lua/lib.3d.mousepick.lua Thu Aug  2 17:12:24 2007
@@ -151,82 +151,76 @@
 			end
 	end end
 =

-	-- dynamics and mobile
-	local bIgnorePlayer =3D self:IsFirstPersonCam()
-	for k,object in pairs(gObjectList) do =

-		-- dynamics
-		if (object.isdynamic) then =

-			local mobile =3D dynamic
-			-- does this dynamic consists of many gfx parts (multi)?
-			if dynamic.lMultiChildGfx then
-				-- handle multi collision
-				for k,gfx in pairs(dynamic.lMultiChildGfx) do =

-					if (self:IsZLayerVisible(gfx.zloc)) then
-						-- WARNING copy &amp; paste code
-							bHit,fHitDist =3D gfx:RayPick(rx,ry,rz,rvx,rvy,rvz)
-							if (bHit and ((not gMousePickFoundHit) or fHitDist &lt; self.gMousePic=
kFoundDist)) then
-								self.gMousePickFoundDist =3D fHitDist
-								gMousePickFoundHit =3D {}
-								gMousePickFoundHit.hittype =3D kMousePickHitType_Dynamic
-								gMousePickFoundHit.dynamic =3D dynamic
-							end
-					end
-				end
-			elseif (dynamic.gfx) then
-				-- WARNING copy &amp; paste code
-				if (self:IsZLayerVisible(dynamic.zloc)) then
-					if (dynamic.gfx.billboard) then
-						-- fallback
-						local x,y,z =3D dynamic.gfx.billboard:GetDerivedPosition()
-						fHitDist =3D SphereRayPick(x,y,z,0.5,rx,ry,rz,rvx,rvy,rvz) -- 0.5 rad
-						bHit =3D (fHitDist ~=3D nil)
-					else
-						-- mesh mousepick
-						bHit,fHitDist =3D dynamic.gfx:RayPick(rx,ry,rz,rvx,rvy,rvz)
-					end
-					if (bHit and ((not gMousePickFoundHit) or fHitDist &lt; self.gMousePickF=
oundDist)) then
-						self.gMousePickFoundDist =3D fHitDist
-						gMousePickFoundHit =3D {}
-						gMousePickFoundHit.hittype =3D kMousePickHitType_Dynamic
-						gMousePickFoundHit.dynamic =3D dynamic
-					end
-				end
-			end
-		end
-		=

-		-- mobiles
-		if (object.ismobile) then =

-			local mobile =3D object
-			if (mobile.gfx and self:IsZLayerVisible(mobile.zloc) and ((not bIgnoreP=
layer) or (not IsPlayerMobile(mobile)))) then
-				if (true) then
-					-- small bbox mousepick as fallback in case model is not available/in=
visible (horse)
-					bHit,fHitDist =3D mobile.gfx:RayPick(rx,ry,rz,rvx,rvy,rvz)
-					if (bHit and ((not gMousePickFoundHit) or fHitDist &lt; self.gMousePickF=
oundDist)) then
-						self.gMousePickFoundDist =3D fHitDist
-						gMousePickFoundHit =3D {}
-						gMousePickFoundHit.hittype =3D kMousePickHitType_Mobile
-						gMousePickFoundHit.mobile =3D mobile
-					end
-				end
-				if (gbUseExactGrannyMousepicking and mobile.modelparts) then =

-					-- exact granny mousepick if possible
-					--print(&quot;gbUseExactGrannyMousepicking&quot;,mobile.modelparts)
-					for k,partgfx in pairs(mobile.modelparts) do =

-						--print(&quot;### grannymousepick start&quot;)
-						bHit,fHitDist =3D partgfx:RayPick(rx,ry,rz,rvx,rvy,rvz)
-						--print(&quot;### grannymousepick end,&quot;,bHit)
-						--if (bHit) then print(&quot;HIT ! HIT ! HIT ! HIT ! HIT !&quot;) end
+	-- dynamics
+	for k,dynamic in pairs(GetDynamicList()) do
+		-- does this dynamic consists of many gfx parts (multi)?
+		if dynamic.lMultiChildGfx then
+			-- handle multi collision
+			for k,gfx in pairs(dynamic.lMultiChildGfx) do =

+				if (self:IsZLayerVisible(gfx.zloc)) then
+					-- WARNING copy &amp; paste code
+						bHit,fHitDist =3D gfx:RayPick(rx,ry,rz,rvx,rvy,rvz)
 						if (bHit and ((not gMousePickFoundHit) or fHitDist &lt; self.gMousePick=
FoundDist)) then
 							self.gMousePickFoundDist =3D fHitDist
 							gMousePickFoundHit =3D {}
-							gMousePickFoundHit.hittype =3D kMousePickHitType_Mobile
-							gMousePickFoundHit.mobile =3D mobile
+							gMousePickFoundHit.hittype =3D kMousePickHitType_Dynamic
+							gMousePickFoundHit.dynamic =3D dynamic
 						end
-					end
-				end
-			end =

-		end
-	end
+				end
+			end
+		elseif (dynamic.gfx) then
+			-- WARNING copy &amp; paste code
+			if (self:IsZLayerVisible(dynamic.zloc)) then
+				if (dynamic.gfx.billboard) then
+					-- fallback
+					local x,y,z =3D dynamic.gfx.billboard:GetDerivedPosition()
+					fHitDist =3D SphereRayPick(x,y,z,0.5,rx,ry,rz,rvx,rvy,rvz) -- 0.5 rad
+					bHit =3D (fHitDist ~=3D nil)
+				else
+					-- mesh mousepick
+					bHit,fHitDist =3D dynamic.gfx:RayPick(rx,ry,rz,rvx,rvy,rvz)
+				end
+				if (bHit and ((not gMousePickFoundHit) or fHitDist &lt; self.gMousePickFo=
undDist)) then
+					self.gMousePickFoundDist =3D fHitDist
+					gMousePickFoundHit =3D {}
+					gMousePickFoundHit.hittype =3D kMousePickHitType_Dynamic
+					gMousePickFoundHit.dynamic =3D dynamic
+				end
+			end
+		end
+	end
+
+	-- mobiles
+	local bIgnorePlayer =3D self:IsFirstPersonCam()
+	for k,mobile in pairs(GetMobileList()) do if (mobile.gfx and self:IsZLaye=
rVisible(mobile.zloc) and ((not bIgnorePlayer) or (not IsPlayerMobile(mobil=
e)))) then
+		if (true) then
+			-- small bbox mousepick as fallback in case model is not available/invi=
sible (horse)
+			bHit,fHitDist =3D mobile.gfx:RayPick(rx,ry,rz,rvx,rvy,rvz)
+			if (bHit and ((not gMousePickFoundHit) or fHitDist &lt; self.gMousePickFou=
ndDist)) then
+				self.gMousePickFoundDist =3D fHitDist
+				gMousePickFoundHit =3D {}
+				gMousePickFoundHit.hittype =3D kMousePickHitType_Mobile
+				gMousePickFoundHit.mobile =3D mobile
+			end
+		end
+		if (gbUseExactGrannyMousepicking and mobile.modelparts) then =

+			-- exact granny mousepick if possible
+			--print(&quot;gbUseExactGrannyMousepicking&quot;,mobile.modelparts)
+			for k,partgfx in pairs(mobile.modelparts) do =

+				--print(&quot;### grannymousepick start&quot;)
+				bHit,fHitDist =3D partgfx:RayPick(rx,ry,rz,rvx,rvy,rvz)
+				--print(&quot;### grannymousepick end,&quot;,bHit)
+				--if (bHit) then print(&quot;HIT ! HIT ! HIT ! HIT ! HIT !&quot;) end
+				if (bHit and ((not gMousePickFoundHit) or fHitDist &lt; self.gMousePickFo=
undDist)) then
+					self.gMousePickFoundDist =3D fHitDist
+					gMousePickFoundHit =3D {}
+					gMousePickFoundHit.hittype =3D kMousePickHitType_Mobile
+					gMousePickFoundHit.mobile =3D mobile
+				end
+			end
+		end
+	end end
+	=

 	=

 	-- prepare exact hit coords 3d hit
 	self.gMousePickFoundHit_ExactX =3D rx + self.gMousePickFoundDist * rvx
@@ -317,7 +311,7 @@
 		end
 	elseif (o.hittype =3D=3D kMousePickHitType_Mobile) then
 		local mobile =3D o.mobile
-		local mouseover =3D sprintf(&quot;(mobiletype=3D0x%04x serial=3D0x%08x notori=
ety=3D%d flag=3D0x%02x)&quot;,mobile.body,mobile.serial,mobile.notoriety,mobile.=
flag)
+		local mouseover =3D sprintf(&quot;(mobiletype=3D0x%04x serial=3D0x%08x notori=
ety=3D%d flag=3D0x%02x)&quot;,mobile.artid,mobile.serial,mobile.notoriety,mobile=
.flag)
 		=

 		Client_SetBottomLine(self.gMousePickTippOverride or mouseover)
 		=

@@ -330,7 +324,7 @@
 			--local x,y,z =3D gMousePickBBox:GetPosition()
 			--gMousePickBBox:SetPosition(x,y,z+0.1)
 			--local qw,qx,qy,qz =3D Quaternion.identity()
-			--local qw,qx,qy,qz =3D GetStaticMeshOrientation(mobile.body)
+			--local qw,qx,qy,qz =3D GetStaticMeshOrientation(mobile.artid)
 			--gMousePickBBox:SetOrientation(qw,qx,qy,qz)
 			self.gMousePickBBox:SetVisible(true) =

 		end

Modified: branches/knut/data/lua/lib.3d.renderer.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.3d.renderer.lua (original)
+++ branches/knut/data/lua/lib.3d.renderer.lua Thu Aug  2 17:12:24 2007
@@ -84,18 +84,14 @@
 	self:SetMapEnvironment()
 	=

 	self.gbCamRotChanged =3D true
-	for k,object in pairs(gObjectList) do
-		if (object.isdynamic) then self:CreateDynamicGfx(object) end
-		if (object.ismobile ) then self:CreateMobileGfx(object) end
-	end
+	for k,dynamic in pairs(GetDynamicList()) do self:CreateDynamicGfx(dynamic=
) end
+	for k,mobile in pairs(GetMobileList()) do self:CreateMobileGfx(mobile) end
 end
 =

 function Renderer3D:DeInit()
 	--print(&quot;deactivating Renderer3D&quot;)
-	for k,object in pairs(gObjectList) do =

-		if (object.ismobile ) then self:DestroyMobileGfx(object) end
-		if (object.isdynamic) then self:DestroyDynamicGfx(object) end
-	end
+	for k,dynamic in pairs(GetDynamicList()) do self:DestroyDynamicGfx(dynami=
c) end
+	for k,mobile in pairs(GetMobileList()) do self:DestroyMobileGfx(mobile) e=
nd
 	self:DeactivateMousePick()
 	self:ClearMapCache()
 	Client_SetFog()
@@ -307,9 +303,9 @@
 function Renderer3D:UpdateMobile( mobile )
 	if (not self.gbActive) then return end
 	=

-	if mobile.serial =3D=3D gPlayerBodySerial then
+	if (IsPlayerMobile(mobile)) then
 		-- set audio listener position if this is the playerbody
-		SoundSetListenerPosition(mobile.x,mobile.y,mobile.z * 0.1 + self.gZ_Fact=
or)
+		SoundSetListenerPosition(mobile.xloc,mobile.yloc,mobile.zloc * 0.1 + sel=
f.gZ_Factor)
 	end
 =

 	if (not mobile.gfx) then
@@ -507,7 +503,7 @@
 function Renderer3D:UpdateMobilePos (mobile,x,y,z,qw,qx,qy,qz)
 	-- set position and orientation
 	if (mobile.modelgfx) then
-		local mount =3D mobile:getequipment(kLayer_Mount)
+		local mount =3D GetMobileEquipmentItem(mobile,kLayer_Mount)
 		mobile.modelgfx:SetPosition(x-0.5, y+0.5, z + (mount and -kMountZAdd or =
0))
 		mobile.modelgfx:SetOrientation(qw,qx,qy,qz)
 	end
@@ -610,7 +606,7 @@
 	local iTimeSinceLastStepInSeconds =3D self.giLastAnimStepTime and ((gMyTi=
cks - self.giLastAnimStepTime) / 1000) or 0
 	self.giLastAnimStepTime =3D gMyTicks
 	=

-	for k,mobile in pairs(gObjectList) do if (mobile.ismobile) then Renderer3=
D:StepMobile(mobile,iTimeSinceLastStepInSeconds) end end
+	for k,mobile in pairs(GetMobileList()) do Renderer3D:StepMobile(mobile,iT=
imeSinceLastStepInSeconds) end
 end
 =

 -- obsolete but might be interesting
@@ -669,10 +665,12 @@
 		self.giLastMapOriginX =3D self.giMapOriginX
 		self.giLastMapOriginY =3D self.giMapOriginY
 		=

-		for k,object in pairs(gObjectList) do =

-			if (object.ismobile) then self:UpdateMobile(object) end
-			if (object.isdynamic) then self:UpdateDynamicItemPos(object) end
-		end
+		for k,mobile in pairs(GetMobileList()) do =

+			UpdateMobile(mobile) =

+		end
+		for k,dynamic in pairs(GetDynamicList()) do if (dynamic.gfx) then
+			self:UpdateDynamicItemPos(dynamic)
+		end end
 	end
 end
 =

@@ -688,7 +686,7 @@
 =

 function Renderer3D:UpdateDynamicItemPos ( dynamic )
 	if (dynamic.gfx) then
-		dynamic.gfx:SetPosition(self:UOPosToLocal(dynamic.x + dynamic.xadd,dynam=
ic.y + dynamic.yadd,dynamic.z * 0.1 + dynamic.zadd))
+		dynamic.gfx:SetPosition(self:UOPosToLocal(dynamic.xloc + dynamic.xadd,dy=
namic.yloc + dynamic.yadd,dynamic.zloc * 0.1 + dynamic.zadd))
 	end
 end
 =

@@ -787,7 +785,7 @@
 			print(&quot;+++++++++++++++++++++++++&quot;)
 			print(&quot;ITEM&quot;,vardump(item))
 		else =

-			--printdebug(&quot;missing&quot;,sprintf(&quot;Renderer3D:CreateDynamicGfx: failed loa=
ding mesh for dynamic (multi): artid=3D%i z_typename=3D%s\n&quot;,item.artid or =
-1,item.z_typename or &quot;&quot;))
+			printdebug(&quot;missing&quot;,sprintf(&quot;Renderer3D:CreateDynamicGfx: failed loadi=
ng mesh for dynamic (multi): artid=3D%i z_typename=3D%s\n&quot;,item.artid or -1=
,item.z_typename or &quot;&quot;))
 		end
 	else
 		-- normal 1 part object
@@ -833,7 +831,7 @@
 				item.yadd =3D item.yadd + 0.5
 				item.zadd =3D item.zadd + 0.5
 				self:CreateArtBillBoard(item.gfx.billboard,iTranslatedTileTypeID,item.=
hue)
-				--printdebug(&quot;missing&quot;,sprintf(&quot;Renderer3D:CreateDynamicGfx: failed lo=
ading mesh for dynamic: artid=3D%i z_typename=3D%s\n&quot;,item.artid or -1,item=
.z_typename or &quot;&quot;))
+				printdebug(&quot;missing&quot;,sprintf(&quot;Renderer3D:CreateDynamicGfx: failed load=
ing mesh for dynamic: artid=3D%i z_typename=3D%s\n&quot;,item.artid or -1,item.z=
_typename or &quot;&quot;))
 			end
 		end
 		item.gfx:SetRenderingDistance(self.gDynamicMaxRenderDist)
@@ -923,7 +921,7 @@
 -- removes the current mobile selection
 function Renderer3D:DeselectMobile ()
 	if (giSelectedMobile ~=3D 0) then
-		local mobile =3D gObjectList[giSelectedMobile]
+		local mobile =3D GetMobile(giSelectedMobile)
 		if (mobile) then
 			mobile.isselected =3D false
 			mobile.selection:SetVisible(false)
@@ -937,14 +935,14 @@
 	-- print (&quot;selectmobile&quot;,iSerial)
 	self:DeselectMobile()
 	if (iSerial ~=3D 0) then
-		local mobile =3D gObjectList[iSerial]
+		local mobile =3D GetMobile(iSerial)
 		if (mobile) then
 			mobile.isselected =3D true
 			-- TODO is it possible that selection is not created (UpdateMobile crea=
tes selection)
-			--mobile.selection:SetVisible(true)
+			mobile.selection:SetVisible(true)
 			giSelectedMobile =3D iSerial
 			=

-			-- CombatCreateDamageText(&quot;jupii!&quot;,mobile.x,mobile.y,mobile.z)
-		end
-	end
-end
+			-- CombatCreateDamageText(&quot;jupii!&quot;,mobile.xloc,mobile.yloc,mobile.zloc)
+		end
+	end
+end

Modified: branches/knut/data/lua/lib.debugmenu.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.debugmenu.lua (original)
+++ branches/knut/data/lua/lib.debugmenu.lua Thu Aug  2 17:12:24 2007
@@ -161,12 +161,12 @@
 		local mobile =3D gDebugTestMobiles[index]
 		if (not mobile) then return end
 		mobile.equipment =3D RepairEquipIndex(mobile.equipment)
-		AddFadeLines(sprintf(&quot;DebugMenuShowModel model=3D%04x(=3D%d) anim=3D%d[%=
s]&quot;,mobile.body,mobile.body,gDebugMenuAnimIndex,GetAnimName(mobile.body,gDe=
bugMenuAnimIndex) or &quot;&quot;))
+		AddFadeLines(sprintf(&quot;DebugMenuShowModel model=3D%04x(=3D%d) anim=3D%d[%=
s]&quot;,mobile.artid,mobile.artid,gDebugMenuAnimIndex,GetAnimName(mobile.artid,=
gDebugMenuAnimIndex) or &quot;&quot;))
 		=

 		local animid =3D gDebugMenuAnimIndex
 		local bDoLoop =3D true
 		local modelidarr,iPrimaryHandItem,iSecondaryHandItem =3D GetMobileModelP=
artModelIDs(mobile)
-		CreateMobileModelPartsFromModelIDArray(mobile.body,gDebugRootGfx,gDebugM=
odelParts,modelidarr,iPrimaryHandItem,iSecondaryHandItem)
+		CreateMobileModelPartsFromModelIDArray(mobile.artid,gDebugRootGfx,gDebug=
ModelParts,modelidarr,iPrimaryHandItem,iSecondaryHandItem)
 		if (gDebugMenuAnimIndex &gt;=3D 0) then MobileStartAnim(mobile,gDebugModelP=
arts,animid,bDoLoop) end
 	end
 	=


Modified: branches/knut/data/lua/lib.devtool.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.devtool.lua (original)
+++ branches/knut/data/lua/lib.devtool.lua Thu Aug  2 17:12:24 2007
@@ -260,12 +260,9 @@
 =

 function ListDynamicsNearPos (x,y,z,radius)
 	local res =3D {}
-	for k,object in pairs(gObjectList) do =

-		if (object.isdynamic) then
-			local item =3D object
-			local d =3D dist2(x,y,item.xloc,item.yloc)
-			if (d &lt;=3D radius) then table.insert(res,item) end =

-		end
+	for k,item in pairs(GetDynamicList()) do =

+		local d =3D dist2(x,y,item.xloc,item.yloc)
+		if (d &lt;=3D radius) then table.insert(res,item) end =

 	end
 	return res
 end

Modified: branches/knut/data/lua/lib.fallback.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.fallback.lua (original)
+++ branches/knut/data/lua/lib.fallback.lua Thu Aug  2 17:12:24 2007
@@ -25,17 +25,14 @@
 	f:write(sprintf(&quot;RegisterSkippedArtBillboardFallBack(%d) -- 0x%04x name=
=3D%s\n&quot;,i,i,GetStaticTileTypeName(i) or &quot;unknown&quot;))
 	f:close()
 	-- hide existing dynamics
-	=

-	for k,object in pairs(gObjectList) do =

-		if (object.isdynamic) then
-			local item =3D object
-			if (item.iTileTypeID =3D=3D i and item.gfx and item.gfx.billboard) then =

-				item.gfx.billboard:Destroy() =

-				item.gfx.billboard =3D nil =

-			end
-		end =

+
+	for k,item in pairs(GetDynamicList()) do
+		if (item.iTileTypeID =3D=3D i and item.gfx and item.gfx.billboard) then =

+			item.gfx.billboard:Destroy() =

+			item.gfx.billboard =3D nil =

+		end
 	end
-	=

+
 	-- hide existing statics (requires map rebuild)
 	gCurrentRenderer:ClearMapCache()
 end
@@ -137,12 +134,9 @@
 =

 function List3DDynamicsNearPos (x,y,z,radius)
 	local res =3D {}
-	for k,object in pairs(gObjectList) do =

-		if (object.isdynamic) then
-			local item =3D object
+	for k,item in pairs(GetDynamicList()) do =

 			local d =3D dist2(x,y,item.xloc,item.yloc)
 			if (d &lt;=3D radius) then table.insert(res,item) end =

-		end
 	end
 	return res
 end

Modified: branches/knut/data/lua/lib.modelanim.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.modelanim.lua (original)
+++ branches/knut/data/lua/lib.modelanim.lua Thu Aug  2 17:12:24 2007
@@ -33,14 +33,14 @@
 function MobileStartAnim (mobile,partsarr,animid,bDoLoop)
 	if (gDisableModelAnim) then return end
 	if (not gAnimInfoLists) then return end
-	local bodyid =3D MobileArtId2BodyId(mobile.body)
+	local bodyid =3D MobileArtId2BodyId(mobile.artid)
 	local animname =3D GetAnimName(bodyid,animid)
 	if (not GetAnimPath(bodyid,animid)) then return end -- anim not found
 	-- play animation
 	animlen =3D 0
 	for k,v in pairs(partsarr) do =

 		if (v:HasSkeleton()) then
-			printdebug(&quot;granny&quot;,&quot;MobileStartAnim&quot;,mobile.body,bodyid,animid,animnam=
e,GetAnimPath(bodyid,animid))
+			printdebug(&quot;granny&quot;,&quot;MobileStartAnim&quot;,mobile.artid,bodyid,animid,animna=
me,GetAnimPath(bodyid,animid))
 			v:SetAnim(animname,bDoLoop) =

 			v:SetAnimTimePos(0) =

 			v:AnimAddTime(0)

Modified: branches/knut/data/lua/lib.models.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.models.lua (original)
+++ branches/knut/data/lua/lib.models.lua Thu Aug  2 17:12:24 2007
@@ -305,7 +305,7 @@
 	local iSecondaryHandItem =3D nil
 	local modelidarr =3D {}
 	=

-	local bodyid =3D MobileArtId2BodyId(mobile.body)
+	local bodyid =3D MobileArtId2BodyId(mobile.artid)
 	local bFemale =3D IsBodyIDFemale(bodyid)
 	if (mobile.bIsFemale) then bFemale =3D true end -- debug hack
 	=

@@ -326,10 +326,10 @@
 	end
 	=

 	-- equipment, ORDER IS IMPORTANT FOR STITCHIN !!! (gLayerOrder?)
-	if (mobile.content) then =

+	if (GetMobileEquipmentList(mobile)) then =

 		-- TODO : i assume the paperdoll layerorder is the same as the granny la=
yeroder, check if this is correct
 		for index,layer in pairs(gLayerOrder) do
-			local item =3D mobile:getequipment(layer)
+			local item =3D GetMobileEquipmentItem(mobile,layer)
 			if (item and layer ~=3D kLayer_Mount) then  -- ignore mounts here, hand=
led seperately
 				local tiledata =3D GetStaticTileType(item.artid or 0)
 				--print(&quot;equip&quot;,item.artid,tiledata and tiledata.miAnimID or 0)
@@ -484,13 +484,13 @@
 =

 function UpdateMobileModel (mobile)
 	if (not gAnimInfoLists) then return end
-	--if (mobile.body ~=3D 400 and mobile.body ~=3D 401) then return end
+	--if (mobile.artid ~=3D 400 and mobile.artid ~=3D 401) then return end
 =

 	-- TODO: Debug and check why RunUO sends kPacket_Equipped_MOB with artid =
=3D=3D Zero
 	if (mobile.artid =3D=3D 0) then return end
 	if (not mobile.equipment) then return end -- happens when being teleported
 	=

-	local mount =3D mobile:getequipment(kLayer_Mount)
+	local mount =3D GetMobileEquipmentItem(mobile,kLayer_Mount)
 	local modelidarr,iPrimaryHandItem,iSecondaryHandItem =3D GetMobileModelPa=
rtModelIDs(mobile)
 	local bModelPartsChanged =3D false
 	if (not mobile.modelgfx) then bModelPartsChanged =3D true end
@@ -515,7 +515,7 @@
 		mobile.modelgfx:SetVisible(true)
 		mobile.modelparts =3D {}
 		mobile.modelidarr =3D modelidarr
-		CreateMobileModelPartsFromModelIDArray(mobile.body,mobile.modelgfx,mobil=
e.modelparts,modelidarr,iPrimaryHandItem,iSecondaryHandItem)
+		CreateMobileModelPartsFromModelIDArray(mobile.artid,mobile.modelgfx,mobi=
le.modelparts,modelidarr,iPrimaryHandItem,iSecondaryHandItem)
 		=

 		-- create mount gfx
 		mobile.hasmountgfx =3D false
@@ -579,7 +579,7 @@
 		end
 		=

 		if (false) then
-			local txt =3D sprintf(&quot;##### {body=3D%d,hue=3D%d, equipment=3D{&quot;,mobile=
.body,mobile.hue)
+			local txt =3D sprintf(&quot;##### {artid=3D%d,hue=3D%d, equipment=3D{&quot;,mobil=
e.artid,mobile.hue)
 			if (mobile.equipment) then for k,item in pairs(mobile.equipment) do
 				local tiledata =3D GetStaticTileType(item.artid)
 				txt =3D txt .. sprintf(&quot;[%d]=3D{artid=3D%d,hue=3D%d,animid=3D%d},&quot;,k,i=
tem.artid,item.hue,tiledata and tiledata.miAnimID or 0)

Modified: branches/knut/data/lua/lib.mousepick.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.mousepick.lua (original)
+++ branches/knut/data/lua/lib.mousepick.lua Thu Aug  2 17:12:24 2007
@@ -1,150 +1,146 @@
-kMousePickHitType_Static =3D 0
-kMousePickHitType_Terrain =3D 1
-kMousePickHitType_Dynamic =3D 2
-kMousePickHitType_Mobile =3D 3
-
-gMousePickFoundHit =3D false
-
-giSelectedMobile =3D 0
+kMousePickHitType_Static =3D 0
+kMousePickHitType_Terrain =3D 1
+kMousePickHitType_Dynamic =3D 2
+kMousePickHitType_Mobile =3D 3
+kMousePickHitType_ContainerItem =3D 4
+kMousePickHitType_PaperdollItem =3D 5
 =

--- OBSOLETED CODE ! don't use this, hasn't been adjusted to xmirror fix&gt;f =
TerrainRayIntersect_Hit .lua
-function TerrainRayIntersect_Hit(tx,ty,tiletype,hit_dist,minz,maxz)
-	gCurrentRenderer:TerrainRayIntersect_Hit (tx,ty,tiletype,hit_dist,minz,ma=
xz)
+gMousePickFoundHit =3D false
+
+giSelectedMobile =3D 0
+
+-- OBSOLETED CODE ! don't use this, hasn't been adjusted to xmirror fix&gt;f =
TerrainRayIntersect_Hit .lua
+function TerrainRayIntersect_Hit(tx,ty,tiletype,hit_dist,minz,maxz)
+	gCurrentRenderer:TerrainRayIntersect_Hit (tx,ty,tiletype,hit_dist,minz,ma=
xz)
 end
 =

 function IrisRightDoubleClick ()
-	-- TODO implement pathfinding and use it here
+	-- TODO implement pathfinding and use it here
 	-- SetAutoWalkTarget()
-end
-
-function IrisDoubleClick ()
-	gCurrentRenderer:MousePick()
-	local iSerial =3D gCurrentRenderer:GetMouseHitSerial()
-	if gbControlDown then
-		-- open status window if control pressed and mobile targeted
-		if (iSerial and iSerial ~=3D 0) then =

-			local mobile =3D gObjectList[iSerial].ismobile and gObjectList[iSerial]
-			local iMouseX,iMouseY =3D PollInput()
-			-- -50,-30 to place the dialog beneath the mouse
-			OpenStatus(mobile,iMouseX - 50,iMouseY - 30)
-		end
-	else
-		-- normal doubleclick handling
-		pm =3D GetPlayerMobile()
-		if (gActWarmode =3D=3D gWarmode_Normal or (pm and iSerial =3D=3D pm.seri=
al) ) then
-			if (iSerial and iSerial ~=3D 0) then
-				printdebug(&quot;UO&quot;,&quot;IrisDoubleClick: serial=3D0x%08x\n&quot;,iSerial)
-				Send_DoubleClick(iSerial)
-			end
-		end
-		if (gActWarmode =3D=3D gWarmode_Combat) then
-			if (iSerial and iSerial ~=3D 0) then
-				printdebug(&quot;UO&quot;,&quot;IrisDoubleClickAttack: serial=3D0x%08x\n&quot;,iSerial)
-				Send_AttackReq(iSerial)
-			end
-		end
-	end
-end
-
--- currently sent on mousedown
--- TODO : maybe only send on mouseup if no dragdrop took place ?
-function IrisSingleClick ()
-	if (IsTargetModeActive()) then =

-		CompleteTargetMode() -- see net.cursor.lua
-	else
-		local iSerial =3D gCurrentRenderer:GetMouseHitSerial()
-		if (iSerial and iSerial ~=3D 0) then =

-			printdebug(&quot;UO&quot;,&quot;IrisSingleClick: serial=3D0x%08x\n&quot;,iSerial)
-			Send_SingleClick(iSerial)
-			gCurrentRenderer:SelectMobile(iSerial)
-		else
-			-- TODO is this too removey?
-			-- gCurrentRenderer:DeselectMobile()
-		end
-	end
-end
-
-function IrisRightClick ()
-	local iSerial =3D gCurrentRenderer:GetMouseHitSerial()
-	if (iSerial and iSerial ~=3D 0) then =

-		printdebug(&quot;UO&quot;,&quot;IrisRightClick: serial=3D0x%08x\n&quot;,iSerial)
-		Send_PopupRequest(iSerial) =

-	end
-end
-
--- find mobile with the minimum distance to player (x,y 2d based)
-function SelectNearestMobile ()
-	gCurrentRenderer:DeselectMobile()
-	=

-	local mindist =3D -1
-	local minserial =3D 0
-	local playermobile =3D gObjectList[gPlayerBodySerial]
+end
+
+function IrisDoubleClick ()
+	gCurrentRenderer:MousePick()
+	local iSerial =3D gCurrentRenderer:GetMouseHitSerial()
+	if gbControlDown then
+		-- open status window if control pressed and mobile targeted
+		if (iSerial and iSerial ~=3D 0) then =

+			local mobile =3D GetMobile(iSerial)
+			local iMouseX,iMouseY =3D PollInput()
+			-- -50,-30 to place the dialog beneath the mouse
+			OpenStatus(mobile,iMouseX - 50,iMouseY - 30)
+		end
+	else
+		-- normal doubleclick handling
+		pm =3D GetPlayerMobile()
+		if (gActWarmode =3D=3D gWarmode_Normal or (pm and iSerial =3D=3D pm.seri=
al) ) then
+			if (iSerial and iSerial ~=3D 0) then
+				printdebug(&quot;UO&quot;,&quot;IrisDoubleClick: serial=3D0x%08x\n&quot;,iSerial)
+				Send_DoubleClick(iSerial)
+			end
+		end
+		if (gActWarmode =3D=3D gWarmode_Combat) then
+			if (iSerial and iSerial ~=3D 0) then
+				printdebug(&quot;UO&quot;,&quot;IrisDoubleClickAttack: serial=3D0x%08x\n&quot;,iSerial)
+				Send_AttackReq(iSerial)
+			end
+		end
+	end
+end
+
+-- currently sent on mousedown
+-- TODO : maybe only send on mouseup if no dragdrop took place ?
+function IrisSingleClick ()
+	if (IsTargetModeActive()) then =

+		CompleteTargetMode() -- see net.cursor.lua
+	else
+		local iSerial =3D gCurrentRenderer:GetMouseHitSerial()
+		if (iSerial and iSerial ~=3D 0) then =

+			printdebug(&quot;UO&quot;,&quot;IrisSingleClick: serial=3D0x%08x\n&quot;,iSerial)
+			Send_SingleClick(iSerial)
+			gCurrentRenderer:SelectMobile(iSerial)
+		else
+			-- TODO is this too removey?
+			-- gCurrentRenderer:DeselectMobile()
+		end
+	end
+end
+
+function IrisRightClick ()
+	local iSerial =3D gCurrentRenderer:GetMouseHitSerial()
+	if (iSerial and iSerial ~=3D 0) then =

+		printdebug(&quot;UO&quot;,&quot;IrisRightClick: serial=3D0x%08x\n&quot;,iSerial)
+		Send_PopupRequest(iSerial) =

+	end
+end
+
+-- find mobile with the minimum distance to player (x,y 2d based)
+function SelectNearestMobile ()
+	gCurrentRenderer:DeselectMobile()
+	=

+	local mindist =3D -1
+	local minserial =3D 0
+	local playermobile =3D GetMobile(gPlayerBodySerial)
 	if (playermobile) then
-		for k,object in pairs(gObjectList) do =

-			if (object.ismobile) then =

-				local mobile =3D object
-				if (k ~=3D gPlayerBodySerial) then
-					-- calculate distance to player
-					local dx =3D (mobile.x - playermobile.x)
-					local dy =3D (mobile.y - playermobile.y)
-					local d =3D math.sqrt(dx*dx + dy*dy)
-					if (mindist &lt; 0 or d &lt; mindist) then
-						-- new min found
-						minserial =3D k
-						mindist =3D d
-					end
+		for k,mobile in pairs(GetMobileList()) do =

+			if (k ~=3D gPlayerBodySerial) then
+				-- calculate distance to player
+				local dx =3D (mobile.xloc - playermobile.xloc)
+				local dy =3D (mobile.yloc - playermobile.yloc)
+				local d =3D math.sqrt(dx*dx + dy*dy)
+				if (mindist &lt; 0 or d &lt; mindist) then
+					-- new min found
+					minserial =3D k
+					mindist =3D d
 				end
 			end
-		end
-	end
-	-- select the nearest if found
-	if (minserial ~=3D 0) then
-		gCurrentRenderer:SelectMobile(minserial)
-	end
-end
-
--- selects the next mobile cycling through all mobiles
-function SelectNextMobile ()
-	local current =3D giSelectedMobile
-	local minserial =3D -1
-	local nextminserial =3D -1
+		end
+	end
+	-- select the nearest if found
+	if (minserial ~=3D 0) then
+		gCurrentRenderer:SelectMobile(minserial)
+	end
+end
+
+-- selects the next mobile cycling through all mobiles
+function SelectNextMobile ()
+	local current =3D giSelectedMobile
+	local minserial =3D -1
+	local nextminserial =3D -1
 	-- print (&quot;current&quot;, current)
 	=

-	for k,object in pairs(gObjectList) do =

-		if (object.ismobile) then =

-			local mobile =3D object
-			if (current &lt; k and (k &lt; nextminserial or nextminserial &lt; 0)) then
-				-- small serial (bigger than current found)
-				nextminserial =3D k
-				-- print (&quot;nextminserial&quot;,nextminserial)
-			end
-			if (minserial &lt; 0 or k &lt; minserial) then
-				-- searches for the absolute min serial, cycle start
-				minserial =3D k
-				-- print (&quot;minserial&quot;,minserial)
-			end
+	for k,mobile in pairs(GetMobileList()) do
+		if (current &lt; k and (k &lt; nextminserial or nextminserial &lt; 0)) then
+			-- small serial (bigger than current found)
+			nextminserial =3D k
+			-- print (&quot;nextminserial&quot;,nextminserial)
 		end
-	end
-	=

-	-- select the next if found
-	if (nextminserial &gt; 0) then
-		gCurrentRenderer:SelectMobile(nextminserial)
-	else
-		-- or the start if no next found
-		if (minserial &gt; 0) then
-			gCurrentRenderer:SelectMobile(minserial)
-		end
-	end
-end
-
--- attack the current selected mobile or just go to it (depends in warmode=
 on/off)
-function AttackSelectedMobile ()
-	if (giSelectedMobile ~=3D 0) then
-		-- who shall i kill, master?
-		local target =3D gObjectList[giSelectedMobile]
-		if target then
-			-- run to the target
-			SetFollowMobile(giSelectedMobile)
-		end
-	end
-end
+		if (minserial &lt; 0 or k &lt; minserial) then
+			-- searches for the absolute min serial, cycle start
+			minserial =3D k
+			-- print (&quot;minserial&quot;,minserial)
+		end
+	end
+	=

+	-- select the next if found
+	if (nextminserial &gt; 0) then
+		gCurrentRenderer:SelectMobile(nextminserial)
+	else
+		-- or the start if no next found
+		if (minserial &gt; 0) then
+			gCurrentRenderer:SelectMobile(minserial)
+		end
+	end
+end
+
+-- attack the current selected mobile or just go to it (depends in warmode=
 on/off)
+function AttackSelectedMobile ()
+	if (giSelectedMobile ~=3D 0) then
+		-- who shall i kill, master?
+		local target =3D GetMobile(giSelectedMobile)
+		if target then
+			-- run to the target
+			SetFollowMobile(giSelectedMobile)
+		end
+	end
+end

Modified: branches/knut/data/lua/lib.protocol.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.protocol.lua (original)
+++ branches/knut/data/lua/lib.protocol.lua Thu Aug  2 17:12:24 2007
@@ -41,9 +41,9 @@
 	dofile(libpath .. &quot;net.sound.lua&quot;)
 	dofile(libpath .. &quot;net.trade.lua&quot;)
 	dofile(libpath .. &quot;net.securetrade.lua&quot;)
+	dofile(libpath .. &quot;net.uodragdrop.lua&quot;)
 	dofile(libpath .. &quot;net.walk.lua&quot;)
 	dofile(libpath .. &quot;net.world.lua&quot;)
-	dofile(libpath .. &quot;net.customhouse.lua&quot;)
 	dofile(libpath .. &quot;net.corpse.lua&quot;)
 =

 	=

@@ -151,78 +151,9 @@
 =

 -- Send Packets -----------------------------------------------------------
 =

--- send login server request 0x80
--- answered by 0xA8 kPacket_Server_List which calls MainMenuShowServerList
-function ProtocolSend_Account_Login_Request	(sName,sPassword,iSeed)
-	printdebug(&quot;login&quot;,sprintf(&quot;NET: Account_Login_Request: Name: %s Password=
:<i> %s Seed: %i\n&quot;,sName,sPassword,iSeed))
</I>-	local out =3D GetSendFIFO()
-	out:PushNetUint8(kPacket_Account_Login_Request)
-	out:PushFilledString(sName,30)
-	out:PushFilledString(sPassword,30)
-	out:PushNetUint8(iSeed)
-	out:SendPacket()
-end
-
--- send gameserverselect to loginserver : kPacket_Server_Select 0xA0
--- answered by kPacket_Server_Redirect 0x8C
--- which calls ProtocolSend_GameServer_PostLogin kPacket_Post_Login 0x91 =

-function ProtocolSend_GameServer_Select(iGameServerID)
-	printdebug(&quot;login&quot;,sprintf(&quot;NET: GameServer_Select: %i\n&quot;,iGameServerID))
-	local out =3D GetSendFIFO()
-	out:PushNetUint8(kPacket_Server_Select)
-	out:PushNetUint16(iGameServerID)
-	out:SendPacket()
-end
-
--- send postlogin to gameserver  kPacket_Post_Login 0x91
--- something is wrong...runuo &amp; wolfpack detects invalid client
--- answered by kPacket_Features 0xB9 (gClientFeatures)  and  kPacket_Chara=
cter_List 0xA9
-function ProtocolSend_GameServer_PostLogin(sName,sPassword,iAccount)
-	printdebug(&quot;login&quot;,sprintf(&quot;NET: GameServer_PostLogin: Name: %s Password:=
 %s AccountNr.: 0x%08x\n&quot;,sName,sPassword,iAccount))
-	local out =3D GetSendFIFO()
-	out:PushNetUint8(kPacket_Post_Login)
-	out:PushNetUint32(iAccount)
-	out:PushFilledString(sName,30)
-	out:PushFilledString(sPassword,30)
-	out:SendPacket()
-end
-
--- send characterselect to gameserver
-function ProtocolSend_Character_Select(iCharacterID,iAccount)
-	printdebug(&quot;login&quot;,sprintf(&quot;NET: Character_Select: %i Name: %s Password: =
%s AccountNr.:%x\n&quot;,
-			iCharacterID,gCharacterList[iCharacterID].name,gCharacterList[iCharacte=
rID].pw,iAccount))
-	local out =3D GetSendFIFO()
-	out:PushNetUint8(kPacket_Pre_Login)
-	out:PushNetUint32(hex2num(&quot;0xedededed&quot;))
-	out:PushFilledString(gCharacterList[iCharacterID].name,30)
-	out:PushFilledString(gCharacterList[iCharacterID].pw,30)
-	out:PushNetUint32(iCharacterID)
-	out:PushNetUint32(hex2num(&quot;0xC0A83016&quot;))	--out:PushNetUint32(gGameServerI=
P)		--TODO: check: iAccount or gGameServerIP
-	out:SendPacket()
-end
-
--- client identification
-function Send_ClientQuery(iMode,iCharacterID)
-	local out =3D GetSendFIFO()
-	out:PushNetUint8(kPacket_Client_Query)
-	out:PushNetUint32(hex2num(&quot;0xedededed&quot;))
-	out:PushNetUint8(iMode)
-	out:PushNetUint32(iCharacterID)
-	out:SendPacket()
-end
-
--- send combat request to server, triggers kPacket_Combat
-function Send_CombatMode(iWarMode)
-	local out =3D GetSendFIFO()
-	out:PushNetUint8(kPacket_Request_Assistance)
-	out:PushNetUint8(iWarMode)
-	out:PushNetUint16(hex2num(&quot;0x0032&quot;))
-	out:PushNetUint8(hex2num(&quot;0x00&quot;))
-	out:SendPacket()
-end
-
 -- request serverside helppage
 function Send_RequestHelp()
+	print(&quot;NET: Send_RequestHelp&quot;)
 	local out =3D GetSendFIFO()
 	out:PushNetUint8(kPacket_Request_Assistance)
 	for i=3D1, 257 do
@@ -240,4 +171,3 @@
 	out:PushNetUint32(serial)
 	out:SendPacket()
 end
-

Modified: branches/knut/data/lua/lib.walking2.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/lib.walking2.lua (original)
+++ branches/knut/data/lua/lib.walking2.lua Thu Aug  2 17:12:24 2007
@@ -1,175 +1,174 @@
--- Walking Implementation for PC
--- thx for helping to Arahil
-
-gDebugWalkingDetailed =3D true =

-
-function printwalkdebug (...) if (gDebugWalkingDetailed) then printdebug(&quot;=
walking&quot;,unpack(arg)) end end =

-
--- returns tiletype,zloc
-function GetAbsTile (xloc,yloc) =

-	return gGroundBlockLoader:GetTile(	math.floor(xloc/8), =

-										math.floor(yloc/8), =

-										math.mod(xloc,8), =

-										math.mod(yloc,8))
-end
-
---Calc the average Z Value for the new Player pos (don't use this for calc=
ulations)
-function AverageGroundHeight(bx,by,tx,ty)
-	local iTerrainTileType1,iTerrainZ1 =3D GetAbsTile(bx*8+tx,by*8+ty)
-	local iTerrainTileType2,iTerrainZ2 =3D GetAbsTile(bx*8+tx+1,by*8+ty)
-	local iTerrainTileType3,iTerrainZ3 =3D GetAbsTile(bx*8+tx,by*8+ty+1)
-	local iTerrainTileType4,iTerrainZ4 =3D GetAbsTile(bx*8+tx+1,by*8+ty+1)
-	local testz =3D 0
-	if ( math.abs(iTerrainZ1-iTerrainZ4) &lt;=3D math.abs(iTerrainZ2-iTerrainZ3)=
 ) then
-		if (gIllegalZ =3D=3D iTerrainZ4) then
-			testz =3D iTerrainZ1
-		else
-			testz =3D math.floor( ( iTerrainZ1 + iTerrainZ4 ) / 2.0)
-		end
-	else
-		if (gIllegalZ =3D=3D iTerrainZ2 or gIllegalZ =3D=3D iTerrainZ3) then
-			testz =3D iTerrainZ1
-		else
-			testz =3D math.floor( ( iTerrainZ2 + iTerrainZ3 ) / 2.0)
-		end
-	end
-	return testz
-end
-
-function isBridge(flag)
-	local bIsBridge=3Dfalse
-	if ((BitwiseAND(flag, kTileDataFlag_StairBack) ~=3D 0) or
-		(BitwiseAND(flag, kTileDataFlag_StairRight) ~=3D 0) or
-		(BitwiseAND(flag, kTileDataFlag_Bridge) ~=3D 0) ) then
-		bIsBridge=3Dtrue
-	end
-	return bIsBridge	=

-end
-
-function isSurface(flag)
-	local bIsSurface=3Dfalse
-
-	if (BitwiseAND(flag, kTileDataFlag_Surface) ~=3D 0) then
-		bIsSurface=3Dtrue
-	end
-
-	return bIsSurface
-end
-
-function isImpassable(flag)
-	local bIsImpassable=3Dfalse
-
-	if (BitwiseAND(flag, kTileDataFlag_Impassable) ~=3D 0) then
-		bIsImpassable=3Dtrue
-	end
-
-	return bIsImpassable
-end
-
-
--- a little helper for GetWalkingBlockFlags(...)
-function GetWalkingBlockFlagsHelper(zloc,artid,flaglist)
-	local t =3D GetStaticTileType(artid)
-	if (t) then
-		if ( not(isBridge(t.miFlags)) and not(isImpassable(t.miFlags)) and not(i=
sSurface(t.miFlags)) ) then
-			printwalkdebug(&quot;----&quot; .. t.msName ..&quot;  !impassable  !bridge  !surfacebl=
ocking&quot;)
-		else
-			local iHeight =3D t.miHeight
-			if (isBridge(t.miFlags)) then iHeight =3D iHeight/2 + 0.5 end -- TODO :=
 2 is the right value, but playerpos is to low
-			=

-			if (flaglist[zloc] =3D=3D nil) then
-				flaglist[zloc] =3D { }
-			end
-			=

-			flaglist[zloc].bSurface =3D flaglist[zloc].bSurface or isSurface(t.miFl=
ags)
-			flaglist[zloc].bBridge =3D flaglist[zloc].bBridge or isBridge (t.miFlag=
s)
-			=

-			if (iHeight &gt; 0) then
-				flaglist[zloc].bImpassable =3D flaglist[zloc].bImpassable or isImpassa=
ble(t.miFlags)
-				for j=3D1, iHeight-1, 1 do
-					if (flaglist[zloc + j] =3D=3D nil) then
-						flaglist[zloc + j] =3D { }
-					end
-					flaglist[zloc + j].bImpassable =3D flaglist[zloc + j].bImpassable or =
isImpassable(t.miFlags)
-					flaglist[zloc + j].bSurface =3D flaglist[zloc + j].bSurface or isSurf=
ace(t.miFlags)
-					flaglist[zloc + j].bBridge =3D flaglist[zloc + j].bBridge or isBridge=
 (t.miFlags) =

-				end
-				=

-				if (flaglist[zloc + iHeight] =3D=3D nil) then
-					flaglist[zloc + iHeight] =3D { }
-				end
-				flaglist[zloc + iHeight].bSurface =3D flaglist[zloc + iHeight].bSurfac=
e or isSurface(t.miFlags)
-				flaglist[zloc + iHeight].bBridge =3D flaglist[zloc + iHeight].bBridge =
or isBridge(t.miFlags) =

-			end
-			=

-			printwalkdebug(&quot;----&quot; .. t.msName ..&quot;  z=3D&quot; .. zloc .. &quot;  height=3D&quot; .=
. iHeight .. &quot; bImpassable=3D&quot; .. tostring(isImpassable(t.miFlags)) .. &quot; bS=
urface=3D&quot; .. tostring(isSurface(t.miFlags)) .. &quot; isBridge=3D&quot; .. tostring(=
isBridge(t.miFlags)))
-		end
-	end
-end
-
--- returns an array of flags (impassable, surface, maptile)
--- array might contain empty entries (meaning on the specific z level is n=
either something blocking nor a surface/maptile)
-function GetWalkingBlockFlags(bx, by, tx, ty)
-	printwalkdebug(&quot;--GetWalkingBlockFlags() for bx=3D&quot;..bx..&quot;  by=3D&quot;..by..&quot;=
  tx=3D&quot;..tx..&quot;  ty=3D&quot;..ty..&quot;  (&quot;..(bx*8 + tx)..&quot;/&quot;..(by*8+ty)..&quot;)&quot;) =

-	=

-	if ( not(gTileTypeLoader) ) then return {} end
-	local flaglist =3D { }
-	=

-	-- map
-	printwalkdebug(&quot;---Map&quot;)
-	=

-	local iMapTileType =3D gGroundBlockLoader:GetTile(bx,by,tx,ty)
-	local iMapTileZ =3D tonumber(AverageGroundHeight( bx, by, tx, ty))
-
-	--Seasonal Translation
-	local iTranstile=3DTranslateTileTypeID(iMapTileType, gSeasonSetting)
-	local miFlags,miTexID,msName =3D gTileTypeLoader:GetGroundTileType(iTrans=
tile)
-	=

-	-- ignore NoDraw Tiles
-	if (iMapTileType ~=3D hex2num(&quot;0x02&quot;)) then
-		flaglist[iMapTileZ] =3D { }
-		flaglist[iMapTileZ].bSurface =3D true
-		flaglist[iMapTileZ].bImpassable =3D isImpassable(miFlags)
-		flaglist[iMapTileZ].bMaptile =3D true
-		printwalkdebug(&quot;----Map Name=3D&quot; .. msName ..&quot;  Heigt=3D&quot; .. iMapTileZ .=
.&quot;   bSurface=3Dtrue  bImpassable=3D&quot; .. tostring(flaglist[iMapTileZ].bImpa=
ssable))
-	end
-	=

-	=

-	-- statics
-	printwalkdebug(&quot;---Statics&quot;)
-	=

-	local iStaticCount
-	if (gStaticBlockLoader) then
-		gStaticBlockLoader:Load(bx,by)
-		iStaticCount =3D gStaticBlockLoader:Count() -- operates on the block tha=
t was last loaded using :Load()
-	else
-		iStaticCount =3D 0
-	end
-	-- TODO : maybe include Seasonal translation also here!?
-	=

-	local iTileTypeID,iX,iY,iZ,iHue
-	for i =3D 0,iStaticCount-1 do
-		iTileTypeID,iX,iY,iZ,iHue =3D gStaticBlockLoader:GetStatic(i)
-		if (iX =3D=3D tx and iY =3D=3D ty) then
-			printwalkdebug(&quot;----new Static ID=3D&quot; .. iTileTypeID)
-			GetWalkingBlockFlagsHelper(iZ,iTileTypeID,flaglist)
-		end
-	end
-	=

-	-- dynamics
-	printwalkdebug(&quot;---Dynamics&quot;)
-	=

+-- Walking Implementation for PC
+-- thx for helping to Arahil
+
+gDebugWalkingDetailed =3D true =

+
+function printwalkdebug (...) if (gDebugWalkingDetailed) then printdebug(&quot;=
walking&quot;,unpack(arg)) end end =

+
+-- returns tiletype,zloc
+function GetAbsTile (xloc,yloc) =

+	return gGroundBlockLoader:GetTile(	math.floor(xloc/8), =

+										math.floor(yloc/8), =

+										math.mod(xloc,8), =

+										math.mod(yloc,8))
+end
+
+--Calc the average Z Value for the new Player pos (don't use this for calc=
ulations)
+function AverageGroundHeight(bx,by,tx,ty)
+	local iTerrainTileType1,iTerrainZ1 =3D GetAbsTile(bx*8+tx,by*8+ty)
+	local iTerrainTileType2,iTerrainZ2 =3D GetAbsTile(bx*8+tx+1,by*8+ty)
+	local iTerrainTileType3,iTerrainZ3 =3D GetAbsTile(bx*8+tx,by*8+ty+1)
+	local iTerrainTileType4,iTerrainZ4 =3D GetAbsTile(bx*8+tx+1,by*8+ty+1)
+	local testz =3D 0
+	if ( math.abs(iTerrainZ1-iTerrainZ4) &lt;=3D math.abs(iTerrainZ2-iTerrainZ3)=
 ) then
+		if (gIllegalZ =3D=3D iTerrainZ4) then
+			testz =3D iTerrainZ1
+		else
+			testz =3D math.floor( ( iTerrainZ1 + iTerrainZ4 ) / 2.0)
+		end
+	else
+		if (gIllegalZ =3D=3D iTerrainZ2 or gIllegalZ =3D=3D iTerrainZ3) then
+			testz =3D iTerrainZ1
+		else
+			testz =3D math.floor( ( iTerrainZ2 + iTerrainZ3 ) / 2.0)
+		end
+	end
+	return testz
+end
+
+function isBridge(flag)
+	local bIsBridge=3Dfalse
+	if ((BitwiseAND(flag, kTileDataFlag_StairBack) ~=3D 0) or
+		(BitwiseAND(flag, kTileDataFlag_StairRight) ~=3D 0) or
+		(BitwiseAND(flag, kTileDataFlag_Bridge) ~=3D 0) ) then
+		bIsBridge=3Dtrue
+	end
+	return bIsBridge	=

+end
+
+function isSurface(flag)
+	local bIsSurface=3Dfalse
+
+	if (BitwiseAND(flag, kTileDataFlag_Surface) ~=3D 0) then
+		bIsSurface=3Dtrue
+	end
+
+	return bIsSurface
+end
+
+function isImpassable(flag)
+	local bIsImpassable=3Dfalse
+
+	if (BitwiseAND(flag, kTileDataFlag_Impassable) ~=3D 0) then
+		bIsImpassable=3Dtrue
+	end
+
+	return bIsImpassable
+end
+
+
+-- a little helper for GetWalkingBlockFlags(...)
+function GetWalkingBlockFlagsHelper(zloc,artid,flaglist)
+	local t =3D GetStaticTileType(artid)
+	if (t) then
+		if ( not(isBridge(t.miFlags)) and not(isImpassable(t.miFlags)) and not(i=
sSurface(t.miFlags)) ) then
+			printwalkdebug(&quot;----&quot; .. t.msName ..&quot;  !impassable  !bridge  !surfacebl=
ocking&quot;)
+		else
+			local iHeight =3D t.miHeight
+			if (isBridge(t.miFlags)) then iHeight =3D iHeight/2 + 0.5 end -- TODO :=
 2 is the right value, but playerpos is to low
+			=

+			if (flaglist[zloc] =3D=3D nil) then
+				flaglist[zloc] =3D { }
+			end
+			=

+			flaglist[zloc].bSurface =3D flaglist[zloc].bSurface or isSurface(t.miFl=
ags)
+			flaglist[zloc].bBridge =3D flaglist[zloc].bBridge or isBridge (t.miFlag=
s)
+			=

+			if (iHeight &gt; 0) then
+				flaglist[zloc].bImpassable =3D flaglist[zloc].bImpassable or isImpassa=
ble(t.miFlags)
+				for j=3D1, iHeight-1, 1 do
+					if (flaglist[zloc + j] =3D=3D nil) then
+						flaglist[zloc + j] =3D { }
+					end
+					flaglist[zloc + j].bImpassable =3D flaglist[zloc + j].bImpassable or =
isImpassable(t.miFlags)
+					flaglist[zloc + j].bSurface =3D flaglist[zloc + j].bSurface or isSurf=
ace(t.miFlags)
+					flaglist[zloc + j].bBridge =3D flaglist[zloc + j].bBridge or isBridge=
 (t.miFlags) =

+				end
+				=

+				if (flaglist[zloc + iHeight] =3D=3D nil) then
+					flaglist[zloc + iHeight] =3D { }
+				end
+				flaglist[zloc + iHeight].bSurface =3D flaglist[zloc + iHeight].bSurfac=
e or isSurface(t.miFlags)
+				flaglist[zloc + iHeight].bBridge =3D flaglist[zloc + iHeight].bBridge =
or isBridge(t.miFlags) =

+			end
+			=

+			printwalkdebug(&quot;----&quot; .. t.msName ..&quot;  z=3D&quot; .. zloc .. &quot;  height=3D&quot; .=
. iHeight .. &quot; bImpassable=3D&quot; .. tostring(isImpassable(t.miFlags)) .. &quot; bS=
urface=3D&quot; .. tostring(isSurface(t.miFlags)) .. &quot; isBridge=3D&quot; .. tostring(=
isBridge(t.miFlags)))
+		end
+	end
+end
+
+-- returns an array of flags (impassable, surface, maptile)
+-- array might contain empty entries (meaning on the specific z level is n=
either something blocking nor a surface/maptile)
+function GetWalkingBlockFlags(bx, by, tx, ty)
+	printwalkdebug(&quot;--GetWalkingBlockFlags() for bx=3D&quot;..bx..&quot;  by=3D&quot;..by..&quot;=
  tx=3D&quot;..tx..&quot;  ty=3D&quot;..ty..&quot;  (&quot;..(bx*8 + tx)..&quot;/&quot;..(by*8+ty)..&quot;)&quot;) =

+	=

+	if ( not(gTileTypeLoader) ) then return {} end
+	local flaglist =3D { }
+	=

+	-- map
+	printwalkdebug(&quot;---Map&quot;)
+	=

+	local iMapTileType =3D gGroundBlockLoader:GetTile(bx,by,tx,ty)
+	local iMapTileZ =3D tonumber(AverageGroundHeight( bx, by, tx, ty))
+
+	--Seasonal Translation
+	local iTranstile=3DTranslateTileTypeID(iMapTileType, gSeasonSetting)
+	local miFlags,miTexID,msName =3D gTileTypeLoader:GetGroundTileType(iTrans=
tile)
+	=

+	-- ignore NoDraw Tiles
+	if (iMapTileType ~=3D hex2num(&quot;0x02&quot;)) then
+		flaglist[iMapTileZ] =3D { }
+		flaglist[iMapTileZ].bSurface =3D true
+		flaglist[iMapTileZ].bImpassable =3D isImpassable(miFlags)
+		flaglist[iMapTileZ].bMaptile =3D true
+		printwalkdebug(&quot;----Map Name=3D&quot; .. msName ..&quot;  Heigt=3D&quot; .. iMapTileZ .=
.&quot;   bSurface=3Dtrue  bImpassable=3D&quot; .. tostring(flaglist[iMapTileZ].bImpa=
ssable))
+	end
+	=

+	=

+	-- statics
+	printwalkdebug(&quot;---Statics&quot;)
+	=

+	local iStaticCount
+	if (gStaticBlockLoader) then
+		gStaticBlockLoader:Load(bx,by)
+		iStaticCount =3D gStaticBlockLoader:Count() -- operates on the block tha=
t was last loaded using :Load()
+	else
+		iStaticCount =3D 0
+	end
+	-- TODO : maybe include Seasonal translation also here!?
+	=

+	local iTileTypeID,iX,iY,iZ,iHue
+	for i =3D 0,iStaticCount-1 do
+		iTileTypeID,iX,iY,iZ,iHue =3D gStaticBlockLoader:GetStatic(i)
+		if (iX =3D=3D tx and iY =3D=3D ty) then
+			printwalkdebug(&quot;----new Static ID=3D&quot; .. iTileTypeID)
+			GetWalkingBlockFlagsHelper(iZ,iTileTypeID,flaglist)
+		end
+	end
+	=

+	-- dynamics
+	printwalkdebug(&quot;---Dynamics&quot;)
+	=

 	local xloc=3Dbx*8+tx
 	local yloc=3Dby*8+ty
-	for k,object in pairs(gObjectList) do =

-		if (object.isdynamic) then
-			local dynamic =3D object
+	for k,dynamic in pairs(GetDynamicList()) do =

+		if(dynamic.artid) then
 =

 			-- is this a normal statictile or multi?
 			if (dynamic.artid &gt;=3D gMulti_ID) then -- gMulti_ID + 100
 				if (dynamic.lTile) then
 					for k,v in pairs(dynamic.lTile) do
-						if ((dynamic.x+v.x) =3D=3D xloc and (dynamic.y+v.y) =3D=3D yloc) then
+						if ((dynamic.xloc+v.x) =3D=3D xloc and (dynamic.yloc+v.y) =3D=3D ylo=
c) then
 							printwalkdebug(&quot;----new serverside multi tile ID=3D&quot; .. v.artid)
 							GetWalkingBlockFlagsHelper(v.z,v.artid,flaglist)	-- todo flaglist
 				end
@@ -184,9 +183,9 @@
 					blocknum,x,y,z,flags =3D gMultiLoader:GetMultiParts(id,p)
 					=

 					local pxloc,pyloc,pzloc
-						pxloc =3D dynamic.x + x
-						pyloc =3D dynamic.y + y
-						pzloc =3D dynamic.z + z
+						pxloc =3D dynamic.xloc + x
+						pyloc =3D dynamic.yloc + y
+						pzloc =3D dynamic.zloc + z
 					=

 					if (flags =3D=3D 1 and pxloc =3D=3D xloc and pyloc =3D=3D yloc) then
 						printwalkdebug(&quot;----new dynamic ID=3D&quot; .. blocknum)
@@ -199,213 +198,213 @@
 			else
 				--elseif(dynamic.artid &lt; gMulti_ID + 100) then
 				-- no mulit just a normal tile
-				if (dynamic.x =3D=3D xloc and dynamic.y =3D=3D yloc) then
+				if (dynamic.xloc =3D=3D xloc and dynamic.yloc =3D=3D yloc) then
 					printwalkdebug(&quot;----new dynamic ID=3D&quot; .. dynamic.artid)
-					GetWalkingBlockFlagsHelper(dynamic.z,dynamic.artid,flaglist)
-				end
-			end
-		end
-	end
-	=

-	printwalkdebug(&quot;End GetWalkingBlockFlags()&quot;)
-	return flaglist
-end
-
-
--- check for free space (!impassable), char is 15 zlevels tall
--- if diagonalCheck is true land tiles above zloc+gMaxZ_Climb (resp. +5 fo=
r maptiles) are blocking, underneath they are ignored
--- returns true or false
-function CheckZSpace(flaglist, zloc, diagonalCheck, height)  =

-	diagonalCheck =3D diagonalCheck or false =

-	height =3D height or 15
-	for i=3D1, height, 1 do
-		if (flaglist[zloc+i] ~=3D nil) then
-			if (diagonalCheck) then
-				if (flaglist[zloc+i].bImpassable
-					or (flaglist[zloc+i].bMaptile and (i &gt; gMaxZ_Climb + 5)) =

-					or (flaglist[zloc+i].bSurface and (i &gt; gMaxZ_Climb))
-				) then
-					return false =

-				end
-			elseif (flaglist[zloc+i].bImpassable or flaglist[zloc+i].bSurface) then =

-				return false
-			end
-		end
-	end
-	=

-	return true
-end
-
-
--- check adjacent coordinates when walking diagonally
--- OSI is not looking for a surface on those tiles, it only checks that th=
ere is nothing blocking
--- OSI takes the current z level to check for that, not the z level of the=
 target tile
--- returns true or false
-function CheckAdjacentTiles(bx, by, tx, ty, iDir, iStartZ)
-	local bDiagonal
-	local diagonalFlagList1, diagonalFlagList2
-	printwalkdebug(&quot;------direction: &quot;..iDir)
-	if (iDir =3D=3D 1) then --northeast (right)
-		bDiagonal =3D true
-		if (tx =3D=3D 0) then
-			diagonalFlagList1 =3D GetWalkingBlockFlags(bx-1, by, 7, ty)
-		else
-			diagonalFlagList1 =3D GetWalkingBlockFlags(bx, by, tx-1, ty)
-		end
-		=

-		if (ty =3D=3D 7) then
-			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by+1, tx, 0)
-		else
-			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by, tx, ty+1)
-		end
-							=

-	elseif (iDir =3D=3D 3) then --southeast (down)
-		bDiagonal =3D true
-		if (tx =3D=3D 0) then
-			diagonalFlagList1 =3D GetWalkingBlockFlags(bx-1, by, 7, ty)
-		else
-			diagonalFlagList1 =3D GetWalkingBlockFlags(bx, by, tx-1, ty)
-		end
-		=

-		if (ty =3D=3D 0) then
-			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by-1, tx, 7)
-		else
-			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by, tx, ty-1)
-		end
-		=

-	elseif (iDir =3D=3D 5) then --southwest (left)
-		bDiagonal =3D true
-		if (tx =3D=3D 7) then
-			diagonalFlagList1 =3D GetWalkingBlockFlags(bx+1, by, 0, ty)
-		else
-			diagonalFlagList1 =3D GetWalkingBlockFlags(bx, by, tx+1, ty)
-		end
-		=

-		if (ty =3D=3D 0) then
-			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by-1, tx, 7)
-		else
-			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by, tx, ty-1)
-		end
-		=

-	elseif (iDir =3D=3D 7) then --northwest (up)
-		bDiagonal =3D true
-		if (tx =3D=3D 7) then
-			diagonalFlagList1 =3D GetWalkingBlockFlags(bx+1, by, 0, ty)
-		else
-			diagonalFlagList1 =3D GetWalkingBlockFlags(bx, by, tx+1, ty)
-		end
-		=

-		if (ty =3D=3D 7) then
-			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by+1, tx, 0)
-		else
-			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by, tx, ty+1)
-		end
-	end
-			=

-	if (bDiagonal) then
-		printwalkdebug(&quot;------walking diagonally&quot;)
-				=

-		if (CheckZSpace(diagonalFlagList1, iStartZ, true) and CheckZSpace(diagon=
alFlagList2, iStartZ, true)) then
-			printwalkdebug(&quot;-------no obstacles on adjacent coordinates&quot;)
-			return true
-		else
-			printwalkdebug(&quot;-------adjacent tiles are not free to walk, blocking&quot;)
-			return false
-		end
-	else
-		return true
-	end
-end
-
-
-
--- Can walk the tile, the tile's height and if the tile's a stair
--- (about 30 in int, or 3.0 in float (*0.1) is the height of a door)
--- two values are returned: is walkable, new Z Level
-function GetNearestGroundLevel (bx,by,tx,ty,iStartZ,iDir)
-	local Walking_Start =3D Client_GetTicks()
-	printwalkdebug(&quot;-------------------&quot;)
-	printwalkdebug(&quot;GetNearestGroundLevel()&quot;)
-	=

-	if ( (tx &gt;=3D 8) or (ty &gt;=3D 8) or (tx &lt; 0) or (ty &lt; 0)) then return fals=
e, 255 end
-	if (not gGroundBlockLoader) then return false, 255 end
-
-	printwalkdebug(&quot;iStartZ=3D&quot;..iStartZ)
-	=

-	local flaglist =3D GetWalkingBlockFlags(bx, by, tx, ty)
-	=

-	printwalkdebug(&quot;--------------------&quot;)
-	printwalkdebug(&quot;List output:&quot;)
-	for index, value in pairs(flaglist) do
-		printwalkdebug(&quot;z=3D&quot; .. index .. &quot;   bSurface=3D&quot; .. tostring(flaglist[=
index].bSurface) .. &quot;  bImpassable=3D&quot; .. tostring(flaglist[index].bImpassa=
ble).. &quot;  bBridge=3D&quot; .. tostring(flaglist[index].bBridge))
-	end
-
-	printwalkdebug(&quot;--------------------&quot;)
-	=

-	=

-	-- find closest surface (z + 0, -1, +1, -2, +2 etc)
-	-- check for maxfall and maxclimb
-	-- if surface is maptile +5 climbing bonus
-	=

-	local iCur
-	for i=3D0, math.max((gMaxZ_Climb + 5), gMaxZ_Fall), 1 do
-		iCur =3D iStartZ + i
-		if (i ~=3D 0 and flaglist[iCur] ~=3D nil) then
-			printwalkdebug(&quot;-----iCur=3D&quot; .. iCur)
-			if (i &lt; gMaxZ_Climb or (i &lt; (gMaxZ_Climb + 5) and (flaglist[iCur].bMapt=
ile or flaglist[iCur].bBridge))) then
-				if ((not flaglist[iCur].bImpassable) and flaglist[iCur].bSurface) then
-					printwalkdebug(&quot;------found Surface&quot;);
-					if (CheckZSpace(flaglist, iCur)) then
-						printwalkdebug(&quot;------checkSpace successful&quot;)
-						=

-						local bAdjacent =3D CheckAdjacentTiles(bx, by, tx, ty, iDir, iStartZ)
-						=

-						printwalkdebug(&quot;End GetNearestGroundLevel()&quot;)
-						printwalkdebug(&quot;----------------------------&quot;)
-						printwalkdebug()
-						printdebug(&quot;walking&quot;,sprintf( &quot;Walking calculations took %d msec.\n&quot;=
, Client_GetTicks() - Walking_Start ))
-						if (bAdjacent) then
-							return true, iCur
-						else
-							return false, 255
-						end
-					end
-				end
-			end
-		end
-		=

-		=

-		iCur =3D iStartZ - i
-		if (flaglist[iCur] ~=3D nil) then
-			printwalkdebug(&quot;-----iCur=3D&quot; .. iCur)
-			if (i &lt; gMaxZ_Fall) then
-				if ((not flaglist[iCur].bImpassable) and flaglist[iCur].bSurface) then
-					printwalkdebug(&quot;------found Surface&quot;);
-					if (CheckZSpace(flaglist, iCur)) then
-						printwalkdebug(&quot;------ checkSpace successful&quot;)
-						=

-						local bAdjacent =3D CheckAdjacentTiles(bx, by, tx, ty, iDir, iStartZ)
-						=

-						printwalkdebug(&quot;End GetNearestGroundLevel()&quot;)
-						printwalkdebug(&quot;----------------------------&quot;)
-						printwalkdebug()
-						printdebug(&quot;walking&quot;,sprintf( &quot;Walking calculations took %d msec.\n&quot;=
, Client_GetTicks() - Walking_Start ))
-						if (bAdjacent) then
-							return true, iCur
-						else
-							return false, 255
-						end
-					end
-				end
-			end
-		end
-	end
-	=

-	-- if there was no space to walk through found, return false
-	printwalkdebug(&quot;End GetNearestGroundLevel()&quot;)
-	printwalkdebug(&quot;returning false&quot;)
-	printwalkdebug(&quot;----------------------------&quot;)
-	=

-	printdebug(&quot;walking&quot;,sprintf( &quot;Walking calculations took %d msec.\n&quot;, Cli=
ent_GetTicks() - Walking_Start ))
-	return false, 255 =

-end
+					GetWalkingBlockFlagsHelper(dynamic.zloc,dynamic.artid,flaglist)
+				end
+			end
+		end
+	end
+	=

+	printwalkdebug(&quot;End GetWalkingBlockFlags()&quot;)
+	return flaglist
+end
+
+
+-- check for free space (!impassable), char is 15 zlevels tall
+-- if diagonalCheck is true land tiles above zloc+gMaxZ_Climb (resp. +5 fo=
r maptiles) are blocking, underneath they are ignored
+-- returns true or false
+function CheckZSpace(flaglist, zloc, diagonalCheck, height)  =

+	diagonalCheck =3D diagonalCheck or false =

+	height =3D height or 15
+	for i=3D1, height, 1 do
+		if (flaglist[zloc+i] ~=3D nil) then
+			if (diagonalCheck) then
+				if (flaglist[zloc+i].bImpassable
+					or (flaglist[zloc+i].bMaptile and (i &gt; gMaxZ_Climb + 5)) =

+					or (flaglist[zloc+i].bSurface and (i &gt; gMaxZ_Climb))
+				) then
+					return false =

+				end
+			elseif (flaglist[zloc+i].bImpassable or flaglist[zloc+i].bSurface) then =

+				return false
+			end
+		end
+	end
+	=

+	return true
+end
+
+
+-- check adjacent coordinates when walking diagonally
+-- OSI is not looking for a surface on those tiles, it only checks that th=
ere is nothing blocking
+-- OSI takes the current z level to check for that, not the z level of the=
 target tile
+-- returns true or false
+function CheckAdjacentTiles(bx, by, tx, ty, iDir, iStartZ)
+	local bDiagonal
+	local diagonalFlagList1, diagonalFlagList2
+	printwalkdebug(&quot;------direction: &quot;..iDir)
+	if (iDir =3D=3D 1) then --northeast (right)
+		bDiagonal =3D true
+		if (tx =3D=3D 0) then
+			diagonalFlagList1 =3D GetWalkingBlockFlags(bx-1, by, 7, ty)
+		else
+			diagonalFlagList1 =3D GetWalkingBlockFlags(bx, by, tx-1, ty)
+		end
+		=

+		if (ty =3D=3D 7) then
+			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by+1, tx, 0)
+		else
+			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by, tx, ty+1)
+		end
+							=

+	elseif (iDir =3D=3D 3) then --southeast (down)
+		bDiagonal =3D true
+		if (tx =3D=3D 0) then
+			diagonalFlagList1 =3D GetWalkingBlockFlags(bx-1, by, 7, ty)
+		else
+			diagonalFlagList1 =3D GetWalkingBlockFlags(bx, by, tx-1, ty)
+		end
+		=

+		if (ty =3D=3D 0) then
+			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by-1, tx, 7)
+		else
+			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by, tx, ty-1)
+		end
+		=

+	elseif (iDir =3D=3D 5) then --southwest (left)
+		bDiagonal =3D true
+		if (tx =3D=3D 7) then
+			diagonalFlagList1 =3D GetWalkingBlockFlags(bx+1, by, 0, ty)
+		else
+			diagonalFlagList1 =3D GetWalkingBlockFlags(bx, by, tx+1, ty)
+		end
+		=

+		if (ty =3D=3D 0) then
+			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by-1, tx, 7)
+		else
+			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by, tx, ty-1)
+		end
+		=

+	elseif (iDir =3D=3D 7) then --northwest (up)
+		bDiagonal =3D true
+		if (tx =3D=3D 7) then
+			diagonalFlagList1 =3D GetWalkingBlockFlags(bx+1, by, 0, ty)
+		else
+			diagonalFlagList1 =3D GetWalkingBlockFlags(bx, by, tx+1, ty)
+		end
+		=

+		if (ty =3D=3D 7) then
+			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by+1, tx, 0)
+		else
+			diagonalFlagList2 =3D GetWalkingBlockFlags(bx, by, tx, ty+1)
+		end
+	end
+			=

+	if (bDiagonal) then
+		printwalkdebug(&quot;------walking diagonally&quot;)
+				=

+		if (CheckZSpace(diagonalFlagList1, iStartZ, true) and CheckZSpace(diagon=
alFlagList2, iStartZ, true)) then
+			printwalkdebug(&quot;-------no obstacles on adjacent coordinates&quot;)
+			return true
+		else
+			printwalkdebug(&quot;-------adjacent tiles are not free to walk, blocking&quot;)
+			return false
+		end
+	else
+		return true
+	end
+end
+
+
+
+-- Can walk the tile, the tile's height and if the tile's a stair
+-- (about 30 in int, or 3.0 in float (*0.1) is the height of a door)
+-- two values are returned: is walkable, new Z Level
+function GetNearestGroundLevel (bx,by,tx,ty,iStartZ,iDir)
+	local Walking_Start =3D Client_GetTicks()
+	printwalkdebug(&quot;-------------------&quot;)
+	printwalkdebug(&quot;GetNearestGroundLevel()&quot;)
+	=

+	if ( (tx &gt;=3D 8) or (ty &gt;=3D 8) or (tx &lt; 0) or (ty &lt; 0)) then return fals=
e, 255 end
+	if (not gGroundBlockLoader) then return false, 255 end
+
+	printwalkdebug(&quot;iStartZ=3D&quot;..iStartZ)
+	=

+	local flaglist =3D GetWalkingBlockFlags(bx, by, tx, ty)
+	=

+	printwalkdebug(&quot;--------------------&quot;)
+	printwalkdebug(&quot;List output:&quot;)
+	for index, value in pairs(flaglist) do
+		printwalkdebug(&quot;z=3D&quot; .. index .. &quot;   bSurface=3D&quot; .. tostring(flaglist[=
index].bSurface) .. &quot;  bImpassable=3D&quot; .. tostring(flaglist[index].bImpassa=
ble).. &quot;  bBridge=3D&quot; .. tostring(flaglist[index].bBridge))
+	end
+
+	printwalkdebug(&quot;--------------------&quot;)
+	=

+	=

+	-- find closest surface (z + 0, -1, +1, -2, +2 etc)
+	-- check for maxfall and maxclimb
+	-- if surface is maptile +5 climbing bonus
+	=

+	local iCur
+	for i=3D0, math.max((gMaxZ_Climb + 5), gMaxZ_Fall), 1 do
+		iCur =3D iStartZ + i
+		if (i ~=3D 0 and flaglist[iCur] ~=3D nil) then
+			printwalkdebug(&quot;-----iCur=3D&quot; .. iCur)
+			if (i &lt; gMaxZ_Climb or (i &lt; (gMaxZ_Climb + 5) and (flaglist[iCur].bMapt=
ile or flaglist[iCur].bBridge))) then
+				if ((not flaglist[iCur].bImpassable) and flaglist[iCur].bSurface) then
+					printwalkdebug(&quot;------found Surface&quot;);
+					if (CheckZSpace(flaglist, iCur)) then
+						printwalkdebug(&quot;------checkSpace successful&quot;)
+						=

+						local bAdjacent =3D CheckAdjacentTiles(bx, by, tx, ty, iDir, iStartZ)
+						=

+						printwalkdebug(&quot;End GetNearestGroundLevel()&quot;)
+						printwalkdebug(&quot;----------------------------&quot;)
+						printwalkdebug()
+						printdebug(&quot;walking&quot;,sprintf( &quot;Walking calculations took %d msec.\n&quot;=
, Client_GetTicks() - Walking_Start ))
+						if (bAdjacent) then
+							return true, iCur
+						else
+							return false, 255
+						end
+					end
+				end
+			end
+		end
+		=

+		=

+		iCur =3D iStartZ - i
+		if (flaglist[iCur] ~=3D nil) then
+			printwalkdebug(&quot;-----iCur=3D&quot; .. iCur)
+			if (i &lt; gMaxZ_Fall) then
+				if ((not flaglist[iCur].bImpassable) and flaglist[iCur].bSurface) then
+					printwalkdebug(&quot;------found Surface&quot;);
+					if (CheckZSpace(flaglist, iCur)) then
+						printwalkdebug(&quot;------ checkSpace successful&quot;)
+						=

+						local bAdjacent =3D CheckAdjacentTiles(bx, by, tx, ty, iDir, iStartZ)
+						=

+						printwalkdebug(&quot;End GetNearestGroundLevel()&quot;)
+						printwalkdebug(&quot;----------------------------&quot;)
+						printwalkdebug()
+						printdebug(&quot;walking&quot;,sprintf( &quot;Walking calculations took %d msec.\n&quot;=
, Client_GetTicks() - Walking_Start ))
+						if (bAdjacent) then
+							return true, iCur
+						else
+							return false, 255
+						end
+					end
+				end
+			end
+		end
+	end
+	=

+	-- if there was no space to walk through found, return false
+	printwalkdebug(&quot;End GetNearestGroundLevel()&quot;)
+	printwalkdebug(&quot;returning false&quot;)
+	printwalkdebug(&quot;----------------------------&quot;)
+	=

+	printdebug(&quot;walking&quot;,sprintf( &quot;Walking calculations took %d msec.\n&quot;, Cli=
ent_GetTicks() - Walking_Start ))
+	return false, 255 =

+end

Modified: branches/knut/data/lua/main.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/main.lua (original)
+++ branches/knut/data/lua/main.lua Thu Aug  2 17:12:24 2007
@@ -211,8 +211,8 @@
 =

 	if (gStartInDebugMode) then StopMainMenu() StartDebugMenu() end
 =

-	TestGuiSystem2_Init()
-	TestGuiSystem3_Init()
+	--TestGuiSystem2_Init()
+	--TestGuiSystem3_Init()
 	=

 	-- mainloop
 	while (Client_IsAlive()) do
@@ -254,7 +254,7 @@
 	if (gInGameStarted) then
 		gCurrentRenderer:UpdateMap()
 		gCurrentRenderer:MousePickStep()
-		DragDropStep()
+		StepUODragDrop()
 		WalkStep()
 		PingStep()
 		gCurrentRenderer:CombatGuiStep()

Modified: branches/knut/data/lua/net.login.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/net.login.lua (original)
+++ branches/knut/data/lua/net.login.lua Thu Aug  2 17:12:24 2007
@@ -277,13 +277,13 @@
 =

 -- send login server request 0x80
 -- answered by 0xA8 kPacket_Server_List which calls MainMenuShowServerList
-function ProtocolSend_Account_Login_Request	(sName,sPassword)
+function ProtocolSend_Account_Login_Request	(sName,sPassword,iSeed)
 	printdebug(&quot;login&quot;,sprintf(&quot;NET: Account_Login_Request: Name: %s Password=
:<i> %s\n&quot;,sName,sPassword))
</I> 	local out =3D GetSendFIFO()
 	out:PushNetUint8(kPacket_Account_Login_Request)
 	out:PushFilledString(sName,30)
 	out:PushFilledString(sPassword,30)
-	out:PushNetUint8(hex2num(&quot;0x5D&quot;))
+	out:PushNetUint8(iSeed or hex2num(&quot;0x5D&quot;))
 	out:SendPacket()
 end
 =


Modified: branches/knut/data/lua/net.other.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/net.other.lua (original)
+++ branches/knut/data/lua/net.other.lua Thu Aug  2 17:12:24 2007
@@ -371,7 +371,7 @@
 -- prevents the answer to the tooltipp request from being displayed as nor=
mal message
 -- returns true if the info was caught and should not be displayed
 function CatchTooltippRequest (serial,model,charname,message) =

-	local mobile =3D gObjectList[serial]
+	local mobile =3D GetMobile(serial)
 	=

 	if (mobile) then
 		if (charname =3D=3D message) then
@@ -383,7 +383,7 @@
 		end
 		if (not mobile.name) then =

 			mobile.name =3D charname
-			--mobile:update() -- TODO : set mobile name
+			UpdateMobile(mobile) -- TODO : set mobile name
 			if (charname ~=3D message) then print(&quot;CatchTooltippRequest : unexpecte=
d text:&quot;,charname,message) return false end
 			return true
 		end
@@ -416,7 +416,7 @@
 	local plaintext =3D string.gsub(text_message,&quot;&lt;br&gt;&quot;,&quot;\n&quot;)
 	AddFadeLines(sprintf(&quot;%s: %s&quot;,text_charname,plaintext)) -- TODO : color,f=
ont,...
 	=

-	-- MobileDisplayTextOverHead(text_item_serial,string.gsub(text_message,&quot;&lt;=
br&gt;&quot;,&quot;\n&quot;),Uo16Color2Rgb(text_color))
+	MobileDisplayTextOverHead(text_item_serial,string.gsub(text_message,&quot;&lt;br&gt;=
&quot;,&quot;\n&quot;),Uo16Color2Rgb(text_color))
 	=

 	-- TODO : text_item ?!?
 	-- TODO : JournalAddEntry(somefunc(text_type),text_charname,text_message)
@@ -504,7 +504,7 @@
 	-- TODO : JournalAddEntry(somefunc(text_type),text_charname,text_message)
 	=

 	-- show text over player head
-	-- MobileDisplayTextOverHead(unitext_speakerid,string.gsub(unitext_messag=
e,&quot;&lt;br&gt;&quot;,&quot;\n&quot;),Uo16Color2Rgb(unitext_hue))
+	MobileDisplayTextOverHead(unitext_speakerid,string.gsub(unitext_message,&quot;=
&lt;br&gt;&quot;,&quot;\n&quot;),Uo16Color2Rgb(unitext_hue))
 end
 =

 -- TODO : question : ghoulsblade : is this only for combat ? sience: don't=
 know -&gt; verify

Modified: branches/knut/data/lua/net.trade.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/net.trade.lua (original)
+++ branches/knut/data/lua/net.trade.lua Thu Aug  2 17:12:24 2007
@@ -71,10 +71,10 @@
 		if (not playerMobile)				then print(&quot;FATAL : kPacket_Shop_Sell : playerM=
obile not found&quot;) Crash() end
 	=

 		if (true) then -- debug
-			for k,item in pairs(playerBackpackContainer.content) do =

+			for k,item in pairs(GetContainerContentList(playerBackpackContainer)) d=
o =

 				printf(&quot;item serial=3D0x%08x artid=3D0x%04x in backpack\n&quot;,item.serial=
,item.artid)
 			end
-			for k,item in pairs(playerMobile.content) do =

+			for k,item in pairs(GetMobileEquipmentList(playerMobile)) do =

 				printf(&quot;item serial=3D0x%08x artid=3D0x%04x equipped\n&quot;,item.serial,it=
em.artid)
 			end
 		end
@@ -91,8 +91,9 @@
 			good.name 		=3D input:PopFilledString(good.namelen)
 			good.tradeamount=3D 0
 			good.index 		=3D i
-			good.item		=3D gObjectList[good.itemserial]
-			=

+			good.item		=3D GetObjectBySerial(good.itemserial)
+			--- old : see also playerBackpackContainer.items[good.itemserial]			=

+
 			if (good.item) then -- item is not always available, especially if its =
in the backpack, and that has not been opened yet
 				if (good.itemartid ~=3D good.item.artid)	then printf(&quot;FATAL : kPacket_=
Shop_Sell : artid mismatch 0x%04x !=3D 0x%04x\n&quot;,good.itemartid,good.item.a=
rtid) Crash()  end
 				if (good.itemamount ~=3D good.item.amount)	then printf(&quot;FATAL : kPacke=
t_Shop_Sell : amount mismatch 0x%04x !=3D 0x%04x\n&quot;,good.itemamount,good.it=
em.amount) Crash()  end
@@ -397,7 +398,7 @@
 =

 function GetShopMobileID (shop)
 	if (shop.shopMobileID) then return shop.shopMobileID end -- only set for =
sell-shop
-	local shopContainerItem =3D gObjectList[shop.shopContainerID]
+	local shopContainerItem =3D GetObjectBySerial(shop.shopContainerID)
 	if (not shopContainerItem) then printf(&quot;FATAL : GetShopMobileID : shopCon=
tainerItem not found %08x\n&quot;,shop.shopContainerID) return end
 	local shopmobile =3D shopContainerItem.mobile
 	if (not shopmobile) then printf(&quot;FATAL : GetShopMobileID : shopmobile not=
 found for container %08x\n&quot;,shop.shopContainerID) return end

Modified: branches/knut/data/lua/net.uodragdrop.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/net.uodragdrop.lua (original)
+++ branches/knut/data/lua/net.uodragdrop.lua Thu Aug  2 17:12:24 2007
@@ -122,6 +122,7 @@
 end
 =

 function StepUODragDrop () =

+	if (true) then DragDropStep() return end
 	-- start dragdrop if the mouse is dragged for a minimum distance
 	if (gDragDrop and (not gDragDrop.started)) then =

 		local iMouseX,iMouseY =3D PollInput()
@@ -260,7 +261,7 @@
 		local iTileTypeID =3D item.artid -- can come from paperdoll or container=
 or dynamic
 		local layer =3D GetPaperdollLayerFromTileType(iTileTypeID)
 		local mobileserial =3D paperdoll.mobileserial
-		local mobile =3D gObjectList[mobileserial]
+		local mobile =3D GetMobile(mobileserial)
 		print(&quot;MouseUpUODragDrop: drop on paperdoll &quot;,item.serial,item.amount,iT=
ileTypeID,layer,paperdoll.mobileserial)
 		if (not layer) then
 			print(&quot;CompleteUODragDrop : item is not wearable&quot;,vardump(item))
@@ -268,7 +269,7 @@
 		elseif (not mobile) then
 			print(&quot;CompleteUODragDrop : paperdoll mobile not found&quot;,vardump(item))
 			CancelUODragDrop()
-		elseif (mobile:getequipment(layer)) then
+		elseif (GetMobileEquipmentItem(mobile,layer)) then
 			print(&quot;CompleteUODragDrop : layer already full&quot;,vardump(item))
 			-- TODO : if layer is not empty, drop dragged item to backpack, take it=
em from layer to backpack, equip dragged item
 			-- NOTE : if layer is not empty and it's not possible to put item to ba=
ckpack -&gt; check and solve this problem!

Modified: branches/knut/data/lua/net.walk.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/net.walk.lua (original)
+++ branches/knut/data/lua/net.walk.lua Thu Aug  2 17:12:24 2007
@@ -80,7 +80,7 @@
 	=

 		-- destroy objects outside view range
 		for k,object in pairs(gObjectList) do =

-			if ((not object.container) and IsObjectFarEnoughToDestroy(object.x,obje=
ct.y)) then
+			if ((not object.container) and IsObjectFarEnoughToDestroy(object.xloc,o=
bject.yloc)) then
 				object:delete()
 			end
 		end
@@ -113,7 +113,7 @@
 gNextAutoWalkCheck =3D 0
 -- timeout to next autowalk check on pressed right button
 gNextAutoWalkCheckTimeout =3D 500
--- if this is &gt; 0 and the mobile (given as serial) is existing in gObjectL=
ist, autowalk tries to follow the mobile
+-- if this is &gt; 0 and the mobile (given as serial) is existing, autowalk t=
ries to follow the mobile
 gFollowMobile =3D 0
 function WalkStep ()
 	-- runnung if shift is pressed
@@ -129,7 +129,7 @@
 	=

 	-- follow target
 	if (gFollowMobile ~=3D 0) then
-		local target =3D gObjectList[gFollowMobile]
+		local target =3D GetMobile(gFollowMobile)
 		if target then
 			SetAutoWalkTo(target.xloc, target.yloc,true)
 		else
@@ -221,7 +221,7 @@
 =

 -- will follow a given mobile
 function SetFollowMobile (serial)
-	local target =3D gObjectList[serial]
+	local target =3D GetMobile(serial)
 	if target then
 		gFollowMobile =3D serial
 		SetAutoWalkTo(target.xloc, target.yloc , true)

Modified: branches/knut/data/lua/net/net.main.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/net/net.main.lua (original)
+++ branches/knut/data/lua/net/net.main.lua Thu Aug  2 17:12:24 2007
@@ -9,4 +9,4 @@
 dofile(libpath .. &quot;net/net.packethandlers.lua&quot;)
 =

 gLastDoubleClickSerial =3D 0
-gLastResyncRequest =3D nil
+

Modified: branches/knut/data/lua/net/net.mobile.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/net/net.mobile.lua (original)
+++ branches/knut/data/lua/net/net.mobile.lua Thu Aug  2 17:12:24 2007
@@ -1,257 +1,257 @@
--- simple mobile, no equipment, fixed size packet 0x77
-function gPacketHandler.kPacket_Naked_MOB ()
-	local packet =3D {}
-	local input =3D GetRecvFIFO()
-	=

-	local packetid =3D input:PopNetUint8()
-	packet.serial =3D input:PopNetUint32()
-	packet.body =3D input:PopNetUint16()
-	packet.x =3D input:PopNetUint16()
-	packet.y =3D input:PopNetUint16()
-	packet.z =3D input:PopInt8()
-	packet.dir =3D input:PopNetUint8()
-	packet.hue =3D input:PopNetUint16()
-	packet.flag =3D input:PopNetUint8()
-	packet.notoriety =3D input:PopNetUint8()
-	=

-	local mobile =3D gObjectList[packet.serial]	=

-	if (not mobile) then
-		mobile =3D CreateMobile( packet )
-	end
-	=

-	mobile:update( packet )
-end
-
--- equipped mobile packet (0x78)
-function gPacketHandler.kPacket_Equipped_MOB()
-	local packet =3D {}
-	local input =3D GetRecvFIFO()
-	=

-	local fifolen_start =3D input:Size()
-	local packetid =3D input:PopNetUint8()
-	local iPacketSize =3D input:PopNetUint16()
-	=

-	packet.serial =3D input:PopNetUint32()
-	packet.body =3D input:PopNetUint16()
-	-- maybe it is necessary to read amount here, if this packet is used for =
a corpse
-	=

-	packet.x =3D input:PopNetUint16()
-	packet.y =3D input:PopNetUint16()
-	packet.z =3D input:PopInt8()
-	packet.dir =3D input:PopNetUint8()
-	packet.hue =3D input:PopNetUint16()
-	packet.flag =3D input:PopNetUint8()
-	packet.notoriety =3D input:PopNetUint8()
-	=

-	local mobile =3D gObjectList[packet.serial] =

-	if (not mobile) then
-		mobile =3D CreateMobile( packet )
-	end
-	=

-	mobile:update( packet )
-	=

-	local loopalive =3D true
-	while loopalive do =

-		local packet_dynamic =3D {}
-		if ( iPacketSize &gt;=3D (fifolen_start - input:Size()+4) ) then
-			packet_dynamic.serial =3D input:PopNetUint32()
-			if ( packet_dynamic.serial =3D=3D 0 ) then
-				loopalive =3D false
-			else
-				if ( iPacketSize &gt;=3D (fifolen_start - input:Size()+3) ) then
-					packet_dynamic.artid =3D input:PopNetUint16()
-					packet_dynamic.layer =3D input:PopNetUint8()
-					=

-					if ((BitwiseAND(packet_dynamic.artid,hex2num(&quot;0x8000&quot;)) ~=3D 0) and (=
 iPacketSize &gt;=3D (fifolen_start - input:Size()+2) )) then
-						packet_dynamic.hue =3D input:PopNetUint16()
-					else
-						packet_dynamic.hue =3D 0
-					end
-					packet_dynamic.artid =3D BitwiseAND(packet_dynamic.artid,hex2num(&quot;0x7=
fff&quot;))
-					=

-					dynamic =3D gObjectList[ packet_dynamic.serial ]
-					if (not dynamic) then
-						dynamic =3D CreateDynamic( packet_dynamic )
-					end
-					=

-					dynamic:update( packet_dynamic )
-					dynamic:setcontainer( mobile )
-				else
-					loopalive =3D false
-				end
-			end
-		else
-			loopalive =3D false
-		end
-	end
-end
-
--- Teleport packet (also known as ProtocolRecv_Draw_Player) (0x20)
-function gPacketHandler.kPacket_Teleport()
-	gLastResyncRequest =3D nil
-	=

-	local input =3D GetRecvFIFO()
-	local id =3D input:PopNetUint8()
-	packet =3D {}
-	packet.serial	=3D input:PopNetUint32()
-	packet.body	=3D input:PopNetUint16()
-	packet.unknown1 =3D input:PopNetUint8()
-	packet.hue	=3D input:PopNetUint16()
-	packet.flag	=3D input:PopNetUint8()
-	packet.x	=3D input:PopNetUint16()
-	packet.y	=3D input:PopNetUint16()
-	packet.unknown2 =3D input:PopNetUint16()
-	packet.dir	=3D input:PopNetUint8()
-	packet.z	=3D input:PopInt8()
-	=

-	gCurrentRenderer:ClientSideMobileAnimPlayerTeleported()
-
-	local mobile =3D gObjectList[packet.serial] =

-	if (not mobile) then
-		mobile =3D CreateMobile( packet )
-	end
-	=

-	mobile:update( packet )
-	-- set player pos after updating mobile, otherwise the mobile may be dele=
ted as its out of range
-	SetPlayerPos( packet.x, packet.y, packet.z, packet.dir )
-
-	ResetWalkQueue()
-end
-
--- Character Animation (0x6e)
-function gPacketHandler.kPacket_Animation ()
-	local input =3D GetRecvFIFO()
-	local packetid =3D input:PopNetUint8()
-	=

-	local packet =3D {}
-	packet.mobileserial	=3D input:PopNetUint32()	=

-	packet.m_animation	=3D input:PopNetUint16()
-	packet.m_framecount	=3D input:PopNetUint16()
-	packet.m_repeat		=3D input:PopNetUint16()	--repeat (1 =3D once / 2 =3D tw=
ice / 0 =3D repeat forever)
-	packet.m_animForward	=3D input:PopNetUint8()	--(0x00=3Dforward, 0x01=3Dba=
ckwards)
-	packet.m_repeatFlag	=3D input:PopNetUint8()	--(0 - Don't repeat / 1 repea=
t)
-	packet.m_frameDelay	=3D input:PopNetUint8()	--(0x00 - fastest / 0xFF - To=
o slow to watch)
-	=

-	local mobile =3D gObjectList[packet.serial] =

-	if (mobile) then
-		mobile:DoAnimation( packet )
-	end
-end
-
--- mobile status (0x11)
-function gPacketHandler.kPacket_Mobile_Stats()
-	local input =3D GetRecvFIFO()
-	local packetid =3D input:PopNetUint8()
-	local iPacketSize =3D input:PopNetUint16()
-	=

-	local stats =3D {}
-	local mobileserial	=3D input:PopNetUint32()
+-- simple mobile, no equipment, fixed size packet 0x77
+function gPacketHandler.kPacket_Naked_MOB ()
+	local packet =3D {}
+	local input =3D GetRecvFIFO()
+	=

+	local packetid =3D input:PopNetUint8()
+	packet.serial =3D input:PopNetUint32()
+	packet.body =3D input:PopNetUint16()
+	packet.xloc =3D input:PopNetUint16()
+	packet.yloc =3D input:PopNetUint16()
+	packet.zloc =3D input:PopInt8()
+	packet.dir =3D input:PopNetUint8()
+	packet.hue =3D input:PopNetUint16()
+	packet.flag =3D input:PopNetUint8()
+	packet.notoriety =3D input:PopNetUint8()
+	=

+	local mobile =3D gObjectList[packet.serial]	=

+	if (not mobile) then
+		mobile =3D CreateMobile( packet )
+	end
+	=

+	mobile:update( packet )
+end
+
+-- equipped mobile packet (0x78)
+function gPacketHandler.kPacket_Equipped_MOB()
+	local packet =3D {}
+	local input =3D GetRecvFIFO()
+	=

+	local fifolen_start =3D input:Size()
+	local packetid =3D input:PopNetUint8()
+	local iPacketSize =3D input:PopNetUint16()
+	=

+	packet.serial =3D input:PopNetUint32()
+	packet.body =3D input:PopNetUint16()
+	-- maybe it is necessary to read amount here, if this packet is used for =
a corpse
+	=

+	packet.x =3D input:PopNetUint16()
+	packet.y =3D input:PopNetUint16()
+	packet.z =3D input:PopInt8()
+	packet.dir =3D input:PopNetUint8()
+	packet.hue =3D input:PopNetUint16()
+	packet.flag =3D input:PopNetUint8()
+	packet.notoriety =3D input:PopNetUint8()
+	=

+	local mobile =3D gObjectList[packet.serial] =

+	if (not mobile) then
+		mobile =3D CreateMobile( packet )
+	end
+	=

+	mobile:update( packet )
+	=

+	local loopalive =3D true
+	while loopalive do =

+		local packet_dynamic =3D {}
+		if ( iPacketSize &gt;=3D (fifolen_start - input:Size()+4) ) then
+			packet_dynamic.serial =3D input:PopNetUint32()
+			if ( packet_dynamic.serial =3D=3D 0 ) then
+				loopalive =3D false
+			else
+				if ( iPacketSize &gt;=3D (fifolen_start - input:Size()+3) ) then
+					packet_dynamic.artid =3D input:PopNetUint16()
+					packet_dynamic.layer =3D input:PopNetUint8()
+					=

+					if ((BitwiseAND(packet_dynamic.artid,hex2num(&quot;0x8000&quot;)) ~=3D 0) and (=
 iPacketSize &gt;=3D (fifolen_start - input:Size()+2) )) then
+						packet_dynamic.hue =3D input:PopNetUint16()
+					else
+						packet_dynamic.hue =3D 0
+					end
+					packet_dynamic.artid =3D BitwiseAND(packet_dynamic.artid,hex2num(&quot;0x7=
fff&quot;))
+					=

+					dynamic =3D gObjectList[ packet_dynamic.serial ]
+					if (not dynamic) then
+						dynamic =3D CreateDynamic( packet_dynamic )
+					end
+					=

+					dynamic:update( packet_dynamic )
+					dynamic:setcontainer( mobile )
+				else
+					loopalive =3D false
+				end
+			end
+		else
+			loopalive =3D false
+		end
+	end
+end
+
+-- Teleport packet (also known as ProtocolRecv_Draw_Player) (0x20)
+function gPacketHandler.kPacket_Teleport()
+	gLastResyncRequest =3D nil
+	=

+	local input =3D GetRecvFIFO()
+	local id =3D input:PopNetUint8()
+	packet =3D {}
+	packet.serial	=3D input:PopNetUint32()
+	packet.body	=3D input:PopNetUint16()
+	packet.unknown1 =3D input:PopNetUint8()
+	packet.hue	=3D input:PopNetUint16()
+	packet.flag	=3D input:PopNetUint8()
+	packet.x	=3D input:PopNetUint16()
+	packet.y	=3D input:PopNetUint16()
+	packet.unknown2 =3D input:PopNetUint16()
+	packet.dir	=3D input:PopNetUint8()
+	packet.z	=3D input:PopInt8()
+	=

+	gCurrentRenderer:ClientSideMobileAnimPlayerTeleported()
+
+	local mobile =3D gObjectList[packet.serial] =

+	if (not mobile) then
+		mobile =3D CreateMobile( packet )
+	end
+	=

+	mobile:update( packet )
+	-- set player pos after updating mobile, otherwise the mobile may be dele=
ted as its out of range
+	SetPlayerPos( packet.x, packet.y, packet.z, packet.dir )
+
+	ResetWalkQueue()
+end
+
+-- Character Animation (0x6e)
+function gPacketHandler.kPacket_Animation ()
+	local input =3D GetRecvFIFO()
+	local packetid =3D input:PopNetUint8()
+	=

+	local packet =3D {}
+	packet.mobileserial	=3D input:PopNetUint32()	=

+	packet.m_animation	=3D input:PopNetUint16()
+	packet.m_framecount	=3D input:PopNetUint16()
+	packet.m_repeat		=3D input:PopNetUint16()	--repeat (1 =3D once / 2 =3D tw=
ice / 0 =3D repeat forever)
+	packet.m_animForward	=3D input:PopNetUint8()	--(0x00=3Dforward, 0x01=3Dba=
ckwards)
+	packet.m_repeatFlag	=3D input:PopNetUint8()	--(0 - Don't repeat / 1 repea=
t)
+	packet.m_frameDelay	=3D input:PopNetUint8()	--(0x00 - fastest / 0xFF - To=
o slow to watch)
+	=

+	local mobile =3D gObjectList[packet.serial] =

+	if (mobile) then
+		mobile:DoAnimation( packet )
+	end
+end
+
+-- mobile status (0x11)
+function gPacketHandler.kPacket_Mobile_Stats()
+	local input =3D GetRecvFIFO()
+	local packetid =3D input:PopNetUint8()
+	local iPacketSize =3D input:PopNetUint16()
+	=

+	local stats =3D {}
+	local mobileserial	=3D input:PopNetUint32()
 	stats.name				=3D input:PopFilledString(30)
-	stats.curHits			=3D input:PopNetUint16()
-	stats.maxHits	 		=3D input:PopNetUint16()
-	stats.bCanChangeName	=3D input:PopNetUint8() ~=3D 0
-	stats.flag 				=3D input:PopNetUint8()
-	=

-	-- more data following
-	if in_array( stats.flag, {1,3,4,5} ) then
-		stats.sex			=3D input:PopNetUint8() -- * 0x00 - Male * 0x01 - Female
-		stats.str			=3D input:PopNetUint16()
-		stats.dex			=3D input:PopNetUint16()
-		stats.int			=3D input:PopNetUint16()
-		stats.curStamina	=3D input:PopNetUint16()
-		stats.maxStamina	=3D input:PopNetUint16()
-		stats.curMana		=3D input:PopNetUint16()
-		stats.maxMana		=3D input:PopNetUint16()
-		stats.gold			=3D input:PopNetUint32()
-		stats.armor			=3D input:PopNetUint16()
-		stats.curWeight		=3D input:PopNetUint16()
-
-		if (stats.flag =3D=3D 5) then
-			stats.maxWeight	=3D input:PopNetUint16()
-			stats.race		=3D input:PopNetUint8()
-		end
-
-		if in_array( stats.flag, {3,4,5} ) then
-			stats.statcap	=3D input:PopNetUint16()
-			stats.curPet	=3D input:PopNetUint8()			=

-			stats.maxPet	=3D input:PopNetUint8()
-			=

-			if in_array( stats.flag, {4,5} ) then
-				stats.fireresist	=3D input:PopNetUint16()			=

-				stats.coldresist	=3D input:PopNetUint16()			=

-				stats.poisonresist	=3D input:PopNetUint16()			=

-				stats.energyresist	=3D input:PopNetUint16()			=

-				stats.luck			=3D input:PopNetUint16()			=

-				stats.minDamage		=3D input:PopNetUint16()			=

-				stats.maxDamage		=3D input:PopNetUint16()			=

-				stats.tithing		=3D input:PopNetUint32()			=

-			end
-		end
-	end
-
-	local mobile =3D gObjectList[mobileserial] =

-	if (mobile) then
-		mobile:updatestats( stats )
-	end
-end
-
--- Update Current Health [0xA1]
-function gPacketHandler.kPacket_HP_Health()
-	local input =3D GetRecvFIFO()
-	local packetid =3D input:PopNetUint8()
-	local serial =3D input:PopNetUint32()
-	local maxval =3D input:PopNetUint16()
-	local curval =3D input:PopNetUint16()
-	=

-	local mobile =3D gObjectList[serial] =

-	if (mobile) then
-		mobile:UpdateHits( curval, maxval )
-	end
-end
-
--- Update Current Mana [0xA2]
-function gPacketHandler.kPacket_Mana_Health()
-	local input =3D GetRecvFIFO()
-	local packetid =3D input:PopNetUint8()
-	local serial =3D input:PopNetUint32()
-	local maxval =3D input:PopNetUint16()
-	local curval =3D input:PopNetUint16()
-
-	local mobile =3D gObjectList[serial] =

-	if (mobile) then
-		mobile:UpdateMana( curval, maxval )
-	end	=

-end
-
--- Update Current Stamina [0xA3]
-function gPacketHandler.kPacket_Stamina()
-	local input =3D GetRecvFIFO()
-	local packetid =3D input:PopNetUint8()
-	local serial =3D input:PopNetUint32()
-	local maxval =3D input:PopNetUint16()
-	local curval =3D input:PopNetUint16()
-
-	local mobile =3D gObjectList[serial] =

-	if (mobile) then
-		mobile:UpdateStamina( curval, maxval )
-	end
-end
-
-function gPacketHandler.kPacket_Damage()
-	local input =3D GetRecvFIFO()
-	local packetid =3D input:PopNetUint8()
-	local serial =3D input:PopNetUint32()
-	local damage =3D input:PopNetUint16()
-	=

-	gCurrentRenderer:NotifyHPChange( serial, damage, 0 )
-end
-
--- see also Send_ClientQuery in net.login.lua
-function Send_QueryStatus( mobile )
-	local out =3D GetSendFIFO()
-	out:PushNetUint8( kPacket_Client_Query )
-	out:PushNetUint32( hex2num(&quot;0xedededed&quot;))
-	out:PushNetUint8( hex2num(&quot;0x04&quot;) )
-	out:PushNetUint32( mobile.serial )
-	out:SendPacket()
-end
+	stats.curHits			=3D input:PopNetUint16()
+	stats.maxHits	 		=3D input:PopNetUint16()
+	stats.bCanChangeName	=3D input:PopNetUint8() ~=3D 0
+	stats.flag 				=3D input:PopNetUint8()
+	=

+	-- more data following
+	if in_array( stats.flag, {1,3,4,5} ) then
+		stats.sex			=3D input:PopNetUint8() -- * 0x00 - Male * 0x01 - Female
+		stats.str			=3D input:PopNetUint16()
+		stats.dex			=3D input:PopNetUint16()
+		stats.int			=3D input:PopNetUint16()
+		stats.curStamina	=3D input:PopNetUint16()
+		stats.maxStamina	=3D input:PopNetUint16()
+		stats.curMana		=3D input:PopNetUint16()
+		stats.maxMana		=3D input:PopNetUint16()
+		stats.gold			=3D input:PopNetUint32()
+		stats.armor			=3D input:PopNetUint16()
+		stats.curWeight		=3D input:PopNetUint16()
+
+		if (stats.flag =3D=3D 5) then
+			stats.maxWeight	=3D input:PopNetUint16()
+			stats.race		=3D input:PopNetUint8()
+		end
+
+		if in_array( stats.flag, {3,4,5} ) then
+			stats.statcap	=3D input:PopNetUint16()
+			stats.curPet	=3D input:PopNetUint8()			=

+			stats.maxPet	=3D input:PopNetUint8()
+			=

+			if in_array( stats.flag, {4,5} ) then
+				stats.fireresist	=3D input:PopNetUint16()			=

+				stats.coldresist	=3D input:PopNetUint16()			=

+				stats.poisonresist	=3D input:PopNetUint16()			=

+				stats.energyresist	=3D input:PopNetUint16()			=

+				stats.luck			=3D input:PopNetUint16()			=

+				stats.minDamage		=3D input:PopNetUint16()			=

+				stats.maxDamage		=3D input:PopNetUint16()			=

+				stats.tithing		=3D input:PopNetUint32()			=

+			end
+		end
+	end
+
+	local mobile =3D gObjectList[mobileserial] =

+	if (mobile) then
+		mobile:updatestats( stats )
+	end
+end
+
+-- Update Current Health [0xA1]
+function gPacketHandler.kPacket_HP_Health()
+	local input =3D GetRecvFIFO()
+	local packetid =3D input:PopNetUint8()
+	local serial =3D input:PopNetUint32()
+	local maxval =3D input:PopNetUint16()
+	local curval =3D input:PopNetUint16()
+	=

+	local mobile =3D gObjectList[serial] =

+	if (mobile) then
+		mobile:UpdateHits( curval, maxval )
+	end
+end
+
+-- Update Current Mana [0xA2]
+function gPacketHandler.kPacket_Mana_Health()
+	local input =3D GetRecvFIFO()
+	local packetid =3D input:PopNetUint8()
+	local serial =3D input:PopNetUint32()
+	local maxval =3D input:PopNetUint16()
+	local curval =3D input:PopNetUint16()
+
+	local mobile =3D gObjectList[serial] =

+	if (mobile) then
+		mobile:UpdateMana( curval, maxval )
+	end	=

+end
+
+-- Update Current Stamina [0xA3]
+function gPacketHandler.kPacket_Stamina()
+	local input =3D GetRecvFIFO()
+	local packetid =3D input:PopNetUint8()
+	local serial =3D input:PopNetUint32()
+	local maxval =3D input:PopNetUint16()
+	local curval =3D input:PopNetUint16()
+
+	local mobile =3D gObjectList[serial] =

+	if (mobile) then
+		mobile:UpdateStamina( curval, maxval )
+	end
+end
+
+function gPacketHandler.kPacket_Damage()
+	local input =3D GetRecvFIFO()
+	local packetid =3D input:PopNetUint8()
+	local serial =3D input:PopNetUint32()
+	local damage =3D input:PopNetUint16()
+	=

+	gCurrentRenderer:NotifyHPChange( serial, damage, 0 )
+end
+
+-- see also Send_ClientQuery in net.login.lua
+function Send_QueryStatus( mobile )
+	local out =3D GetSendFIFO()
+	out:PushNetUint8( kPacket_Client_Query )
+	out:PushNetUint32( hex2num(&quot;0xedededed&quot;))
+	out:PushNetUint8( hex2num(&quot;0x04&quot;) )
+	out:PushNetUint32( mobile.serial )
+	out:SendPacket()
+end

Modified: branches/knut/data/lua/net/net.object.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/net/net.object.lua (original)
+++ branches/knut/data/lua/net/net.object.lua Thu Aug  2 17:12:24 2007
@@ -1,4 +1,8 @@
+-- packet handlers for receiving creating and updating game-objects (dynam=
ics, statics, multis...)
+-- see also lib.packet.lua and lib.protocol.lua
+
 function Send_DoubleClick( iSerial )
+	printdebug(&quot;net&quot;,sprintf(&quot;NET: Send_DoubleClick: 0x%08x\n&quot;,iSerial))
 	local out =3D GetSendFIFO()
 	out:PushNetUint8( kPacket_Double_Click )
 	out:PushNetUint32( iSerial )
@@ -9,24 +13,31 @@
 =

 function RepeatLastDoubleClick()
 	if gLastDoubleClickSerial ~=3D 0 then
-		DoubleClick( gLastDoubleClickSerial )
+		Send_DoubleClick(gLastDoubleClickSerial)
 	end
 end
 =

 function Send_SingleClick( iSerial )
+	printdebug(&quot;net&quot;,sprintf(&quot;NET: Send_SingleClick: 0x%08x\n&quot;,iSerial))
 	local out =3D GetSendFIFO()
 	out:PushNetUint8( kPacket_Single_Click )
 	out:PushNetUint32( iSerial )
 	out:SendPacket()
 end
 =

+-- Server sends Delete/Destroy command of char/item (usually during drag&amp;d=
rop from container)
+-- TODO : multis (serverside multis)
+--		  destroy statics?, containers ?? (associated dialogs,widgets..)
+--		 (NOT here, statics are dynamicly loaded and containers should be cach=
ed or destroyed when closed
 function gPacketHandler.kPacket_Destroy()
 	local input =3D GetRecvFIFO()
-	local packetid =3D input:PopNetUint8()
+	local id =3D input:PopNetUint8()
 	local serial =3D input:PopNetUint32()
+	printdebug(&quot;net&quot;,sprintf(&quot;NET: Destroy item with serial: 0x%08x\n&quot;,serial=
))
 	=

 	object =3D gObjectList[ serial ]
 	if (object) then
 		object:delete()
 	end
-end
+end
+

Modified: branches/knut/data/lua/obj/obj.dynamic.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/obj/obj.dynamic.lua (original)
+++ branches/knut/data/lua/obj/obj.dynamic.lua Thu Aug  2 17:12:24 2007
@@ -138,4 +138,4 @@
 =

 	-- just for testing, remove me
 	--if (item.artid_addstack ~=3D 0) then print(&quot;unexpected item.artid_addst=
ack&quot;,item.artid_addstack) Crash() end
-end
+end

Modified: branches/knut/data/lua/obj/obj.main.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/obj/obj.main.lua (original)
+++ branches/knut/data/lua/obj/obj.main.lua Thu Aug  2 17:12:24 2007
@@ -1,6 +1,33 @@
 dofile(libpath .. &quot;obj/obj.mobile.lua&quot;)
 dofile(libpath .. &quot;obj/obj.dynamic.lua&quot;)
 dofile(libpath .. &quot;obj/obj.player.lua&quot;)
+
+function GetMobile (mobileserial) local res =3D gObjectList[mobileserial] =
if (res.ismobile) then return res end end
+function GetMobileEquipmentItem (mobile,layer) return mobile:getequipment(=
layer) end
+function GetMobileEquipmentList (mobile) return mobile.content end
+function GetContainerContentList (container) return container.content end
+function GetObjectBySerial (serial) return gObjectList[serial] end
+
+function GetDynamicList () =

+	if (not gGetDynamicListWarning)	print(&quot;WARNING ! redesign me : GetDynamic=
List workaround&quot;) gGetDynamicListWarning =3D true end
+	-- ask ghoulsblade : this global lists of all dynamics and mobiles etc sh=
ould be kept for performance
+	local res
+	for k,object in pairs(gObjectList) do
+		if (object.isdynamic) then res[k] =3D object end
+	end
+	return res
+end
+
+function GetMobileList () =

+	if (not gGetMobileListWarning)	print(&quot;WARNING ! redesign me : GetDynamicL=
ist workaround&quot;) gGetMobileListWarning =3D true end
+	-- ask ghoulsblade : this global lists of all dynamics and mobiles etc sh=
ould be kept for performance
+	local res
+	for k,object in pairs(gObjectList) do
+		if (object.ismobile) then res[k] =3D object end
+	end
+	return res
+end
+
 =

 gObjectList =3D {}
 gPlayerBodySerial =3D 0

Modified: branches/knut/data/lua/obj/obj.player.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- branches/knut/data/lua/obj/obj.player.lua (original)
+++ branches/knut/data/lua/obj/obj.player.lua Thu Aug  2 17:12:24 2007
@@ -4,9 +4,10 @@
 end
 =

 function GetPlayerMobile ()
-	return gObjectList[ gPlayerBodySerial ]
+	return gPlayerBodySerial and GetMobile(gPlayerBodySerial)
 end
 =

+-- used by secure trade, mobile.name is filled by kPacket_Mobile_Stats
 function GetPlayerName ()
 	local mobile =3D GetPlayerMobile()
 	return mobile and mobile.name


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000140.html">[Iris-commit] [IRIS] r1328 - in /trunk/data/lua: gui/gui.main.lua gui/gui.status.lua lib.charcreate.lua lib.debug.lua lib.guimaker.lua lib.listener.lua lib.loading.lua lib.skill.lua lib.test.lua lib.util.lua net/net.multi.lua net/net.uodragdrop.lua
</A></li>
	<LI>Next message: <A HREF="000146.html">[Iris-commit] [IRIS] r1330 - in /trunk/data/lua: ./ gui/ net/ obj/
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#145">[ date ]</a>
              <a href="thread.html#145">[ thread ]</a>
              <a href="subject.html#145">[ subject ]</a>
              <a href="author.html#145">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/iris-commit">More information about the Iris-commit
mailing list</a><br>
</body></html>
