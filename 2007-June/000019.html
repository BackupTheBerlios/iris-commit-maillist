<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Iris-commit] [IRIS] r1203 - in /trunk: bin/iris2.exe	src/ogrewrapper.cpp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/iris-commit/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:iris-commit%40lists.berlios.de?Subject=Re%3A%20%5BIris-commit%5D%20%5BIRIS%5D%20r1203%20-%20in%20/trunk%3A%20bin/iris2.exe%0A%09src/ogrewrapper.cpp&In-Reply-To=%3C20070616114931.67167B1466D%40localhost.localdomain%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000018.html">
   <LINK REL="Next"  HREF="000020.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Iris-commit] [IRIS] r1203 - in /trunk: bin/iris2.exe	src/ogrewrapper.cpp</H1>
    <B>no-reply at zwischenwelt.org</B> 
    <A HREF="mailto:iris-commit%40lists.berlios.de?Subject=Re%3A%20%5BIris-commit%5D%20%5BIRIS%5D%20r1203%20-%20in%20/trunk%3A%20bin/iris2.exe%0A%09src/ogrewrapper.cpp&In-Reply-To=%3C20070616114931.67167B1466D%40localhost.localdomain%3E"
       TITLE="[Iris-commit] [IRIS] r1203 - in /trunk: bin/iris2.exe	src/ogrewrapper.cpp">no-reply at zwischenwelt.org
       </A><BR>
    <I>Sat Jun 16 13:49:27 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000018.html">[Iris-commit] [IRIS] r1202 - in /trunk/include: data.h	spritemanager.h
</A></li>
        <LI>Next message: <A HREF="000020.html">[Iris-commit] [IRIS] r1204 - in /trunk/data/lua: lib.3d.renderer.lua lib.models.lua lib.skill.lua lib.terrain.lua net.container.lua net.customhouse.lua net.mobile.lua net.objects.lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19">[ date ]</a>
              <a href="thread.html#19">[ thread ]</a>
              <a href="subject.html#19">[ subject ]</a>
              <a href="author.html#19">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: sience
Date: Sat Jun 16 13:49:25 2007
New Revision: 1203

Log:
-screenshots are now PNG
-new namebuild added for screenshots
-new binary

Modified:
    trunk/bin/iris2.exe
    trunk/src/ogrewrapper.cpp

Modified: trunk/bin/iris2.exe
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
Binary files - no diff available.

Modified: trunk/src/ogrewrapper.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/src/ogrewrapper.cpp (original)
+++ trunk/src/ogrewrapper.cpp Sat Jun 16 13:49:25 2007
@@ -1,766 +1,770 @@
-#include &quot;prefix.h&quot;
-#include &quot;ogrewrapper.h&quot;
-#include &quot;input.h&quot;
-#include &quot;robstring1.2.h&quot;
-#include &lt;Ogre.h&gt;
-/*
-#include &lt;OgreInput.h&gt;
-#include &lt;OgreInputEvent.h&gt;
-#include &lt;OgreEventListeners.h&gt;
-#include &lt;OgreKeyEvent.h&gt;
-#include &lt;OgreOverlay.h&gt;
-#include &lt;OgreOverlayManager.h&gt;
-#include &lt;OgrePanelOverlayElement.h&gt;
-#include &lt;OgreTextAreaOverlayElement.h&gt;
-#include &lt;OgreWireBoundingBox.h&gt;
-#include &lt;SDL/SDL.h&gt;
-*/
-#include &lt;OIS/OIS.h&gt;
-#include &lt;map&gt;
-#include &quot;shell.h&quot;
-#include &quot;timer.h&quot;
-#include &quot;ColourClipPaneOverlay.h&quot;
-#include &quot;ColourClipTextOverlay.h&quot;
-#include &quot;BorderColourClipPaneOverlay.h&quot;
-#include &quot;SortedOverlayContainer.h&quot;
-#include &quot;RobRenderableOverlay.h&quot;
-#include &quot;widget.h&quot;
-#include &quot;meshshape.h&quot;
-#include &quot;game.h&quot;
-
-#include &quot;CompassOverlay.h&quot;
-
-using namespace OIS;
-using namespace Ogre;
-Ogre::LogManager* gLogMan =3D 0;
-
-
-void	DisplayErrorMessage		(const char* szMsg); ///&lt; defined in main.cpp, O=
S-specific
-
-cOgreUserObjectWrapper::cOgreUserObjectWrapper() : mpEntity(0), miType(0) =
{}
-cOgreUserObjectWrapper::~cOgreUserObjectWrapper() {}
-long cOgreUserObjectWrapper::getTypeID(void) const { return 23; }
-const Ogre::String&amp; cOgreUserObjectWrapper::getTypeName(void) const { stat=
ic Ogre::String eris(&quot;shiva&quot;); return eris; }
-
-
-cOgreWrapper::cOgreWrapper() : mRoot(0) {PROFILE
-    mCamera =3D 0;
-    mViewport =3D 0;
-    mSceneMgr =3D 0;
-    mWindow =3D 0;
-	mInputManager =3D 0;
-	mMouse =3D 0;
-	mKeyboard =3D 0;
-	mJoy =3D 0;
-}
-
-int gLastWinLeft =3D 0;
-int gLastWinTop =3D 0;
-
-/// warning, evil hack, since this is not really supported by ogre
-void	OgreForceCloseFullscreen () {
-	// found no other way to hide the window, setVisible and mWindow-&gt;destroy=
() didn't work
-	// arg, even mRoot-&gt;shutdown() didn't work
-	delete cOgreWrapper::GetSingleton().mRoot;
-    cOgreWrapper::GetSingleton().mCamera =3D 0;
-    cOgreWrapper::GetSingleton().mViewport =3D 0;
-    cOgreWrapper::GetSingleton().mSceneMgr =3D 0;
-    cOgreWrapper::GetSingleton().mWindow =3D 0;
-	cOgreWrapper::GetSingleton().mInputManager =3D 0;
-	cOgreWrapper::GetSingleton().mMouse =3D 0;
-	cOgreWrapper::GetSingleton().mKeyboard =3D 0;
-	cOgreWrapper::GetSingleton().mJoy =3D 0;
-
-	char* szPluginCfgPath =3D &quot;plugins.cfg&quot;;
-	#ifdef WIN32
-	#else
-	szPluginCfgPath =3D &quot;plugins_linux.cfg&quot;;
-	#endif
-	printf(&quot;ogre deinit ok, reinit...\n&quot;);
-	cOgreWrapper::GetSingleton().mRoot =3D new Root(szPluginCfgPath);
-}
-
-/// only call this once at startup
-bool	cOgreWrapper::Init			() {PROFILE
-	static bool bInitialised =3D false;
-	if (bInitialised) return false;
-	bInitialised =3D true;
-
-	// create custom logmanager so ogre doesn't dump all that junk onto the c=
onsole
-	gLogMan =3D new LogManager();
-	bool suppressFileOutput =3D false;
-	gLogMan-&gt;createLog(&quot;Ogre.log&quot;, true, false,suppressFileOutput);
-	//gLogMan-&gt;createLog(logFileName, true, true);
-
-	char* szPluginCfgPath =3D &quot;plugins.cfg&quot;;
-	#ifdef WIN32
-	#else
-	szPluginCfgPath =3D &quot;plugins_linux.cfg&quot;;
-	#endif
-	mRoot =3D new Root(szPluginCfgPath);
-
-
-
-	//setupResources();
-	{
-        // Load resource paths from config file
-        ConfigFile cf;
-        cf.load(&quot;resources.cfg&quot;);
-
-        // Go through all sections &amp; settings in the file
-        ConfigFile::SectionIterator seci =3D cf.getSectionIterator();
-
-        String secName, typeName, archName;
-        while (seci.hasMoreElements())
-        {
-            secName =3D seci.peekNextKey();
-            ConfigFile::SettingsMultiMap *settings =3D seci.getNext();
-            ConfigFile::SettingsMultiMap::iterator i;
-            for (i =3D settings-&gt;begin(); i !=3D settings-&gt;end(); ++i)
-            {
-                typeName =3D i-&gt;first;
-                archName =3D i-&gt;second;
-                ResourceGroupManager::getSingleton().addResourceLocation(
-                    archName, typeName, secName);
-            }
-        }
-	}
-
-	bool bWinDebug =3D false;
-	//bool carryOn =3D configure();
-	//if (!carryOn) return false;
-	if (!mRoot-&gt;restoreConfig() &amp;&amp; !mRoot-&gt;showConfigDialog()) return false;
-//	mRoot-&gt;getRenderSystem()-&gt;setConfigOption(&quot;RTT Preferred Mode&quot;,&quot;Copy&quot;);=
 // todo : set via lua ?
-	if (bWinDebug) printf(&quot;windebug safepoint -2\n&quot;);
-	mRoot-&gt;getRenderSystem()-&gt;setWaitForVerticalBlank(false);
-	mWindow =3D mRoot-&gt;initialise(true,&quot;Iris2&quot;);
-	if (bWinDebug) printf(&quot;windebug safepoint -1\n&quot;);
-
-	//printf(&quot;\n\n Ogre Root-Init Successful\n\n&quot;);
-
-	if (1) {
-		bool bufferedKeys =3D true;
-		bool bufferedMouse =3D true;
-		bool bufferedJoy =3D true;
-		ParamList pl;
-		size_t windowHnd =3D 0;
-		std::ostringstream windowHndStr;
-
-		mWindow-&gt;getCustomAttribute(&quot;WINDOW&quot;, &amp;windowHnd);
-		windowHndStr &lt;&lt; windowHnd;
-		pl.insert(std::make_pair(std::string(&quot;WINDOW&quot;), windowHndStr.str()));
-		#if defined OIS_WIN32_PLATFORM
-		//Default mode is foreground exclusive..but, we want to show mouse - so =
nonexclusive
-		pl.insert(std::make_pair(std::string(&quot;w32_mouse&quot;), std::string(&quot;DISCL_FO=
REGROUND&quot; )));
-		pl.insert(std::make_pair(std::string(&quot;w32_mouse&quot;), std::string(&quot;DISCL_NO=
NEXCLUSIVE&quot;)));
-		pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL=
_FOREGROUND&quot;)));
-		pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL=
_NONEXCLUSIVE&quot;)));
-		/*
-		temp[&quot;DISCL_BACKGROUND&quot;]	=3D DISCL_BACKGROUND;
-		temp[&quot;DISCL_EXCLUSIVE&quot;]		=3D DISCL_EXCLUSIVE;
-		temp[&quot;DISCL_FOREGROUND&quot;]	=3D DISCL_FOREGROUND;
-		temp[&quot;DISCL_NONEXCLUSIVE&quot;]	=3D DISCL_NONEXCLUSIVE;
-		temp[&quot;DISCL_NOWINKEY&quot;]		=3D DISCL_NOWINKEY;
-		*/
-		#elif defined OIS_LINUX_PLATFORM
-		//For this demo, show mouse and do not grab (confine to window)
-		pl.insert(std::make_pair(std::string(&quot;x11_mouse_grab&quot;), std::string(&quot;fal=
se&quot;)));
-		pl.insert(std::make_pair(std::string(&quot;x11_mouse_hide&quot;), std::string(&quot;fal=
se&quot;)));
-		pl.insert(std::make_pair(std::string(&quot;x11_keyboard_grab&quot;), std::string(&quot;=
false&quot;)));
-		pl.insert(std::make_pair(std::string(&quot;XAutoRepeatOn&quot;), std::string(&quot;true=
&quot;)));
-		#endif
-
-		mInputManager =3D InputManager::createInputSystem( pl );
-
-		//Create all devices (We only catch joystick exceptions here, as, most p=
eople have Key/Mouse)
-		mKeyboard =3D static_cast&lt;Keyboard*&gt;(mInputManager-&gt;createInputObject( O=
ISKeyboard, bufferedKeys ));
-		// init tranlation mode (Unicode or Ascii)
-		if (mKeyboard) {
-			OIS::Keyboard::TextTranslationMode myTextTranslationMode =3D OIS::Keybo=
ard::Ascii;
-			mKeyboard-&gt;setTextTranslation(myTextTranslationMode);
-			if (mKeyboard-&gt;getTextTranslation() !=3D myTextTranslationMode) {
-				DisplayErrorMessage(strprintf(&quot;failed initialising OIS TextTranslation=
Mode : %s\n&quot;,(myTextTranslationMode=3D=3DOIS::Keyboard::Ascii)?&quot;asci&quot;:&quot;unic=
ode&quot;).c_str());
-				exit(12);
-			}
-		}
-		mMouse =3D static_cast&lt;Mouse*&gt;(mInputManager-&gt;createInputObject( OISMous=
e, bufferedMouse ));
-		/*
-		try {
-			mJoy =3D static_cast&lt;JoyStick*&gt;(mInputManager-&gt;createInputObject( OISJo=
yStick, bufferedJoy ));
-		}
-		catch(...) {
-			mJoy =3D 0;
-		}
-		*/
-
-		class cMyOISListener : public KeyListener, public MouseListener { public:
-			cInput&amp; input;
-			cMyOISListener() : input(cInput::GetSingleton()) {}
-
-			bool keyPressed( const KeyEvent &amp;arg ) {
-				if (0) std::cout &lt;&lt; &quot;\nKeyPressed {&quot; &lt;&lt; arg.key
-					&lt;&lt; &quot;, &quot; &lt;&lt; ((Keyboard*)(arg.device))-&gt;getAsString(arg.key)
-					&lt;&lt; &quot;} || Character (&quot; &lt;&lt; (char)arg.text &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
-
-				input.KeyDown(input.KeyConvertOIS(arg.key),(char)arg.text);
-
-
-				return true;
-			}
-			bool keyReleased( const KeyEvent &amp;arg ) {
-				input.KeyUp( input.KeyConvertOIS(arg.key));
-				return true;
-			}
-			bool mouseMoved( const MouseEvent &amp;arg ) {
-				const OIS::MouseState&amp; s =3D arg.state;
-				if (0) std::cout &lt;&lt; &quot;\nMouseMoved: Abs(&quot;
-						  &lt;&lt; s.X.abs &lt;&lt; &quot;, &quot; &lt;&lt; s.Y.abs &lt;&lt; &quot;, &quot; &lt;&lt; s.Z.abs &lt;&lt; &quot;) Abs2(&quot;
-						  &lt;&lt; (s.X.abs-gLastWinLeft) &lt;&lt; &quot;, &quot; &lt;&lt; (s.Y.abs-gLastWinTop) &lt;&lt; &quot;, &quot;=
 &lt;&lt; s.Z.abs &lt;&lt; &quot;) Rel(&quot;
-						  &lt;&lt; s.X.rel &lt;&lt; &quot;, &quot; &lt;&lt; s.Y.rel &lt;&lt; &quot;, &quot; &lt;&lt; s.Z.rel &lt;&lt; &quot;)&quot;;
-
-				cInput::iMouse[0] =3D s.X.abs; //-gLastWinLeft;
-				cInput::iMouse[1] =3D s.Y.abs; //-gLastWinTop;
-				if (s.Z.rel &lt; 0) { input.KeyDown(cInput::kkey_wheelup); input.KeyUp(cI=
nput::kkey_wheelup); }
-				if (s.Z.rel &gt; 0) { input.KeyDown(cInput::kkey_wheeldown); input.KeyUp(=
cInput::kkey_wheeldown); }
-				return true;
-			}
-			bool mousePressed( const MouseEvent &amp;arg, MouseButtonID id ) {
-				if (0) std::cout &lt;&lt; &quot;\nMousePressed: &quot; &lt;&lt; id;
-
-				switch (id) {
-					case MB_Left: input.KeyDown(cInput::kkey_mouse1); break;
-					case MB_Right: input.KeyDown(cInput::kkey_mouse2); break;
-					case MB_Middle: input.KeyDown(cInput::kkey_mouse3); break;
-				}
-
-				return true;
-			}
-			bool mouseReleased( const MouseEvent &amp;arg, MouseButtonID id ) {
-				if (0) std::cout &lt;&lt; &quot;\nMouseReleased: &quot; &lt;&lt; id;
-
-				switch (id) {
-					case MB_Left: input.KeyUp(cInput::kkey_mouse1); break;
-					case MB_Right: input.KeyUp(cInput::kkey_mouse2); break;
-					case MB_Middle: input.KeyUp(cInput::kkey_mouse3); break;
-				}
-
-				return true;
-			}
-		};
-		cMyOISListener* pMyOISListener =3D new cMyOISListener();
-
-		mKeyboard-&gt;setEventCallback(pMyOISListener);
-		mMouse-&gt;setEventCallback(pMyOISListener);
-
-		class cMyWindowListener : public Ogre::WindowEventListener { public:
-			virtual void windowMoved(RenderWindow* rw) {
-				if ( !cOgreWrapper::GetSingleton().mInputManager ) return;
-				unsigned int width, height, depth;
-				int left, top;
-				rw-&gt;getMetrics(width, height, depth, left, top);
-				gLastWinLeft =3D left;
-				gLastWinTop =3D top;
-				//printf(&quot;windowMoved, l,t=3D%d,%d\n&quot;,left,top); commented out by spam=
filter...
-			}
-
-			//Adjust mouse clipping area
-			virtual void windowResized(RenderWindow* rw)
-			{
-				if ( !cOgreWrapper::GetSingleton().mInputManager ) return;
-				unsigned int width, height, depth;
-				int left, top;
-				rw-&gt;getMetrics(width, height, depth, left, top);
-
-				const OIS::MouseState &amp;ms =3D cOgreWrapper::GetSingleton().mMouse-&gt;get=
MouseState();
-				ms.width =3D width;
-				ms.height =3D height;
-
-				// notify game that window was resized
-				cGame::GetSingleton().NotifyMainWindowResized(width,height);
-			}
-
-			//Unattach OIS before window shutdown (very important under Linux)
-			virtual void windowClosed(RenderWindow* rw)
-			{
-				//Only close for window that created OIS (the main window in these dem=
os)
-				if( rw =3D=3D cOgreWrapper::GetSingleton().mWindow )
-				{
-					cShell::mbAlive =3D false;
-					if( cOgreWrapper::GetSingleton().mInputManager )
-					{
-						cOgreWrapper::GetSingleton().mInputManager-&gt;destroyInputObject( cOgr=
eWrapper::GetSingleton().mMouse );
-						cOgreWrapper::GetSingleton().mInputManager-&gt;destroyInputObject( cOgr=
eWrapper::GetSingleton().mKeyboard );
-						cOgreWrapper::GetSingleton().mInputManager-&gt;destroyInputObject( cOgr=
eWrapper::GetSingleton().mJoy );
-						cOgreWrapper::GetSingleton().mMouse =3D 0;
-						cOgreWrapper::GetSingleton().mKeyboard =3D 0;
-						cOgreWrapper::GetSingleton().mJoy =3D 0;
-
-						OIS::InputManager::destroyInputSystem(cOgreWrapper::GetSingleton().m=
InputManager);
-						cOgreWrapper::GetSingleton().mInputManager =3D 0;
-					}
-				}
-			}
-		};
-		cMyWindowListener* pMyWindowListener =3D new cMyWindowListener();
-
-		//Set initial mouse clipping size
-		pMyWindowListener-&gt;windowResized(mWindow);
-
-		//Register as a Window listener
-		// ogrenew/OgreMain/include/OgreWindowEventUtilities.h
-		// static void Ogre::WindowEventUtilities::addWindowEventListener(Ogre::=
RenderWindow*, Ogre::WindowEventListener*)
-		WindowEventUtilities::addWindowEventListener(mWindow, pMyWindowListener);
-	}
-
-
-	//printf(&quot;\n\n Ogre Event-Init Successful\n\n&quot;);
-
-	//chooseSceneManager();
-	//for ogre 1.0
-	//mSceneMgr =3D mRoot-&gt;getSceneManager(ST_GENERIC);
-	//for ogre 1.2
-	if (bWinDebug) printf(&quot;windebug safepoint 0\n&quot;);
-	mSceneMgr =3D mRoot-&gt;createSceneManager(ST_GENERIC,&quot;main&quot;);
-	if (!mSceneMgr) { printf(&quot;COULDN'T CREATE SCENEMANAGER\n&quot;); exit(3); }
-	if (bWinDebug) printf(&quot;windebug safepoint 1\n&quot;);
-
-
-	mpCamHolderSceneNode =3D mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneN=
ode(&quot;CamHolder&quot;);
-	mpCamPosSceneNode =3D mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode=
(&quot;CamPos&quot;);
-
-	//printf(&quot;\n\n Ogre SceneManager-Init Successful\n\n&quot;);
-
-	//createCamera();
-	{
-		// Create the camera
-		mCamera =3D mSceneMgr-&gt;createCamera(&quot;PlayerCam&quot;);
-
-		// Position it at 500 in Z direction
-		mCamera-&gt;setPosition(Ogre::Vector3(0,0,40));
-		// Look back along -Z
-		//mCamera-&gt;lookAt(Vector3(0,0,0));
-		mCamera-&gt;setNearClipDistance(1);
-		//mCamera-&gt;setPolygonMode(PM_WIREFRAME);
-	}
-	if (bWinDebug) printf(&quot;windebug safepoint 2\n&quot;);
-
-	//printf(&quot;\n\n Ogre Camera-Init Successful\n\n&quot;);
-
-	// TODO : redesign this for lua cam handling
-	mpCamHolderSceneNode-&gt;attachObject(mCamera);
-	// Create one viewport, entire window
-	mViewport =3D mWindow-&gt;addViewport(mCamera);
-	mViewport-&gt;setBackgroundColour(ColourValue(0,0,0));
-
-	if (bWinDebug) printf(&quot;windebug safepoint 3\n&quot;);
-	// Alter the camera aspect ratio to match the viewport
-	mCamera-&gt;setAspectRatio(Real(mViewport-&gt;getActualWidth()) / Real(mViewpor=
t-&gt;getActualHeight()));
-
-
-	if (bWinDebug) printf(&quot;windebug safepoint 4\n&quot;);
-	//printf(&quot;\n\n Ogre Viewport-Init Successful\n\n&quot;);
-
-
-	if (0) { // mbRttHack
-		// render to texture hack, required for hagish's weird gfx-setup only =
=3D)
-		RenderTexture* rttTex =3D mRoot-&gt;getRenderSystem()-&gt;createRenderTexture(=
 &quot;RttTex&quot;, 512, 512, TEX_TYPE_2D, PF_R8G8B8 );
-		Viewport* vp =3D rttTex-&gt;addViewport( mCamera );
-		vp-&gt;setOverlaysEnabled( false );
-		vp-&gt;setClearEveryFrame( true );
-		vp-&gt;setBackgroundColour( ColourValue::Black );
-
-		//printf(&quot;\n\n Ogre RTT-HACK-Init Successful\n\n&quot;);
-	}
-
-	if (bWinDebug) printf(&quot;windebug safepoint 5\n&quot;);
-	// Set default mipmap level (NB some APIs ignore this)
-	TextureManager::getSingleton().setDefaultNumMipmaps(5);
-	Animation::setDefaultInterpolationMode(Animation::IM_SPLINE);
-
-	/*
-	mFiltering =3D TFO_TRILINEAR; mAniso =3D 1;
-	mFiltering =3D TFO_ANISOTROPIC; mAniso =3D 8;
-	mFiltering =3D TFO_BILINEAR; mAniso =3D 1;
-	MaterialManager::getSingleton().setDefaultTextureFiltering(mFiltering);
-	MaterialManager::getSingleton().setDefaultAnisotropy(mAniso);
-	*/
-
-	// TODO : Create any resource listeners (for loading screens)
-
-	// Load resources
-	// loadResources();
-	// Initialise, parse scripts etc
-	if (bWinDebug) printf(&quot;windebug safepoint 6\n&quot;);
-	ResourceGroupManager::getSingleton().initialiseAllResourceGroups();
-
-	if (bWinDebug) printf(&quot;windebug safepoint 7\n&quot;);
-
-	cCompassOverlay::RegisterFactory();
-	cRobRenderableOverlay::RegisterFactory();
-	cColourClipPaneOverlay::RegisterFactory();
-	cColourClipTextOverlay::RegisterFactory();
-	cBorderColourClipPaneOverlay::RegisterFactory();
-	cSortedOverlayContainer::RegisterFactory();
-
-	// sfzgui
-	if (1) {
-		class cSFZGUIEventPump : public cListener { public:
-			cDialogManager* mpDialogMan;
-			cSFZGUIEventPump() {
-				mpDialogMan =3D &amp;cDialogManager::GetSingleton();
-			}
-
-			enum {
-				kEventBinding_InputEvent,
-				kEventBinding_EveryFrame,
-			};
-			virtual	void	Listener_Notify (cListenable* pTarget,const size_t eventco=
de =3D 0,const size_t param =3D 0,const size_t userdata =3D 0) {
-				size_t key,c;
-				switch (userdata) {
-					case kEventBinding_EveryFrame:	// time,mousemovement
-						cDialogManager::GetSingleton().OnEnterFrame(cTimer::miCurFrameNum,cI=
nput::iMouse[0],cInput::iMouse[1]);
-					break;
-					case kEventBinding_InputEvent:
-						key =3D (size_t)(param &amp; 255);
-						c =3D (size_t)((param &gt;&gt; 8) &amp; 255);
-						switch (eventcode) {
-							case cInput::kListenerEvent_KeyPress:
-								mpDialogMan-&gt;InjectKey(key,c,true);
-							break;
-							case cInput::kListenerEvent_KeyRelease:
-								mpDialogMan-&gt;InjectKey(key,c,false);
-							break;
-						}
-					break;
-				}
-			}
-		};
-		cSFZGUIEventPump* pump =3D new cSFZGUIEventPump();
-		cInput::GetSingleton().RegisterListener(pump,(int)cSFZGUIEventPump::kEve=
ntBinding_InputEvent);
-		cTimer::GetSingletonPtr()-&gt;RegisterFrameIntervalListener(pump,0,(int)cSF=
ZGUIEventPump::kEventBinding_EveryFrame);
-	}
-
-	if (bWinDebug) printf(&quot;windebug safepoint 12\n&quot;);
-
-	return true;
-}
-
-void	cOgreWrapper::RenderOneFrame	() {PROFILE
-	if (!mRoot) return;
-
-	// draw one frame
-	mRoot-&gt;renderOneFrame();
-
-	// update input
-	Ogre::WindowEventUtilities::messagePump();
-	if (mKeyboard) mKeyboard-&gt;capture();
-	if (mMouse) mMouse-&gt;capture();
-
-
-	if (0) {
-		// terminate the application after a few seconds, useful for experimenti=
ng with input
-		static int iDeadTime =3D 0;
-		if (iDeadTime =3D=3D 0) iDeadTime =3D cShell::GetTicks() + 1000*20;
-		if (iDeadTime &lt; cShell::GetTicks()) cShell::mbAlive =3D false;
-	}
-
-	if(1) {
-		// read out some statistics
-		const RenderTarget::FrameStats&amp; stats =3D mWindow-&gt;getStatistics();
-		mfLastFPS =3D stats.lastFPS;
-		mfAvgFPS =3D stats.avgFPS;
-		mfBestFPS =3D stats.bestFPS;
-		mfWorstFPS =3D stats.worstFPS;
-		miBestFrameTime =3D stats.bestFrameTime;
-		miWorstFrameTime =3D stats.worstFrameTime;
-		miTriangleCount =3D stats.triangleCount;
-		miBatchCount =3D stats.batchCount;
-	}
-}
-
-void	cOgreWrapper::DeInit		() {PROFILE
-	if (mRoot) delete mRoot; mRoot =3D 0;
-}
-
-void	cOgreWrapper::SetSkybox	(const char* szMatName,const bool bFlip) { PR=
OFILE
-	// setSkyBox (bool enable, const String &amp;materialName, Real distance=3D50=
00, bool drawFirst=3Dtrue, const Quaternion &amp;orientation=3DQuaternion::IDEN=
TITY, const String &amp;groupName=3DResourceGroupManager::DEFAULT_RESOURCE_GROU=
P_NAME)
- 	if (szMatName) {
-		if (bFlip)
-				mSceneMgr-&gt;setSkyBox(true,szMatName,1000,true,Quaternion(Degree(90),Og=
re::Vector3(1,0,0)));
-		else	mSceneMgr-&gt;setSkyBox(true,szMatName);
-	} else {
-		mSceneMgr-&gt;setSkyBox(false,&quot;&quot;);
-	}
-}
-
-Ogre::SceneManager*	cOgreWrapper::GetSceneManager	(const char* szSceneMgrN=
ame) {
-	return mRoot-&gt;getSceneManager(szSceneMgrName);
-}
-
-void	cOgreWrapper::AttachCamera	(SceneNode* pSceneNode) {PROFILE
-	if (pSceneNode)
-			pSceneNode-&gt;attachObject(mCamera);
-	else	mSceneMgr-&gt;getRootSceneNode()-&gt;attachObject(mCamera);
-}
-
-void	cOgreWrapper::SetCameraPos		(const Ogre::Vector3 vPos) {PROFILE
-	mCamera-&gt;setPosition(vPos);
-}
-
-void	cOgreWrapper::SetCameraRot		(const Quaternion qRot) {PROFILE
-	mCamera-&gt;setOrientation(qRot);
-}
-
-void	cOgreWrapper::CameraLookAt		(const Ogre::Vector3 vPos) { PROFILE
-	mCamera-&gt;lookAt(vPos);
-}
-
-/// highres screenshot from wiki
-/// <A HREF="http://www.ogre3d.org/wiki/index.php/High_resolution_screenshots">http://www.ogre3d.org/wiki/index.php/High_resolution_screenshots</A>
-void cOgreWrapper::TakeGridScreenshot(/*Ogre::RenderWindow* mWindow, Ogre:=
:<i>Camera* mCamera, */const int&amp; pGridSize, const Ogre::String&amp; pFileName, co=
</I>nst Ogre::String&amp; pFileExtention, const bool&amp; pStitchGridImages)
-{
-  /* Parameters:
-   *  mWindow:    Pointer to the render window.  This could be &quot;mWindow&quot; f=
rom the ExampleApplication,
-   *              the window automatically created obtained when calling
-   *              Ogre::Root::getSingletonPtr()-&gt;initialise(false) and ret=
rieved by calling
-   *              &quot;Ogre::Root::getSingletonPtr()-&gt;getAutoCreatedWindow()&quot;,=
 or the manually created
-   *              window from calling &quot;mRoot-&gt;createRenderWindow()&quot;.
-   *  mCamera:      Pointer to the camera &quot;looking at&quot; the scene of intere=
st
-   *  pGridSize:      The magnification factor.  A 2 will create a 2x2 gri=
d, doubling the size of the
-                screenshot.  A 3 will create a 3x3 grid, tripling the size=
 of the screenshot.
-   *  pFileName:      The filename to generate, without an extention.  To =
generate &quot;MyScreenshot.png&quot; this
-   *              parameter would contain the value &quot;MyScreenshot&quot;.
-   *  pFileExtention:    The extention of the screenshot file name, hence =
the type of graphics file to generate.
-   *              To generate &quot;MyScreenshot.pnh&quot; this parameter would cont=
ain &quot;.png&quot;.
-   *  pStitchGridImages:  Determines whether the grid screenshots are (tru=
e) automatically stitched into a single
-   *              image (and discarded) or whether they should (false) rem=
ain in their unstitched
-   *              form.  In that case they are sequentially numbered from =
0 to
-   *              pGridSize * pGridSize - 1 (if pGridSize is 3 then from 0=
 to 8).
-   *
-  */
-	bool overlaysEnabled =3D mViewport-&gt;getOverlaysEnabled();
-	mViewport-&gt;setOverlaysEnabled(false);
-
-  Ogre::String gridFilename;
-
-  if(pGridSize &lt;=3D 1)
-  {
-    // Simple case where the contents of the screen are taken directly
-    // Also used when an invalid value is passed within pGridSize (zero or=
 negative grid size)
-    gridFilename =3D pFileName + pFileExtention;
-
-    mWindow-&gt;writeContentsToFile(gridFilename);
-  }
-  else
-  {
-    // Generate a grid of screenshots
-    mCamera-&gt;setCustomProjectionMatrix(false); // reset projection matrix
-    Ogre::Matrix4 standard =3D mCamera-&gt;getProjectionMatrix();
-    double nearDist =3D mCamera-&gt;getNearClipDistance();
-    double nearWidth =3D (mCamera-&gt;getWorldSpaceCorners()[0] - mCamera-&gt;ge=
tWorldSpaceCorners()[1]).length();
-    double nearHeight =3D (mCamera-&gt;getWorldSpaceCorners()[1] - mCamera-&gt;g=
etWorldSpaceCorners()[2]).length();
-    Ogre::Image sourceImage;
-    Ogre::uchar* stitchedImageData;
-
-    // Process each grid
-    for (int nbScreenshots =3D 0; nbScreenshots &lt; pGridSize * pGridSize; n=
bScreenshots++)
-    {
-      // Use asymmetrical perspective projection. For more explanations ch=
eck out:
-      // <A HREF="http://www.cs.kuleuven.ac.be/cwis/research/graphics/INFOTEC/viewi=">http://www.cs.kuleuven.ac.be/cwis/research/graphics/INFOTEC/viewi=</A>
ng-in-3d/node8.html
-      int y =3D nbScreenshots / pGridSize;
-      int x =3D nbScreenshots - y * pGridSize;
-      Ogre::Matrix4 shearing(
-        1, 0,(x - (pGridSize - 1) * 0.5) * nearWidth / nearDist, 0,
-        0, 1, -(y - (pGridSize - 1) * 0.5) * nearHeight / nearDist, 0,
-        0, 0, 1, 0,
-        0, 0, 0, 1);
-      Ogre::Matrix4 scale(
-        pGridSize, 0, 0, 0,
-        0, pGridSize, 0, 0,
-        0, 0, 1, 0,
-        0, 0, 0, 1);
-      mCamera-&gt;setCustomProjectionMatrix(true, standard * shearing * scale=
);
-      Ogre::Root::getSingletonPtr()-&gt;renderOneFrame();
-      gridFilename =3D pFileName + Ogre::StringConverter::toString(nbScree=
nshots) + pFileExtention;
-
-
-      // Screenshot of the current grid
-      mWindow-&gt;writeContentsToFile(gridFilename);
-
-      if(pStitchGridImages)
-      {
-        // Automatically stitch the grid screenshots
-        sourceImage.load(gridFilename, &quot;General&quot;); // Assumes that the cur=
rent directory is within the &quot;General&quot; resource group
-        int sourceWidth =3D (int) sourceImage.getWidth();
-        int sourceHeight =3D (int) sourceImage.getHeight();
-        Ogre::ColourValue colourValue;
-        int stitchedX, stitchedY, stitchedIndex;
-
-        // Allocate memory for the stitched image when processing the scre=
enshot of the first grid
-        if(nbScreenshots =3D=3D 0)
-          stitchedImageData =3D new Ogre::uchar[(sourceImage.getWidth() * =
pGridSize) * (sourceImage.getHeight() * pGridSize) * 3]; // 3 colors per pi=
xel
-
-        // Copy each pixel within the grid screenshot to the proper positi=
on within the stitched image
-        for(int rawY =3D 0; rawY &lt; sourceHeight; rawY++)
-        {
-          for(int rawX =3D 0; rawX &lt; sourceWidth; rawX++)
-          {
-            colourValue =3D sourceImage.getColourAt(rawX, rawY, 0);
-            stitchedX =3D x * sourceWidth + rawX;
-            stitchedY =3D y * sourceHeight + rawY;
-            stitchedIndex =3D stitchedY * sourceWidth * pGridSize + stitch=
edX;
-            Ogre::PixelUtil::packColour(colourValue,
-                          Ogre::PF_R8G8B8,
-                          (void*) &amp;stitchedImageData[stitchedIndex * 3]);
-          }
-        }
-        // The screenshot of the grid is no longer needed
-        remove(gridFilename.c_str());
-      }
-    }
-    mCamera-&gt;setCustomProjectionMatrix(false); // reset projection matrix
-
-    if(pStitchGridImages)
-    {
-      // Save the stitched image to a file
-      Ogre::Image targetImage;
-      targetImage.loadDynamicImage(stitchedImageData,
-                    sourceImage.getWidth() * pGridSize,
-                    sourceImage.getHeight() * pGridSize,
-                    1, // depth
-                    Ogre::PF_R8G8B8,
-                    false);
-      targetImage.save(pFileName + pFileExtention);
-      delete[] stitchedImageData;
-    }
-  }
-	mViewport-&gt;setOverlaysEnabled(overlaysEnabled);
-}
-
-void	cOgreWrapper::TakeScreenshot	(const char* szDirPath) {PROFILE
-	mWindow-&gt;writeContentsToFile( strprintf( &quot;%s%d.png&quot;, szDirPath, cShell::G=
etTicks() ) );
-}
-
-std::string		cOgreWrapper::GetUniqueName () {PROFILE
-	static int iLastName =3D 0;
-	return strprintf(&quot;n%04d&quot;,++iLastName);
-}
-
-/// avoid using OverlayManager::getSingleton().GetViewportHeight() as it i=
s one frame late
-int		cOgreWrapper::GetViewportHeight	() { return mViewport-&gt;getActualHeigh=
t(); }
-int		cOgreWrapper::GetViewportWidth	() { return mViewport-&gt;getActualWidth(=
); }
-
-bool	cOgreWrapper::RayAABBQuery	(const Ogre::Vector3&amp; vRayPos,const Ogre::=
Vector3&amp; vRayDir,const Ogre::AxisAlignedBox &amp;aabb,float* pfHitDist) { PROFI=
LE
-	static Ogre::Vector3 mlVertices[8];
-	static Ogre::Vector3 d,p000,p111,p100,p010,p001,p011,p101,p110;
-	p000 =3D aabb.getMinimum();
-	p111 =3D aabb.getMaximum();
-	d =3D p111-p000;
-	p100 =3D p000 + Ogre::Vector3(d.x,0,0);
-	p010 =3D p000 + Ogre::Vector3(0,d.y,0);
-	p001 =3D p000 + Ogre::Vector3(0,0,d.z);
-	p011 =3D p000 + Ogre::Vector3(0,d.y,d.z);
-	p101 =3D p000 + Ogre::Vector3(d.x,0,d.z);
-	p110 =3D p000 + Ogre::Vector3(d.x,d.y,0);
-
-	static int mlIndices[] =3D {
-		0,1,2, 3,1,2,	4,5,6, 7,5,6, // front, back
-		0,1,4, 5,1,4,	2,3,6, 7,3,6, // top, bottom
-		0,2,4, 6,2,4,	1,3,5, 7,3,5, // left, right
-		};
-	mlVertices[0] =3D p000;	mlVertices[1] =3D p100; // front
-	mlVertices[2] =3D p010;	mlVertices[3] =3D p110;
-
-	mlVertices[4] =3D p001;	mlVertices[5] =3D p101; // back
-	mlVertices[6] =3D p011;	mlVertices[7] =3D p111;
-
-	bool bHit =3D false;
-	float myHitDist;
-
-	for (int i=3D0;i&lt;6*6;i+=3D3) {
-		if (IntersectRayTriangle(vRayPos,vRayDir,
-			mlVertices[mlIndices[i+0]],
-			mlVertices[mlIndices[i+1]],
-			mlVertices[mlIndices[i+2]],&amp;myHitDist)) {
-			if (!bHit || myHitDist &lt; *pfHitDist) *pfHitDist =3D myHitDist;
-			bHit =3D true;
-		}
-	}
-	return bHit;
-}
-
-/// returns true if the ray intersects the entities triangles
-/// the resulting distance in the case of a hit is stored into pfHitDist
-/// see also OgreOpCode for more complex collision/intersection detection
-bool	cOgreWrapper::RayEntityQuery	(const Ogre::Vector3&amp; vRayPos,const Ogre=
::<i>Vector3&amp; vRayDir,Ogre::Entity* pEntity,const Ogre::Vector3&amp; vPos,const Og=
</I>re::Quaternion&amp; qRot,const Ogre::Vector3&amp; vScale,float* pfHitDist) { PROFILE
-	if (!pEntity) return false;
-	if (!pEntity-&gt;isVisible()) return false;
-
-	// get origin &amp; dir in coordinates local to the entity
-	MeshShape* myshape =3D MeshShape::GetMeshShape(pEntity);
-	if (!myshape) return false;
-	Ogre::Quaternion invrot =3D qRot.Inverse();
-	return myshape-&gt;RayIntersect((invrot*(vRayPos - vPos))/vScale,(invrot * v=
RayDir)/ vScale,pfHitDist);
-}
-
-/// extracs pos &amp; rot from scenenode, DOESNT WORK FOR entities in static g=
eometry (no scenenode)
-bool	cOgreWrapper::RayEntityQuery	(const Ogre::Vector3&amp; vRayPos,const Ogre=
::<i>Vector3&amp; vRayDir,Ogre::Entity* pEntity,float* pfHitDist) { PROFILE
</I>-	SceneNode* scenenode =3D pEntity ? pEntity-&gt;getParentSceneNode() : 0;
-	if (!scenenode) return false; // TODO : tagpoint (like knife in hand) att=
achment currently not supported...
-	return RayEntityQuery(vRayPos,vRayDir,pEntity,scenenode-&gt;_getDerivedPosit=
ion(),scenenode-&gt;_getDerivedOrientation(),scenenode-&gt;_getDerivedScale(),pfH=
itDist);
-}
-
-/// returns true if in front of cam, and fills x,y with clamped screencoor=
ds in [-1;1]
-/// and fills cx,cy with projected size on screen in [0;1]
-// cam-&gt;getProjectionMatrix() is cached inside ogre
-bool	cOgreWrapper::ProjectPos	(const Ogre::Vector3&amp; pos,Ogre::Real&amp; x,Ogre=
::<i>Real&amp; y) { PROFILE
</I>-	Camera* cam =3D mCamera;
-	Ogre::Vector3 eyeSpacePos =3D cam-&gt;getViewMatrix(true) * pos;
-	// z &lt; 0 means in front of cam
-	if (eyeSpacePos.z &lt; 0) {
-		Ogre::Vector3 screenSpacePos =3D cam-&gt;getProjectionMatrix() * eyeSpacePo=
s;
-		x =3D screenSpacePos.x;
-		y =3D screenSpacePos.y;
-		bool bIsOnSreen =3D true;
-		if (x &lt; -1.0) { x =3D -1.0; bIsOnSreen =3D false; } if (x &gt; 1.0) { x =3D=
 1.0; bIsOnSreen =3D false; }
-		if (y &lt; -1.0) { y =3D -1.0; bIsOnSreen =3D false; } if (y &gt; 1.0) { y =3D=
 1.0; bIsOnSreen =3D false; }
-		return bIsOnSreen;
-	} else {
-		x =3D (-eyeSpacePos.x &gt; 0) ? -1 : 1;
-		y =3D (-eyeSpacePos.y &gt; 0) ? -1 : 1;
-		return false;
-	}
-}
-
-/// returns true if in front of cam, and fills x,y with clamped screencoor=
ds in [-1;1]
-/// and fills cx,cy with projected size on screen in [0;1]
-// cam-&gt;getProjectionMatrix() is cached inside ogre
-bool	cOgreWrapper::ProjectSizeAndPos	(const Ogre::Vector3&amp; pos,Ogre::Real&amp;=
 x,Ogre::Real&amp; y,const Ogre::Real rad,Ogre::Real&amp; cx,Ogre::Real&amp; cy) { PROF=
ILE
-	Camera* cam =3D mCamera;
-	Ogre::Vector3 eyeSpacePos =3D cam-&gt;getViewMatrix(true) * pos;
-	// z &lt; 0 means in front of cam
-	if (eyeSpacePos.z &lt; 0) {
-		Ogre::Vector3 screenSpacePos =3D cam-&gt;getProjectionMatrix() * eyeSpacePo=
s;
-		x =3D screenSpacePos.x;
-		y =3D screenSpacePos.y;
-		bool bIsOnSreen =3D true;
-		if (x &lt; -1.0) { x =3D -1.0; bIsOnSreen =3D false; } if (x &gt; 1.0) { x =3D=
 1.0; bIsOnSreen =3D false; }
-		if (y &lt; -1.0) { y =3D -1.0; bIsOnSreen =3D false; } if (y &gt; 1.0) { y =3D=
 1.0; bIsOnSreen =3D false; }
-		if (bIsOnSreen) {
-			Ogre::Vector3 spheresize(rad, rad, eyeSpacePos.z);
-			spheresize =3D cam-&gt;getProjectionMatrix() * spheresize;
-			cx =3D spheresize.x;
-			cy =3D spheresize.y;
-		} else {
-			cx =3D 0;
-			cy =3D 0;
-		}
-		return bIsOnSreen;
-	} else {
-		cx =3D 0;
-		cy =3D 0;
-		x =3D (-eyeSpacePos.x &gt; 0) ? -1 : 1;
-		y =3D (-eyeSpacePos.y &gt; 0) ? -1 : 1;
-		return false;
-	}
-}
+#include &quot;prefix.h&quot;
+#include &quot;ogrewrapper.h&quot;
+#include &quot;input.h&quot;
+#include &quot;robstring1.2.h&quot;
+#include &lt;Ogre.h&gt;
+/*
+#include &lt;OgreInput.h&gt;
+#include &lt;OgreInputEvent.h&gt;
+#include &lt;OgreEventListeners.h&gt;
+#include &lt;OgreKeyEvent.h&gt;
+#include &lt;OgreOverlay.h&gt;
+#include &lt;OgreOverlayManager.h&gt;
+#include &lt;OgrePanelOverlayElement.h&gt;
+#include &lt;OgreTextAreaOverlayElement.h&gt;
+#include &lt;OgreWireBoundingBox.h&gt;
+#include &lt;SDL/SDL.h&gt;
+*/
+#include &lt;OIS/OIS.h&gt;
+#include &lt;map&gt;
+#include &quot;shell.h&quot;
+#include &quot;timer.h&quot;
+#include &quot;ColourClipPaneOverlay.h&quot;
+#include &quot;ColourClipTextOverlay.h&quot;
+#include &quot;BorderColourClipPaneOverlay.h&quot;
+#include &quot;SortedOverlayContainer.h&quot;
+#include &quot;RobRenderableOverlay.h&quot;
+#include &quot;widget.h&quot;
+#include &quot;meshshape.h&quot;
+#include &quot;game.h&quot;
+
+#include &quot;CompassOverlay.h&quot;
+
+using namespace OIS;
+using namespace Ogre;
+Ogre::LogManager* gLogMan =3D 0;
+
+
+void	DisplayErrorMessage		(const char* szMsg); ///&lt; defined in main.cpp, O=
S-specific
+
+cOgreUserObjectWrapper::cOgreUserObjectWrapper() : mpEntity(0), miType(0) =
{}
+cOgreUserObjectWrapper::~cOgreUserObjectWrapper() {}
+long cOgreUserObjectWrapper::getTypeID(void) const { return 23; }
+const Ogre::String&amp; cOgreUserObjectWrapper::getTypeName(void) const { stat=
ic Ogre::String eris(&quot;shiva&quot;); return eris; }
+
+
+cOgreWrapper::cOgreWrapper() : mRoot(0) {PROFILE
+    mCamera =3D 0;
+    mViewport =3D 0;
+    mSceneMgr =3D 0;
+    mWindow =3D 0;
+	mInputManager =3D 0;
+	mMouse =3D 0;
+	mKeyboard =3D 0;
+	mJoy =3D 0;
+}
+
+int gLastWinLeft =3D 0;
+int gLastWinTop =3D 0;
+
+/// warning, evil hack, since this is not really supported by ogre
+void	OgreForceCloseFullscreen () {
+	// found no other way to hide the window, setVisible and mWindow-&gt;destroy=
() didn't work
+	// arg, even mRoot-&gt;shutdown() didn't work
+	delete cOgreWrapper::GetSingleton().mRoot;
+    cOgreWrapper::GetSingleton().mCamera =3D 0;
+    cOgreWrapper::GetSingleton().mViewport =3D 0;
+    cOgreWrapper::GetSingleton().mSceneMgr =3D 0;
+    cOgreWrapper::GetSingleton().mWindow =3D 0;
+	cOgreWrapper::GetSingleton().mInputManager =3D 0;
+	cOgreWrapper::GetSingleton().mMouse =3D 0;
+	cOgreWrapper::GetSingleton().mKeyboard =3D 0;
+	cOgreWrapper::GetSingleton().mJoy =3D 0;
+
+	char* szPluginCfgPath =3D &quot;plugins.cfg&quot;;
+	#ifdef WIN32
+	#else
+	szPluginCfgPath =3D &quot;plugins_linux.cfg&quot;;
+	#endif
+	printf(&quot;ogre deinit ok, reinit...\n&quot;);
+	cOgreWrapper::GetSingleton().mRoot =3D new Root(szPluginCfgPath);
+}
+
+/// only call this once at startup
+bool	cOgreWrapper::Init			() {PROFILE
+	static bool bInitialised =3D false;
+	if (bInitialised) return false;
+	bInitialised =3D true;
+
+	// create custom logmanager so ogre doesn't dump all that junk onto the c=
onsole
+	gLogMan =3D new LogManager();
+	bool suppressFileOutput =3D false;
+	gLogMan-&gt;createLog(&quot;Ogre.log&quot;, true, false,suppressFileOutput);
+	//gLogMan-&gt;createLog(logFileName, true, true);
+
+	char* szPluginCfgPath =3D &quot;plugins.cfg&quot;;
+	#ifdef WIN32
+	#else
+	szPluginCfgPath =3D &quot;plugins_linux.cfg&quot;;
+	#endif
+	mRoot =3D new Root(szPluginCfgPath);
+
+
+
+	//setupResources();
+	{
+        // Load resource paths from config file
+        ConfigFile cf;
+        cf.load(&quot;resources.cfg&quot;);
+
+        // Go through all sections &amp; settings in the file
+        ConfigFile::SectionIterator seci =3D cf.getSectionIterator();
+
+        String secName, typeName, archName;
+        while (seci.hasMoreElements())
+        {
+            secName =3D seci.peekNextKey();
+            ConfigFile::SettingsMultiMap *settings =3D seci.getNext();
+            ConfigFile::SettingsMultiMap::iterator i;
+            for (i =3D settings-&gt;begin(); i !=3D settings-&gt;end(); ++i)
+            {
+                typeName =3D i-&gt;first;
+                archName =3D i-&gt;second;
+                ResourceGroupManager::getSingleton().addResourceLocation(
+                    archName, typeName, secName);
+            }
+        }
+	}
+
+	bool bWinDebug =3D false;
+	//bool carryOn =3D configure();
+	//if (!carryOn) return false;
+	if (!mRoot-&gt;restoreConfig() &amp;&amp; !mRoot-&gt;showConfigDialog()) return false;
+//	mRoot-&gt;getRenderSystem()-&gt;setConfigOption(&quot;RTT Preferred Mode&quot;,&quot;Copy&quot;);=
 // todo : set via lua ?
+	if (bWinDebug) printf(&quot;windebug safepoint -2\n&quot;);
+	mRoot-&gt;getRenderSystem()-&gt;setWaitForVerticalBlank(false);
+	mWindow =3D mRoot-&gt;initialise(true,&quot;Iris2&quot;);
+	if (bWinDebug) printf(&quot;windebug safepoint -1\n&quot;);
+
+	//printf(&quot;\n\n Ogre Root-Init Successful\n\n&quot;);
+
+	if (1) {
+		bool bufferedKeys =3D true;
+		bool bufferedMouse =3D true;
+		bool bufferedJoy =3D true;
+		ParamList pl;
+		size_t windowHnd =3D 0;
+		std::ostringstream windowHndStr;
+
+		mWindow-&gt;getCustomAttribute(&quot;WINDOW&quot;, &amp;windowHnd);
+		windowHndStr &lt;&lt; windowHnd;
+		pl.insert(std::make_pair(std::string(&quot;WINDOW&quot;), windowHndStr.str()));
+		#if defined OIS_WIN32_PLATFORM
+		//Default mode is foreground exclusive..but, we want to show mouse - so =
nonexclusive
+		pl.insert(std::make_pair(std::string(&quot;w32_mouse&quot;), std::string(&quot;DISCL_FO=
REGROUND&quot; )));
+		pl.insert(std::make_pair(std::string(&quot;w32_mouse&quot;), std::string(&quot;DISCL_NO=
NEXCLUSIVE&quot;)));
+		pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL=
_FOREGROUND&quot;)));
+		pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL=
_NONEXCLUSIVE&quot;)));
+		/*
+		temp[&quot;DISCL_BACKGROUND&quot;]	=3D DISCL_BACKGROUND;
+		temp[&quot;DISCL_EXCLUSIVE&quot;]		=3D DISCL_EXCLUSIVE;
+		temp[&quot;DISCL_FOREGROUND&quot;]	=3D DISCL_FOREGROUND;
+		temp[&quot;DISCL_NONEXCLUSIVE&quot;]	=3D DISCL_NONEXCLUSIVE;
+		temp[&quot;DISCL_NOWINKEY&quot;]		=3D DISCL_NOWINKEY;
+		*/
+		#elif defined OIS_LINUX_PLATFORM
+		//For this demo, show mouse and do not grab (confine to window)
+		pl.insert(std::make_pair(std::string(&quot;x11_mouse_grab&quot;), std::string(&quot;fal=
se&quot;)));
+		pl.insert(std::make_pair(std::string(&quot;x11_mouse_hide&quot;), std::string(&quot;fal=
se&quot;)));
+		pl.insert(std::make_pair(std::string(&quot;x11_keyboard_grab&quot;), std::string(&quot;=
false&quot;)));
+		pl.insert(std::make_pair(std::string(&quot;XAutoRepeatOn&quot;), std::string(&quot;true=
&quot;)));
+		#endif
+
+		mInputManager =3D InputManager::createInputSystem( pl );
+
+		//Create all devices (We only catch joystick exceptions here, as, most p=
eople have Key/Mouse)
+		mKeyboard =3D static_cast&lt;Keyboard*&gt;(mInputManager-&gt;createInputObject( O=
ISKeyboard, bufferedKeys ));
+		// init tranlation mode (Unicode or Ascii)
+		if (mKeyboard) {
+			OIS::Keyboard::TextTranslationMode myTextTranslationMode =3D OIS::Keybo=
ard::Ascii;
+			mKeyboard-&gt;setTextTranslation(myTextTranslationMode);
+			if (mKeyboard-&gt;getTextTranslation() !=3D myTextTranslationMode) {
+				DisplayErrorMessage(strprintf(&quot;failed initialising OIS TextTranslation=
Mode : %s\n&quot;,(myTextTranslationMode=3D=3DOIS::Keyboard::Ascii)?&quot;asci&quot;:&quot;unic=
ode&quot;).c_str());
+				exit(12);
+			}
+		}
+		mMouse =3D static_cast&lt;Mouse*&gt;(mInputManager-&gt;createInputObject( OISMous=
e, bufferedMouse ));
+		/*
+		try {
+			mJoy =3D static_cast&lt;JoyStick*&gt;(mInputManager-&gt;createInputObject( OISJo=
yStick, bufferedJoy ));
+		}
+		catch(...) {
+			mJoy =3D 0;
+		}
+		*/
+
+		class cMyOISListener : public KeyListener, public MouseListener { public:
+			cInput&amp; input;
+			cMyOISListener() : input(cInput::GetSingleton()) {}
+
+			bool keyPressed( const KeyEvent &amp;arg ) {
+				if (0) std::cout &lt;&lt; &quot;\nKeyPressed {&quot; &lt;&lt; arg.key
+					&lt;&lt; &quot;, &quot; &lt;&lt; ((Keyboard*)(arg.device))-&gt;getAsString(arg.key)
+					&lt;&lt; &quot;} || Character (&quot; &lt;&lt; (char)arg.text &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+
+				input.KeyDown(input.KeyConvertOIS(arg.key),(char)arg.text);
+
+
+				return true;
+			}
+			bool keyReleased( const KeyEvent &amp;arg ) {
+				input.KeyUp( input.KeyConvertOIS(arg.key));
+				return true;
+			}
+			bool mouseMoved( const MouseEvent &amp;arg ) {
+				const OIS::MouseState&amp; s =3D arg.state;
+				if (0) std::cout &lt;&lt; &quot;\nMouseMoved: Abs(&quot;
+						  &lt;&lt; s.X.abs &lt;&lt; &quot;, &quot; &lt;&lt; s.Y.abs &lt;&lt; &quot;, &quot; &lt;&lt; s.Z.abs &lt;&lt; &quot;) Abs2(&quot;
+						  &lt;&lt; (s.X.abs-gLastWinLeft) &lt;&lt; &quot;, &quot; &lt;&lt; (s.Y.abs-gLastWinTop) &lt;&lt; &quot;, &quot;=
 &lt;&lt; s.Z.abs &lt;&lt; &quot;) Rel(&quot;
+						  &lt;&lt; s.X.rel &lt;&lt; &quot;, &quot; &lt;&lt; s.Y.rel &lt;&lt; &quot;, &quot; &lt;&lt; s.Z.rel &lt;&lt; &quot;)&quot;;
+
+				cInput::iMouse[0] =3D s.X.abs; //-gLastWinLeft;
+				cInput::iMouse[1] =3D s.Y.abs; //-gLastWinTop;
+				if (s.Z.rel &lt; 0) { input.KeyDown(cInput::kkey_wheelup); input.KeyUp(cI=
nput::kkey_wheelup); }
+				if (s.Z.rel &gt; 0) { input.KeyDown(cInput::kkey_wheeldown); input.KeyUp(=
cInput::kkey_wheeldown); }
+				return true;
+			}
+			bool mousePressed( const MouseEvent &amp;arg, MouseButtonID id ) {
+				if (0) std::cout &lt;&lt; &quot;\nMousePressed: &quot; &lt;&lt; id;
+
+				switch (id) {
+					case MB_Left: input.KeyDown(cInput::kkey_mouse1); break;
+					case MB_Right: input.KeyDown(cInput::kkey_mouse2); break;
+					case MB_Middle: input.KeyDown(cInput::kkey_mouse3); break;
+				}
+
+				return true;
+			}
+			bool mouseReleased( const MouseEvent &amp;arg, MouseButtonID id ) {
+				if (0) std::cout &lt;&lt; &quot;\nMouseReleased: &quot; &lt;&lt; id;
+
+				switch (id) {
+					case MB_Left: input.KeyUp(cInput::kkey_mouse1); break;
+					case MB_Right: input.KeyUp(cInput::kkey_mouse2); break;
+					case MB_Middle: input.KeyUp(cInput::kkey_mouse3); break;
+				}
+
+				return true;
+			}
+		};
+		cMyOISListener* pMyOISListener =3D new cMyOISListener();
+
+		mKeyboard-&gt;setEventCallback(pMyOISListener);
+		mMouse-&gt;setEventCallback(pMyOISListener);
+
+		class cMyWindowListener : public Ogre::WindowEventListener { public:
+			virtual void windowMoved(RenderWindow* rw) {
+				if ( !cOgreWrapper::GetSingleton().mInputManager ) return;
+				unsigned int width, height, depth;
+				int left, top;
+				rw-&gt;getMetrics(width, height, depth, left, top);
+				gLastWinLeft =3D left;
+				gLastWinTop =3D top;
+				//printf(&quot;windowMoved, l,t=3D%d,%d\n&quot;,left,top); commented out by spam=
filter...
+			}
+
+			//Adjust mouse clipping area
+			virtual void windowResized(RenderWindow* rw)
+			{
+				if ( !cOgreWrapper::GetSingleton().mInputManager ) return;
+				unsigned int width, height, depth;
+				int left, top;
+				rw-&gt;getMetrics(width, height, depth, left, top);
+
+				const OIS::MouseState &amp;ms =3D cOgreWrapper::GetSingleton().mMouse-&gt;get=
MouseState();
+				ms.width =3D width;
+				ms.height =3D height;
+
+				// notify game that window was resized
+				cGame::GetSingleton().NotifyMainWindowResized(width,height);
+			}
+
+			//Unattach OIS before window shutdown (very important under Linux)
+			virtual void windowClosed(RenderWindow* rw)
+			{
+				//Only close for window that created OIS (the main window in these dem=
os)
+				if( rw =3D=3D cOgreWrapper::GetSingleton().mWindow )
+				{
+					cShell::mbAlive =3D false;
+					if( cOgreWrapper::GetSingleton().mInputManager )
+					{
+						cOgreWrapper::GetSingleton().mInputManager-&gt;destroyInputObject( cOgr=
eWrapper::GetSingleton().mMouse );
+						cOgreWrapper::GetSingleton().mInputManager-&gt;destroyInputObject( cOgr=
eWrapper::GetSingleton().mKeyboard );
+						cOgreWrapper::GetSingleton().mInputManager-&gt;destroyInputObject( cOgr=
eWrapper::GetSingleton().mJoy );
+						cOgreWrapper::GetSingleton().mMouse =3D 0;
+						cOgreWrapper::GetSingleton().mKeyboard =3D 0;
+						cOgreWrapper::GetSingleton().mJoy =3D 0;
+
+						OIS::InputManager::destroyInputSystem(cOgreWrapper::GetSingleton().m=
InputManager);
+						cOgreWrapper::GetSingleton().mInputManager =3D 0;
+					}
+				}
+			}
+		};
+		cMyWindowListener* pMyWindowListener =3D new cMyWindowListener();
+
+		//Set initial mouse clipping size
+		pMyWindowListener-&gt;windowResized(mWindow);
+
+		//Register as a Window listener
+		// ogrenew/OgreMain/include/OgreWindowEventUtilities.h
+		// static void Ogre::WindowEventUtilities::addWindowEventListener(Ogre::=
RenderWindow*, Ogre::WindowEventListener*)
+		WindowEventUtilities::addWindowEventListener(mWindow, pMyWindowListener);
+	}
+
+
+	//printf(&quot;\n\n Ogre Event-Init Successful\n\n&quot;);
+
+	//chooseSceneManager();
+	//for ogre 1.0
+	//mSceneMgr =3D mRoot-&gt;getSceneManager(ST_GENERIC);
+	//for ogre 1.2
+	if (bWinDebug) printf(&quot;windebug safepoint 0\n&quot;);
+	mSceneMgr =3D mRoot-&gt;createSceneManager(ST_GENERIC,&quot;main&quot;);
+	if (!mSceneMgr) { printf(&quot;COULDN'T CREATE SCENEMANAGER\n&quot;); exit(3); }
+	if (bWinDebug) printf(&quot;windebug safepoint 1\n&quot;);
+
+
+	mpCamHolderSceneNode =3D mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneN=
ode(&quot;CamHolder&quot;);
+	mpCamPosSceneNode =3D mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode=
(&quot;CamPos&quot;);
+
+	//printf(&quot;\n\n Ogre SceneManager-Init Successful\n\n&quot;);
+
+	//createCamera();
+	{
+		// Create the camera
+		mCamera =3D mSceneMgr-&gt;createCamera(&quot;PlayerCam&quot;);
+
+		// Position it at 500 in Z direction
+		mCamera-&gt;setPosition(Ogre::Vector3(0,0,40));
+		// Look back along -Z
+		//mCamera-&gt;lookAt(Vector3(0,0,0));
+		mCamera-&gt;setNearClipDistance(1);
+		//mCamera-&gt;setPolygonMode(PM_WIREFRAME);
+	}
+	if (bWinDebug) printf(&quot;windebug safepoint 2\n&quot;);
+
+	//printf(&quot;\n\n Ogre Camera-Init Successful\n\n&quot;);
+
+	// TODO : redesign this for lua cam handling
+	mpCamHolderSceneNode-&gt;attachObject(mCamera);
+	// Create one viewport, entire window
+	mViewport =3D mWindow-&gt;addViewport(mCamera);
+	mViewport-&gt;setBackgroundColour(ColourValue(0,0,0));
+
+	if (bWinDebug) printf(&quot;windebug safepoint 3\n&quot;);
+	// Alter the camera aspect ratio to match the viewport
+	mCamera-&gt;setAspectRatio(Real(mViewport-&gt;getActualWidth()) / Real(mViewpor=
t-&gt;getActualHeight()));
+
+
+	if (bWinDebug) printf(&quot;windebug safepoint 4\n&quot;);
+	//printf(&quot;\n\n Ogre Viewport-Init Successful\n\n&quot;);
+
+
+	if (0) { // mbRttHack
+		// render to texture hack, required for hagish's weird gfx-setup only =
=3D)
+		RenderTexture* rttTex =3D mRoot-&gt;getRenderSystem()-&gt;createRenderTexture(=
 &quot;RttTex&quot;, 512, 512, TEX_TYPE_2D, PF_R8G8B8 );
+		Viewport* vp =3D rttTex-&gt;addViewport( mCamera );
+		vp-&gt;setOverlaysEnabled( false );
+		vp-&gt;setClearEveryFrame( true );
+		vp-&gt;setBackgroundColour( ColourValue::Black );
+
+		//printf(&quot;\n\n Ogre RTT-HACK-Init Successful\n\n&quot;);
+	}
+
+	if (bWinDebug) printf(&quot;windebug safepoint 5\n&quot;);
+	// Set default mipmap level (NB some APIs ignore this)
+	TextureManager::getSingleton().setDefaultNumMipmaps(5);
+	Animation::setDefaultInterpolationMode(Animation::IM_SPLINE);
+
+	/*
+	mFiltering =3D TFO_TRILINEAR; mAniso =3D 1;
+	mFiltering =3D TFO_ANISOTROPIC; mAniso =3D 8;
+	mFiltering =3D TFO_BILINEAR; mAniso =3D 1;
+	MaterialManager::getSingleton().setDefaultTextureFiltering(mFiltering);
+	MaterialManager::getSingleton().setDefaultAnisotropy(mAniso);
+	*/
+
+	// TODO : Create any resource listeners (for loading screens)
+
+	// Load resources
+	// loadResources();
+	// Initialise, parse scripts etc
+	if (bWinDebug) printf(&quot;windebug safepoint 6\n&quot;);
+	ResourceGroupManager::getSingleton().initialiseAllResourceGroups();
+
+	if (bWinDebug) printf(&quot;windebug safepoint 7\n&quot;);
+
+	cCompassOverlay::RegisterFactory();
+	cRobRenderableOverlay::RegisterFactory();
+	cColourClipPaneOverlay::RegisterFactory();
+	cColourClipTextOverlay::RegisterFactory();
+	cBorderColourClipPaneOverlay::RegisterFactory();
+	cSortedOverlayContainer::RegisterFactory();
+
+	// sfzgui
+	if (1) {
+		class cSFZGUIEventPump : public cListener { public:
+			cDialogManager* mpDialogMan;
+			cSFZGUIEventPump() {
+				mpDialogMan =3D &amp;cDialogManager::GetSingleton();
+			}
+
+			enum {
+				kEventBinding_InputEvent,
+				kEventBinding_EveryFrame,
+			};
+			virtual	void	Listener_Notify (cListenable* pTarget,const size_t eventco=
de =3D 0,const size_t param =3D 0,const size_t userdata =3D 0) {
+				size_t key,c;
+				switch (userdata) {
+					case kEventBinding_EveryFrame:	// time,mousemovement
+						cDialogManager::GetSingleton().OnEnterFrame(cTimer::miCurFrameNum,cI=
nput::iMouse[0],cInput::iMouse[1]);
+					break;
+					case kEventBinding_InputEvent:
+						key =3D (size_t)(param &amp; 255);
+						c =3D (size_t)((param &gt;&gt; 8) &amp; 255);
+						switch (eventcode) {
+							case cInput::kListenerEvent_KeyPress:
+								mpDialogMan-&gt;InjectKey(key,c,true);
+							break;
+							case cInput::kListenerEvent_KeyRelease:
+								mpDialogMan-&gt;InjectKey(key,c,false);
+							break;
+						}
+					break;
+				}
+			}
+		};
+		cSFZGUIEventPump* pump =3D new cSFZGUIEventPump();
+		cInput::GetSingleton().RegisterListener(pump,(int)cSFZGUIEventPump::kEve=
ntBinding_InputEvent);
+		cTimer::GetSingletonPtr()-&gt;RegisterFrameIntervalListener(pump,0,(int)cSF=
ZGUIEventPump::kEventBinding_EveryFrame);
+	}
+
+	if (bWinDebug) printf(&quot;windebug safepoint 12\n&quot;);
+
+	return true;
+}
+
+void	cOgreWrapper::RenderOneFrame	() {PROFILE
+	if (!mRoot) return;
+
+	// draw one frame
+	mRoot-&gt;renderOneFrame();
+
+	// update input
+	Ogre::WindowEventUtilities::messagePump();
+	if (mKeyboard) mKeyboard-&gt;capture();
+	if (mMouse) mMouse-&gt;capture();
+
+
+	if (0) {
+		// terminate the application after a few seconds, useful for experimenti=
ng with input
+		static int iDeadTime =3D 0;
+		if (iDeadTime =3D=3D 0) iDeadTime =3D cShell::GetTicks() + 1000*20;
+		if (iDeadTime &lt; cShell::GetTicks()) cShell::mbAlive =3D false;
+	}
+
+	if(1) {
+		// read out some statistics
+		const RenderTarget::FrameStats&amp; stats =3D mWindow-&gt;getStatistics();
+		mfLastFPS =3D stats.lastFPS;
+		mfAvgFPS =3D stats.avgFPS;
+		mfBestFPS =3D stats.bestFPS;
+		mfWorstFPS =3D stats.worstFPS;
+		miBestFrameTime =3D stats.bestFrameTime;
+		miWorstFrameTime =3D stats.worstFrameTime;
+		miTriangleCount =3D stats.triangleCount;
+		miBatchCount =3D stats.batchCount;
+	}
+}
+
+void	cOgreWrapper::DeInit		() {PROFILE
+	if (mRoot) delete mRoot; mRoot =3D 0;
+}
+
+void	cOgreWrapper::SetSkybox	(const char* szMatName,const bool bFlip) { PR=
OFILE
+	// setSkyBox (bool enable, const String &amp;materialName, Real distance=3D50=
00, bool drawFirst=3Dtrue, const Quaternion &amp;orientation=3DQuaternion::IDEN=
TITY, const String &amp;groupName=3DResourceGroupManager::DEFAULT_RESOURCE_GROU=
P_NAME)
+ 	if (szMatName) {
+		if (bFlip)
+				mSceneMgr-&gt;setSkyBox(true,szMatName,1000,true,Quaternion(Degree(90),Og=
re::Vector3(1,0,0)));
+		else	mSceneMgr-&gt;setSkyBox(true,szMatName);
+	} else {
+		mSceneMgr-&gt;setSkyBox(false,&quot;&quot;);
+	}
+}
+
+Ogre::SceneManager*	cOgreWrapper::GetSceneManager	(const char* szSceneMgrN=
ame) {
+	return mRoot-&gt;getSceneManager(szSceneMgrName);
+}
+
+void	cOgreWrapper::AttachCamera	(SceneNode* pSceneNode) {PROFILE
+	if (pSceneNode)
+			pSceneNode-&gt;attachObject(mCamera);
+	else	mSceneMgr-&gt;getRootSceneNode()-&gt;attachObject(mCamera);
+}
+
+void	cOgreWrapper::SetCameraPos		(const Ogre::Vector3 vPos) {PROFILE
+	mCamera-&gt;setPosition(vPos);
+}
+
+void	cOgreWrapper::SetCameraRot		(const Quaternion qRot) {PROFILE
+	mCamera-&gt;setOrientation(qRot);
+}
+
+void	cOgreWrapper::CameraLookAt		(const Ogre::Vector3 vPos) { PROFILE
+	mCamera-&gt;lookAt(vPos);
+}
+
+/// highres screenshot from wiki
+/// <A HREF="http://www.ogre3d.org/wiki/index.php/High_resolution_screenshots">http://www.ogre3d.org/wiki/index.php/High_resolution_screenshots</A>
+void cOgreWrapper::TakeGridScreenshot(/*Ogre::RenderWindow* mWindow, Ogre:=
:<i>Camera* mCamera, */const int&amp; pGridSize, const Ogre::String&amp; pFileName, co=
</I>nst Ogre::String&amp; pFileExtention, const bool&amp; pStitchGridImages)
+{
+  /* Parameters:
+   *  mWindow:    Pointer to the render window.  This could be &quot;mWindow&quot; f=
rom the ExampleApplication,
+   *              the window automatically created obtained when calling
+   *              Ogre::Root::getSingletonPtr()-&gt;initialise(false) and ret=
rieved by calling
+   *              &quot;Ogre::Root::getSingletonPtr()-&gt;getAutoCreatedWindow()&quot;,=
 or the manually created
+   *              window from calling &quot;mRoot-&gt;createRenderWindow()&quot;.
+   *  mCamera:      Pointer to the camera &quot;looking at&quot; the scene of intere=
st
+   *  pGridSize:      The magnification factor.  A 2 will create a 2x2 gri=
d, doubling the size of the
+                screenshot.  A 3 will create a 3x3 grid, tripling the size=
 of the screenshot.
+   *  pFileName:      The filename to generate, without an extention.  To =
generate &quot;MyScreenshot.png&quot; this
+   *              parameter would contain the value &quot;MyScreenshot&quot;.
+   *  pFileExtention:    The extention of the screenshot file name, hence =
the type of graphics file to generate.
+   *              To generate &quot;MyScreenshot.pnh&quot; this parameter would cont=
ain &quot;.png&quot;.
+   *  pStitchGridImages:  Determines whether the grid screenshots are (tru=
e) automatically stitched into a single
+   *              image (and discarded) or whether they should (false) rem=
ain in their unstitched
+   *              form.  In that case they are sequentially numbered from =
0 to
+   *              pGridSize * pGridSize - 1 (if pGridSize is 3 then from 0=
 to 8).
+   *
+  */
+	bool overlaysEnabled =3D mViewport-&gt;getOverlaysEnabled();
+	mViewport-&gt;setOverlaysEnabled(false);
+
+  Ogre::String gridFilename;
+
+  if(pGridSize &lt;=3D 1)
+  {
+    // Simple case where the contents of the screen are taken directly
+    // Also used when an invalid value is passed within pGridSize (zero or=
 negative grid size)
+    gridFilename =3D pFileName + pFileExtention;
+
+    mWindow-&gt;writeContentsToFile(gridFilename);
+  }
+  else
+  {
+    // Generate a grid of screenshots
+    mCamera-&gt;setCustomProjectionMatrix(false); // reset projection matrix
+    Ogre::Matrix4 standard =3D mCamera-&gt;getProjectionMatrix();
+    double nearDist =3D mCamera-&gt;getNearClipDistance();
+    double nearWidth =3D (mCamera-&gt;getWorldSpaceCorners()[0] - mCamera-&gt;ge=
tWorldSpaceCorners()[1]).length();
+    double nearHeight =3D (mCamera-&gt;getWorldSpaceCorners()[1] - mCamera-&gt;g=
etWorldSpaceCorners()[2]).length();
+    Ogre::Image sourceImage;
+    Ogre::uchar* stitchedImageData;
+
+    // Process each grid
+    for (int nbScreenshots =3D 0; nbScreenshots &lt; pGridSize * pGridSize; n=
bScreenshots++)
+    {
+      // Use asymmetrical perspective projection. For more explanations ch=
eck out:
+      // <A HREF="http://www.cs.kuleuven.ac.be/cwis/research/graphics/INFOTEC/viewi=">http://www.cs.kuleuven.ac.be/cwis/research/graphics/INFOTEC/viewi=</A>
ng-in-3d/node8.html
+      int y =3D nbScreenshots / pGridSize;
+      int x =3D nbScreenshots - y * pGridSize;
+      Ogre::Matrix4 shearing(
+        1, 0,(x - (pGridSize - 1) * 0.5) * nearWidth / nearDist, 0,
+        0, 1, -(y - (pGridSize - 1) * 0.5) * nearHeight / nearDist, 0,
+        0, 0, 1, 0,
+        0, 0, 0, 1);
+      Ogre::Matrix4 scale(
+        pGridSize, 0, 0, 0,
+        0, pGridSize, 0, 0,
+        0, 0, 1, 0,
+        0, 0, 0, 1);
+      mCamera-&gt;setCustomProjectionMatrix(true, standard * shearing * scale=
);
+      Ogre::Root::getSingletonPtr()-&gt;renderOneFrame();
+      gridFilename =3D pFileName + Ogre::StringConverter::toString(nbScree=
nshots) + pFileExtention;
+
+
+      // Screenshot of the current grid
+      mWindow-&gt;writeContentsToFile(gridFilename);
+
+      if(pStitchGridImages)
+      {
+        // Automatically stitch the grid screenshots
+        sourceImage.load(gridFilename, &quot;General&quot;); // Assumes that the cur=
rent directory is within the &quot;General&quot; resource group
+        int sourceWidth =3D (int) sourceImage.getWidth();
+        int sourceHeight =3D (int) sourceImage.getHeight();
+        Ogre::ColourValue colourValue;
+        int stitchedX, stitchedY, stitchedIndex;
+
+        // Allocate memory for the stitched image when processing the scre=
enshot of the first grid
+        if(nbScreenshots =3D=3D 0)
+          stitchedImageData =3D new Ogre::uchar[(sourceImage.getWidth() * =
pGridSize) * (sourceImage.getHeight() * pGridSize) * 3]; // 3 colors per pi=
xel
+
+        // Copy each pixel within the grid screenshot to the proper positi=
on within the stitched image
+        for(int rawY =3D 0; rawY &lt; sourceHeight; rawY++)
+        {
+          for(int rawX =3D 0; rawX &lt; sourceWidth; rawX++)
+          {
+            colourValue =3D sourceImage.getColourAt(rawX, rawY, 0);
+            stitchedX =3D x * sourceWidth + rawX;
+            stitchedY =3D y * sourceHeight + rawY;
+            stitchedIndex =3D stitchedY * sourceWidth * pGridSize + stitch=
edX;
+            Ogre::PixelUtil::packColour(colourValue,
+                          Ogre::PF_R8G8B8,
+                          (void*) &amp;stitchedImageData[stitchedIndex * 3]);
+          }
+        }
+        // The screenshot of the grid is no longer needed
+        remove(gridFilename.c_str());
+      }
+    }
+    mCamera-&gt;setCustomProjectionMatrix(false); // reset projection matrix
+
+    if(pStitchGridImages)
+    {
+      // Save the stitched image to a file
+      Ogre::Image targetImage;
+      targetImage.loadDynamicImage(stitchedImageData,
+                    sourceImage.getWidth() * pGridSize,
+                    sourceImage.getHeight() * pGridSize,
+                    1, // depth
+                    Ogre::PF_R8G8B8,
+                    false);
+      targetImage.save(pFileName + pFileExtention);
+      delete[] stitchedImageData;
+    }
+  }
+	mViewport-&gt;setOverlaysEnabled(overlaysEnabled);
+}
+
+void cOgreWrapper::TakeScreenshot (const char* szDirPath) {PROFILE
+ char mybuf[256];
+ time_t mytime;
+ time(&amp;mytime);
+ strftime(mybuf,255,&quot;%Y%m%d%H%M%S&quot;,localtime(&amp;mytime));
+ mWindow-&gt;writeContentsToFile( strprintf( &quot;%siris_%s_%03d.png&quot;, szDirPath,=
mybuf,cShell::GetTicks() % 1000 ) );
+} =

+
+std::string		cOgreWrapper::GetUniqueName () {PROFILE
+	static int iLastName =3D 0;
+	return strprintf(&quot;n%04d&quot;,++iLastName);
+}
+
+/// avoid using OverlayManager::getSingleton().GetViewportHeight() as it i=
s one frame late
+int		cOgreWrapper::GetViewportHeight	() { return mViewport-&gt;getActualHeigh=
t(); }
+int		cOgreWrapper::GetViewportWidth	() { return mViewport-&gt;getActualWidth(=
); }
+
+bool	cOgreWrapper::RayAABBQuery	(const Ogre::Vector3&amp; vRayPos,const Ogre::=
Vector3&amp; vRayDir,const Ogre::AxisAlignedBox &amp;aabb,float* pfHitDist) { PROFI=
LE
+	static Ogre::Vector3 mlVertices[8];
+	static Ogre::Vector3 d,p000,p111,p100,p010,p001,p011,p101,p110;
+	p000 =3D aabb.getMinimum();
+	p111 =3D aabb.getMaximum();
+	d =3D p111-p000;
+	p100 =3D p000 + Ogre::Vector3(d.x,0,0);
+	p010 =3D p000 + Ogre::Vector3(0,d.y,0);
+	p001 =3D p000 + Ogre::Vector3(0,0,d.z);
+	p011 =3D p000 + Ogre::Vector3(0,d.y,d.z);
+	p101 =3D p000 + Ogre::Vector3(d.x,0,d.z);
+	p110 =3D p000 + Ogre::Vector3(d.x,d.y,0);
+
+	static int mlIndices[] =3D {
+		0,1,2, 3,1,2,	4,5,6, 7,5,6, // front, back
+		0,1,4, 5,1,4,	2,3,6, 7,3,6, // top, bottom
+		0,2,4, 6,2,4,	1,3,5, 7,3,5, // left, right
+		};
+	mlVertices[0] =3D p000;	mlVertices[1] =3D p100; // front
+	mlVertices[2] =3D p010;	mlVertices[3] =3D p110;
+
+	mlVertices[4] =3D p001;	mlVertices[5] =3D p101; // back
+	mlVertices[6] =3D p011;	mlVertices[7] =3D p111;
+
+	bool bHit =3D false;
+	float myHitDist;
+
+	for (int i=3D0;i&lt;6*6;i+=3D3) {
+		if (IntersectRayTriangle(vRayPos,vRayDir,
+			mlVertices[mlIndices[i+0]],
+			mlVertices[mlIndices[i+1]],
+			mlVertices[mlIndices[i+2]],&amp;myHitDist)) {
+			if (!bHit || myHitDist &lt; *pfHitDist) *pfHitDist =3D myHitDist;
+			bHit =3D true;
+		}
+	}
+	return bHit;
+}
+
+/// returns true if the ray intersects the entities triangles
+/// the resulting distance in the case of a hit is stored into pfHitDist
+/// see also OgreOpCode for more complex collision/intersection detection
+bool	cOgreWrapper::RayEntityQuery	(const Ogre::Vector3&amp; vRayPos,const Ogre=
::<i>Vector3&amp; vRayDir,Ogre::Entity* pEntity,const Ogre::Vector3&amp; vPos,const Og=
</I>re::Quaternion&amp; qRot,const Ogre::Vector3&amp; vScale,float* pfHitDist) { PROFILE
+	if (!pEntity) return false;
+	if (!pEntity-&gt;isVisible()) return false;
+
+	// get origin &amp; dir in coordinates local to the entity
+	MeshShape* myshape =3D MeshShape::GetMeshShape(pEntity);
+	if (!myshape) return false;
+	Ogre::Quaternion invrot =3D qRot.Inverse();
+	return myshape-&gt;RayIntersect((invrot*(vRayPos - vPos))/vScale,(invrot * v=
RayDir)/ vScale,pfHitDist);
+}
+
+/// extracs pos &amp; rot from scenenode, DOESNT WORK FOR entities in static g=
eometry (no scenenode)
+bool	cOgreWrapper::RayEntityQuery	(const Ogre::Vector3&amp; vRayPos,const Ogre=
::<i>Vector3&amp; vRayDir,Ogre::Entity* pEntity,float* pfHitDist) { PROFILE
</I>+	SceneNode* scenenode =3D pEntity ? pEntity-&gt;getParentSceneNode() : 0;
+	if (!scenenode) return false; // TODO : tagpoint (like knife in hand) att=
achment currently not supported...
+	return RayEntityQuery(vRayPos,vRayDir,pEntity,scenenode-&gt;_getDerivedPosit=
ion(),scenenode-&gt;_getDerivedOrientation(),scenenode-&gt;_getDerivedScale(),pfH=
itDist);
+}
+
+/// returns true if in front of cam, and fills x,y with clamped screencoor=
ds in [-1;1]
+/// and fills cx,cy with projected size on screen in [0;1]
+// cam-&gt;getProjectionMatrix() is cached inside ogre
+bool	cOgreWrapper::ProjectPos	(const Ogre::Vector3&amp; pos,Ogre::Real&amp; x,Ogre=
::<i>Real&amp; y) { PROFILE
</I>+	Camera* cam =3D mCamera;
+	Ogre::Vector3 eyeSpacePos =3D cam-&gt;getViewMatrix(true) * pos;
+	// z &lt; 0 means in front of cam
+	if (eyeSpacePos.z &lt; 0) {
+		Ogre::Vector3 screenSpacePos =3D cam-&gt;getProjectionMatrix() * eyeSpacePo=
s;
+		x =3D screenSpacePos.x;
+		y =3D screenSpacePos.y;
+		bool bIsOnSreen =3D true;
+		if (x &lt; -1.0) { x =3D -1.0; bIsOnSreen =3D false; } if (x &gt; 1.0) { x =3D=
 1.0; bIsOnSreen =3D false; }
+		if (y &lt; -1.0) { y =3D -1.0; bIsOnSreen =3D false; } if (y &gt; 1.0) { y =3D=
 1.0; bIsOnSreen =3D false; }
+		return bIsOnSreen;
+	} else {
+		x =3D (-eyeSpacePos.x &gt; 0) ? -1 : 1;
+		y =3D (-eyeSpacePos.y &gt; 0) ? -1 : 1;
+		return false;
+	}
+}
+
+/// returns true if in front of cam, and fills x,y with clamped screencoor=
ds in [-1;1]
+/// and fills cx,cy with projected size on screen in [0;1]
+// cam-&gt;getProjectionMatrix() is cached inside ogre
+bool	cOgreWrapper::ProjectSizeAndPos	(const Ogre::Vector3&amp; pos,Ogre::Real&amp;=
 x,Ogre::Real&amp; y,const Ogre::Real rad,Ogre::Real&amp; cx,Ogre::Real&amp; cy) { PROF=
ILE
+	Camera* cam =3D mCamera;
+	Ogre::Vector3 eyeSpacePos =3D cam-&gt;getViewMatrix(true) * pos;
+	// z &lt; 0 means in front of cam
+	if (eyeSpacePos.z &lt; 0) {
+		Ogre::Vector3 screenSpacePos =3D cam-&gt;getProjectionMatrix() * eyeSpacePo=
s;
+		x =3D screenSpacePos.x;
+		y =3D screenSpacePos.y;
+		bool bIsOnSreen =3D true;
+		if (x &lt; -1.0) { x =3D -1.0; bIsOnSreen =3D false; } if (x &gt; 1.0) { x =3D=
 1.0; bIsOnSreen =3D false; }
+		if (y &lt; -1.0) { y =3D -1.0; bIsOnSreen =3D false; } if (y &gt; 1.0) { y =3D=
 1.0; bIsOnSreen =3D false; }
+		if (bIsOnSreen) {
+			Ogre::Vector3 spheresize(rad, rad, eyeSpacePos.z);
+			spheresize =3D cam-&gt;getProjectionMatrix() * spheresize;
+			cx =3D spheresize.x;
+			cy =3D spheresize.y;
+		} else {
+			cx =3D 0;
+			cy =3D 0;
+		}
+		return bIsOnSreen;
+	} else {
+		cx =3D 0;
+		cy =3D 0;
+		x =3D (-eyeSpacePos.x &gt; 0) ? -1 : 1;
+		y =3D (-eyeSpacePos.y &gt; 0) ? -1 : 1;
+		return false;
+	}
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000018.html">[Iris-commit] [IRIS] r1202 - in /trunk/include: data.h	spritemanager.h
</A></li>
	<LI>Next message: <A HREF="000020.html">[Iris-commit] [IRIS] r1204 - in /trunk/data/lua: lib.3d.renderer.lua lib.models.lua lib.skill.lua lib.terrain.lua net.container.lua net.customhouse.lua net.mobile.lua net.objects.lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19">[ date ]</a>
              <a href="thread.html#19">[ thread ]</a>
              <a href="subject.html#19">[ subject ]</a>
              <a href="author.html#19">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/iris-commit">More information about the Iris-commit
mailing list</a><br>
</body></html>
