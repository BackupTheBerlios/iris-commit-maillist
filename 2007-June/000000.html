<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Iris-commit] [IRIS] r1184 - in /trunk: data/lua/lib.3d.map.lua data/lua/lib.3d.renderer.lua data/lua/net.corpse.lua data/lua/net.login.lua data/skippedfallbacks.lua src/scripting.cpp vc8/iris.vcproj
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/iris-commit/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:iris-commit%40lists.berlios.de?Subject=Re%3A%20%5BIris-commit%5D%20%5BIRIS%5D%20r1184%20-%20in%20/trunk%3A%20data/lua/lib.3d.map.lua%0A%20data/lua/lib.3d.renderer.lua%20data/lua/net.corpse.lua%20data/lua/net.login.lua%0A%20data/skippedfallbacks.lua%20src/scripting.cpp%20vc8/iris.vcproj&In-Reply-To=%3C20070610223511.69E7D1058005%40localhost.localdomain%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000001.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Iris-commit] [IRIS] r1184 - in /trunk: data/lua/lib.3d.map.lua data/lua/lib.3d.renderer.lua data/lua/net.corpse.lua data/lua/net.login.lua data/skippedfallbacks.lua src/scripting.cpp vc8/iris.vcproj</H1>
    <B>no-reply at zwischenwelt.org</B> 
    <A HREF="mailto:iris-commit%40lists.berlios.de?Subject=Re%3A%20%5BIris-commit%5D%20%5BIRIS%5D%20r1184%20-%20in%20/trunk%3A%20data/lua/lib.3d.map.lua%0A%20data/lua/lib.3d.renderer.lua%20data/lua/net.corpse.lua%20data/lua/net.login.lua%0A%20data/skippedfallbacks.lua%20src/scripting.cpp%20vc8/iris.vcproj&In-Reply-To=%3C20070610223511.69E7D1058005%40localhost.localdomain%3E"
       TITLE="[Iris-commit] [IRIS] r1184 - in /trunk: data/lua/lib.3d.map.lua data/lua/lib.3d.renderer.lua data/lua/net.corpse.lua data/lua/net.login.lua data/skippedfallbacks.lua src/scripting.cpp vc8/iris.vcproj">no-reply at zwischenwelt.org
       </A><BR>
    <I>Mon Jun 11 00:35:09 CEST 2007</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000001.html">[Iris-commit] [IRIS] r1185 - /trunk/data/lua/lib.data.lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#0">[ date ]</a>
              <a href="thread.html#0">[ thread ]</a>
              <a href="subject.html#0">[ subject ]</a>
              <a href="author.html#0">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: sience
Date: Mon Jun 11 00:35:06 2007
New Revision: 1184

Log:
-vs8 project (debug) updated
-skippedfallback added
-comments removed
-corpse packet temp. fixed

Modified:
    trunk/data/lua/lib.3d.map.lua
    trunk/data/lua/lib.3d.renderer.lua
    trunk/data/lua/net.corpse.lua
    trunk/data/lua/net.login.lua
    trunk/data/skippedfallbacks.lua
    trunk/src/scripting.cpp
    trunk/vc8/iris.vcproj

Modified: trunk/data/lua/lib.3d.map.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/data/lua/lib.3d.map.lua (original)
+++ trunk/data/lua/lib.3d.map.lua Mon Jun 11 00:35:06 2007
@@ -288,11 +288,6 @@
 						playerIsInside =3D true =

 					end
 				end
--- SiENcE: we have to include this for dynamic houses...but this slows per=
formance rapidly
---			else
---				if (x =3D=3D dynamic.xloc and y =3D=3D dynamic.yloc and dynamic.zloc=
 &gt; playerheadpos) then
---					playerIsInside =3D true =

---				end
 			end
 		end
 =


Modified: trunk/data/lua/lib.3d.renderer.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/data/lua/lib.3d.renderer.lua (original)
+++ trunk/data/lua/lib.3d.renderer.lua Mon Jun 11 00:35:06 2007
@@ -601,7 +601,7 @@
 			end
 			item.gfx =3D rootgfx
 			self:UpdateDynamicItemPos(item)
-		--Clientside Clientside Multi
+		-- otherwise ist a Clientside Multi
 		elseif gMultiLoader then
 			local rootgfx =3D CreateRootGfx3D()
 			local id =3D item.artid - gMulti_ID

Modified: trunk/data/lua/net.corpse.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/data/lua/net.corpse.lua (original)
+++ trunk/data/lua/net.corpse.lua Mon Jun 11 00:35:06 2007
@@ -20,10 +20,16 @@
 	local id =3D input:PopNetUint8()
 	local blocksize =3D input:PopNetUint16()
 	local corpse_serial =3D input:PopNetUint16()
+
+	for i=3D1, blocksize-5 do
+		local temp =3D input:PopNetUint8()
+	end
+--[[
 	--for =

 	local item_layer =3D input:PopNetUint8()
 	local item_serial =3D input:PopNetUint16()
 	--end
 	local terminator =3D input:PopNetUint16()
+]]--
 	printdebug(&quot;equip&quot;,sprintf(&quot;NET: kPacket_Corpse_Equipment: blocksize: %i =
corpse_serial=3D0x%04x\n&quot;,blocksize,corpse_serial))
 end

Modified: trunk/data/lua/net.login.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/data/lua/net.login.lua (original)
+++ trunk/data/lua/net.login.lua Mon Jun 11 00:35:06 2007
@@ -110,12 +110,12 @@
 	for i =3D 0,charlist.citynumber-1 do
 		gCities[i] =3D {}
 		gCities[i].index=3Dinput:PopNetUint8()
-		gCities[i].cityname=3Dinput:PopFilledString(30)
+		gCities[i].name=3Dinput:PopFilledString(30)
 		gCities[i].terminator1=3Dinput:PopNetUint8()
 		gCities[i].tavern=3Dinput:PopFilledString(30)
 		gCities[i].terminator2=3Dinput:PopNetUint8()
 =

-		printdebug(&quot;login&quot;,sprintf(&quot;NET: Index: %i City: %s Tavern: %s\n&quot;,gCitie=
s[i].index,gCities[i].cityname,gCities[i].tavern))
+		printdebug(&quot;login&quot;,sprintf(&quot;NET: Index: %i City: %s Tavern: %s\n&quot;,gCitie=
s[i].index,gCities[i].name,gCities[i].tavern))
 	end
 	charlist.cities =3D gCities
 =


Modified: trunk/data/skippedfallbacks.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/data/skippedfallbacks.lua (original)
+++ trunk/data/skippedfallbacks.lua Mon Jun 11 00:35:06 2007
@@ -293,3 +293,11 @@
 RegisterSkippedArtBillboardFallBack(2256) -- 0x08d0 name=3Dfireplace
 RegisterSkippedArtBillboardFallBack(2259) -- 0x08d3 name=3Dfireplace
 RegisterSkippedArtBillboardFallBack(2350) -- 0x092e name=3Doven
+RegisterSkippedArtBillboardFallBack(7740) -- 0x1e3c name=3Dbearskin rug
+RegisterSkippedArtBillboardFallBack(7741) -- 0x1e3d name=3Dbearskin rug
+RegisterSkippedArtBillboardFallBack(7742) -- 0x1e3e name=3Dbearskin rug
+RegisterSkippedArtBillboardFallBack(7734) -- 0x1e36 name=3Dbearskin rug
+RegisterSkippedArtBillboardFallBack(7736) -- 0x1e38 name=3Dbearskin rug
+RegisterSkippedArtBillboardFallBack(7738) -- 0x1e3a name=3Dbearskin rug
+RegisterSkippedArtBillboardFallBack(7739) -- 0x1e3b name=3Dbearskin rug
+RegisterSkippedArtBillboardFallBack(7737) -- 0x1e39 name=3Dbearskin rug

Modified: trunk/src/scripting.cpp
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/src/scripting.cpp (original)
+++ trunk/src/scripting.cpp Mon Jun 11 00:35:06 2007
@@ -1,1544 +1,1546 @@
-#include &quot;prefix.h&quot;
-#include &lt;assert.h&gt;
-#include &lt;stdarg.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &quot;net.h&quot;
-#include &quot;fifo.h&quot;
-#include &quot;game.h&quot;
-#include &quot;listener.h&quot;
-#include &quot;scripting.h&quot;
-#include &quot;input.h&quot;
-#include &quot;robstring1.2.h&quot;
-#include &quot;gfx3D.h&quot;
-#include &quot;gfx2D.h&quot;
-#include &quot;widget.h&quot;
-#include &quot;luabind.h&quot;
-#include &quot;data.h&quot;
-#include &quot;builder.h&quot;
-#include &quot;shell.h&quot;
-#include &quot;timer.h&quot;
-#include &quot;ogrewrapper.h&quot;
-#include &quot;pathsearch.h&quot;
-#include &quot;bitmask.h&quot;
-#include &quot;camera.h&quot;
-#include &quot;viewport.h&quot;
-#include &quot;rendertexture.h&quot;
-#include &quot;sound.h&quot;
-#include &quot;terrain.h&quot;
-#include &quot;radar.h&quot;
-#include &lt;Ogre.h&gt;
-#include &lt;OgreResourceManager.h&gt;
-#include &lt;OgreFontManager.h&gt;
-#include &lt;OgreTextAreaOverlayElement.h&gt;
-#include &lt;OgreMeshSerializer.h&gt;
-#include &lt;OgreCompositorManager.h&gt;
-#include &quot;luaxml.h&quot;
-#include &quot;spritemanager.h&quot;
-#include &quot;ogremanualloader.h&quot;
-
-//#define PROFILE_LUACALLCOUNT
-#ifdef PROFILE_LUACALLCOUNT
-std::map&lt;const char*,int&gt; gPROFILE_LUACALLCOUNT;
-struct cPROFILE_LUACALLCOUNTSetCmp {
-  inline bool operator() (const std::pair&lt;const char*,int&gt;&amp; x,const  std::=
pair&lt;const char*,int&gt;&amp; y) const { =

-	return x.second &gt; y.second; =

-  }
-};
-#endif
-
-#ifdef WIN32
-#include &lt;windows.h&gt;
-#else
-#include &lt;unistd.h&gt;
-#endif
-
-extern &quot;C&quot; {
-	#include &quot;lua.h&quot;
-	#include &quot;lauxlib.h&quot;
-	#include &quot;lualib.h&quot;
-}
-
-void	DisplayNotice			(const char* szMsg); ///&lt; defined in main.cpp, OS-spe=
cific
-void	DisplayErrorMessage		(const char* szMsg); ///&lt; defined in main.cpp, O=
S-specific
-void	Material_LuaRegister	(void *L);
-void	Granny_LuaRegister		(void *L);
-void	PrintLuaStackTrace		();
-void	ProfileDumpCallCount	(); ///&lt; defined in profile.cpp, only does somet=
hing if PROFILE_CALLCOUNT is enabled
-
-void	PrintLuaStackTrace		() { PROFILE
-	printf(&quot;PrintLuaStackTrace:\n&quot;);
-	// see l_TRACEBACK() : leaves a string containing the stacktrace at the t=
op of the stack
-	std::string sMyStackTrace;
-	cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;_TRACEBACK&quot;,&quot;&gt;s&quot;,&amp;sMyStackTrace);
-	printf(&quot;%s\n&quot;,sMyStackTrace.c_str());
-}
-
-void	PrintLuaStackTrace		(const char *filename) { PROFILE
-	FILE *f =3D fopen(filename,&quot;a&quot;);
-	if(f){
-		fprintf(f,&quot;PrintLuaStackTrace:\n&quot;);
-		// see l_TRACEBACK() : leaves a string containing the stacktrace at the =
top of the stack
-		std::string sMyStackTrace;
-		cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;_TRACEBACK&quot;,&quot;&gt;s&quot;,&amp;sMyStackTrace);
-		fprintf(f,&quot;%s\n&quot;,sMyStackTrace.c_str());
-		=

-		fclose(f);
-	}
-}
-
-void	printdebug	(const char *szCategory, const char *szFormat, ...) { PROF=
ILE
-	va_list ap;
-	va_start(ap,szFormat);
-	gRobStringBuffer[0] =3D 0;
-	vsnprintf(gRobStringBuffer,kRobStringBufferSize-1,szFormat,ap);
-	cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;printdebug&quot;,&quot;ss&quot;,szCategory,gRobS=
tringBuffer);
-	va_end(ap);
-}
-
-// ***** ***** global functionals exported to lua ***** *****
-
-
-cScripting*	cScripting::GetSingletonPtr	(cScripting* p) {
-	static cScripting* pSingleton =3D 0;
-	if (p) pSingleton =3D p;
-	return pSingleton;
-}
-
-
-/// called from lua : string keyname
-static int l_GetNamedKey (lua_State *L) { PROFILE
-	const char *keyname =3D luaL_checkstring(L, 1);
-	lua_pushnumber(L,cInput::GetSingleton().GetNamedKey(keyname));  // push r=
esult =

-	return 1;  // number of results =

-}
-
-/// called from lua : int keycode
-static int l_GetKeyName (lua_State *L) { PROFILE
-	int keycode =3D luaL_checkint(L, 1);
-	lua_pushstring(L,cInput::GetSingleton().GetKeyName(keycode));  // push re=
sult =

-	return 1;  // number of results =

-}
-
-/// terminates the application
-static int l_Terminate (lua_State *L) { PROFILE
-	cShell::mbAlive =3D false;
-	return 0;
-}
-
-/// only call this once at startup
-static int l_InitOgre (lua_State *L) { PROFILE
-	lua_pushboolean(L,cOgreWrapper::GetSingleton().Init());
-	return 1;
-}
-
-static int l_GetPointerSize (lua_State *L) { PROFILE
-	lua_pushnumber(L,sizeof(void*));
-	return 1;
-}
-
-/// only call this once at startup
-static int l_Client_IsAlive (lua_State *L) { PROFILE
-	lua_pushboolean(L,cShell::mbAlive);
-	return 1;
-}
-	=

-/// called from lua : no params, returns mousex,mousey,4xmousewheel info...
-static int l_PollInput (lua_State *L) { PROFILE
-	lua_pushnumber(L,cInput::iMouse[0]);
-	lua_pushnumber(L,cInput::iMouse[1]);
-	lua_pushnumber(L,cInput::iMouseWheel);
-	lua_pushnumber(L,cInput::iMouseWheel_pressed);
-	lua_pushnumber(L,cInput::iMouseWheel_all_since_last_step);
-	lua_pushnumber(L,cInput::iMouseWheel_pressed_since_last_step);
-	return 6;
-}
-
-
-static int l_ProfileDumpCallCount (lua_State *L) { PROFILE
-	ProfileDumpCallCount();
-	=

-	#ifdef PROFILE_LUACALLCOUNT
-	printf(&quot;LuaCallCounts:\n\n&quot;);
-	=

-	std::multiset&lt;std::pair&lt;const char*,int&gt;,cPROFILE_LUACALLCOUNTSetCmp&gt; myC=
allCountProfileSet;
-	typedef std::multiset&lt;std::pair&lt;const char*,int&gt;,cPROFILE_LUACALLCOUNTSet=
Cmp&gt;::iterator tLuaCallCountProfileSetItor;
-	{ for (std::map&lt;const char*,int&gt;::iterator itor=3DgPROFILE_LUACALLCOUNT.b=
egin();itor !=3D gPROFILE_LUACALLCOUNT.end();++itor)
-		myCallCountProfileSet.insert(std::make_pair((*itor).first,(*itor).second=
)); =

-	}
-	int i=3D0;
-	for (tLuaCallCountProfileSetItor itor=3DmyCallCountProfileSet.begin();ito=
r !=3D myCallCountProfileSet.end();++itor) {
-		//if (++i &gt; 10) break;
-		printf(&quot;LuaCallCallCount %16d %s\n&quot;,(*itor).second,(*itor).first);
-	}
-	#endif
-
-	return 0;
-}
-
-/// used as errfunc for lua_pcall, adds a callstack/backtrace/list_of_call=
ed_functions to the errormessage
-/// code from errorfb from /usr/src/lua-5.0.2/src/lua/ldblib.c
-/// &quot;_TRACEBACK&quot; is defined as errorfb
-/// leaves a string containing the stacktrace at the top of the stack
-#define LEVELS1	12	/* size of the first part of the stack */
-#define LEVELS2	10	/* size of the second part of the stack */
-static int l_TRACEBACK (lua_State *L) { PROFILE
-  int level =3D 1;  /* skip level 0 (it's this function) */
-  int firstpart =3D 1;  /* still before eventual `...' */
-  lua_Debug ar;
-  if (lua_gettop(L) =3D=3D 0)
-	lua_pushliteral(L, &quot;&quot;);
-  else if (!lua_isstring(L, 1)) return 1;  /* no string message */
-  else lua_pushliteral(L, &quot;\n&quot;);
-  lua_pushliteral(L, &quot;LuaStackTrace:\n&quot;);
-  while (lua_getstack(L, level++, &amp;ar)) {
-	if (level &gt; LEVELS1 &amp;&amp; firstpart) {
-	  /* no more than `LEVELS2' more levels? */
-	  if (!lua_getstack(L, level+LEVELS2, &amp;ar))
-		level--;  /* keep going */
-	  else {
-		lua_pushliteral(L, &quot;\n\t...&quot;);  /* too many levels */
-		while (lua_getstack(L, level+LEVELS2, &amp;ar))  /* find last levels */
-		  level++;
-	  }
-	  firstpart =3D 0;
-	  continue;
-	}
-	lua_pushliteral(L, &quot;\n\t&quot;);
-	lua_getinfo(L, &quot;Snl&quot;, &amp;ar);
-	lua_pushfstring(L, &quot;%s:&quot;, ar.short_src);
-	if (ar.currentline &gt; 0)
-	  lua_pushfstring(L, &quot;%d:&quot;, ar.currentline);
-	switch (*ar.namewhat) {
-	  case 'g':  /* global */ =

-	  case 'l':  /* local */
-	  case 'f':  /* field */
-	  case 'm':  /* method */
-		lua_pushfstring(L, &quot; in function `%s'&quot;, ar.name);
-		break;
-	  default: {
-		if (*ar.what =3D=3D 'm')  /* main? */
-		  lua_pushfstring(L, &quot; in main chunk&quot;);
-		else if (*ar.what =3D=3D 'C' || *ar.what =3D=3D 't')
-		  lua_pushliteral(L, &quot; ?&quot;);  /* C function or tail call */
-		else
-		  lua_pushfstring(L, &quot; in function &lt;%s:%d&gt;&quot;,
-							 ar.short_src, ar.linedefined);
-	  }
-	}
-	lua_concat(L, lua_gettop(L));
-  }
-  lua_concat(L, lua_gettop(L));
-  return 1;
-}
-
-
-
-static int l_Client_GetCurFPS (lua_State *L) { PROFILE
-	lua_pushnumber(L, (cTimer::miTimeSinceLastFrame &gt; 0) ? (float(1000.0) / f=
loat(cTimer::miTimeSinceLastFrame)) : 0.0 );
-	return 1;
-}
-
-static int l_Client_GetFrameNum (lua_State *L) { PROFILE
-	lua_pushnumber(L, cTimer::miCurFrameNum );
-	return 1;
-}
-
-static int l_Client_GetTicks (lua_State *L) { PROFILE
-	lua_pushnumber(L, cShell::GetTicks());
-	return 1;
-}
-
-
-/// void OgreAddCompositor(compositor script name)
-static int l_OgreAddCompositor (lua_State *L) { PROFILE
-	const char *name =3D luaL_checkstring(L,1);
-	Ogre::CompositorManager::getSingleton().addCompositor(cOgreWrapper::GetSi=
ngleton().mViewport, name);
-	return 0;
-}
-
-/// void OgreRemoveCompositor(compositor script name)
-static int l_OgreRemoveCompositor (lua_State *L) { PROFILE
-	const char *name =3D luaL_checkstring(L,1);
-	Ogre::CompositorManager::getSingleton().removeCompositor(cOgreWrapper::Ge=
tSingleton().mViewport, name);
-	return 0;
-}
-
-/// int =3D OgreMemoryUsage(part)
-/// part in {compositor,font,gpuprogram,highlevelgpuprogram,material,mesh,=
skeleton,texture,all}
-/// returns memory usage in byte
-static int l_OgreMemoryUsage (lua_State *L) { PROFILE
-	std::string part(luaL_checkstring(L,1));
-	size_t mem =3D 0;
-	=

-#ifdef OGRE_VERSION_SUFFIX
-	if(part.find(&quot;compositor&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=
=3D std::string::npos)mem +=3D Ogre::CompositorManager::getSingleton().getM=
emoryUsage();
-	if(part.find(&quot;font&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D std:=
:<i>string::npos)mem +=3D Ogre::FontManager::getSingleton().getMemoryUsage();
</I>-	if(part.find(&quot;gpuprogram&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=
=3D std::string::npos)mem +=3D Ogre::GpuProgramManager::getSingleton().getM=
emoryUsage();
-	if(part.find(&quot;highlevelgpuprogram&quot;) !=3D std::string::npos || part.find(&quot;=
all&quot;) !=3D std::string::npos)mem +=3D Ogre::HighLevelGpuProgramManager::get=
Singleton().getMemoryUsage();
-	if(part.find(&quot;material&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D =
std::string::npos)mem +=3D Ogre::MaterialManager::getSingleton().getMemoryU=
sage();
-	if(part.find(&quot;mesh&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D std:=
:<i>string::npos)mem +=3D Ogre::MeshManager::getSingleton().getMemoryUsage();
</I>-	if(part.find(&quot;skeleton&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D =
std::string::npos)mem +=3D Ogre::SkeletonManager::getSingleton().getMemoryU=
sage();
-	if(part.find(&quot;texture&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D s=
td::string::npos)mem +=3D Ogre::TextureManager::getSingleton().getMemoryUsa=
ge();
-#endif
-	=

-	lua_pushnumber(L, mem);
-	return 1;
-}
-
-/// bool =3D OgreMeshAvailable(ressourcename)
-static int l_OgreMeshAvailable (lua_State *L) { PROFILE
-	const char *name =3D luaL_checkstring(L,1);
-	bool ret;
-	=

-	try {
-		Ogre::MeshManager::getSingleton().load(name,Ogre::ResourceGroupManager::=
DEFAULT_RESOURCE_GROUP_NAME);
-		ret =3D true;
-	} catch (...) {
-			ret =3D false;
-	}
-	=

-	lua_pushboolean(L, ret);
-	return 1;
-}
-
-/// see also OgreMaterialAvailable below
-/// bool =3D OgreMaterialNameKnown(ressourcename)
-/// returns false if name is empty string or nil
-static int l_OgreMaterialNameKnown (lua_State *L) { PROFILE =

-	std::string sMatName =3D (lua_gettop(L) &gt;=3D 1 &amp;&amp; !lua_isnil(L,1)) ? luaL=
_checkstring(L,1) : &quot;&quot;;
-	if (sMatName.size() &gt; 0) { =

-		Ogre::MaterialPtr pMaterial =3D Ogre::MaterialManager::getSingleton().ge=
tByName(sMatName.c_str());
-		lua_pushboolean(L,!pMaterial.isNull());
-	} else {
-		lua_pushboolean(L,false);
-	}
-	return 1;
-}
-
-/// bool =3D OgreMaterialAvailable(ressourcename)
-static int l_OgreMaterialAvailable (lua_State *L) { PROFILE
-	assert(0 &amp;&amp; &quot;DON'T USE ME, ALWAYS RETURNS TRUE&quot;); =

-	// TODO, this code does not work, use l_OgreMaterialNameKnown  above
-	const char *name =3D luaL_checkstring(L,1);
-	bool ret;
-	=

-	try {
-		Ogre::MaterialManager::getSingleton().load(name,Ogre::ResourceGroupManag=
er::DEFAULT_RESOURCE_GROUP_NAME);
-		ret =3D true;
-	} catch (...) {
-			ret =3D false;
-	}
-	=

-	lua_pushboolean(L, ret);
-	return 1;
-}
-
-/// bool =3D OgreTextureAvailable(ressourcename)
-static int l_OgreTextureAvailable (lua_State *L) { PROFILE
-	const char *name =3D luaL_checkstring(L,1);
-	bool ret;
-	=

-	try {
-		Ogre::TextureManager::getSingleton().load(name,Ogre::ResourceGroupManage=
r::DEFAULT_RESOURCE_GROUP_NAME);
-		ret =3D true;
-	} catch (...) {
-			ret =3D false;
-	}
-	=

-	lua_pushboolean(L, ret);
-	return 1;
-}
-
-/// r,g,b =3D Uo16Color2Rgb(color)
-static int l_Uo16Color2Rgb (lua_State *L) { PROFILE
-	unsigned short color =3D luaL_checkint(L,1);
-	=

-	float r =3D float((color &gt;&gt; 10) &amp; 0x1F)/float(0x1f);
-	float g =3D float((color &gt;&gt;  5) &amp; 0x1F)/float(0x1f);
-	float b =3D float((color &gt;&gt;  0) &amp; 0x1F)/float(0x1f);
-				=

-	lua_pushnumber(L, r);
-	lua_pushnumber(L, g);
-	lua_pushnumber(L, b);
-	return 3;
-}
-
-/// CreateGrannyHuedTexture(GrannyTextureHook(texturepath),GrannyTextureHo=
ok(texturepath),gHueLoader,hue)
-static int l_CreateGrannyHuedTexture (lua_State *L) { PROFILE
-	std::string sTexturePath	=3D luaL_checkstring(L,1);
-	std::string sMaskPath		=3D luaL_checkstring(L,2);
-	cHueLoader *hueLoader 		=3D cLuaBind&lt;cHueLoader&gt;::checkudata(L,3);
-	int iHue					=3D luaL_checkint(L,4);
-	=

-	if (iHue =3D=3D 0 || !hueLoader) {
-		lua_pushstring(L,sTexturePath.c_str());
-		return 1;
-	}
-	=

-	// load image
-	Ogre::Image myImage;
-	myImage.load(sTexturePath,Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GR=
OUP_NAME);
-	=

-	// get image infos
-	Ogre::PixelFormat myFormat =3D myImage.getFormat();
-	unsigned int size =3D myImage.getSize();
-	unsigned int w =3D myImage.getWidth();
-	unsigned int h =3D myImage.getHeight();
-	unsigned int rowspan =3D myImage.getRowSpan();
-	unsigned int pixelsize =3D Ogre::PixelUtil::getNumElemBytes(myFormat);
-	//Ogre::uchar* dst =3D new Ogre::uchar[size];
-	Ogre::uchar* src =3D myImage.getData();
-	//Ogre::uchar* dst_start =3D dst;
-	Ogre::uchar* src_start =3D src;
-	uint8 cr,cg,cb,ca1,ca2;
-	short col;
-	=

-	// debug info
-	//printf(&quot;image size=3D%d w=3D%d h=3D%d d=3D%d f=3D%d bpp=3D%d rowspan=3D=
%d bIsNonZero2=3D%d\n&quot;,size,w,h,
-	//	myImage.getDepth(),myImage.getNumFaces(),myImage.getBPP(),rowspan,bIsN=
onZero2?1:0);
-	=

-	// hue filter
-	cHueFilter Filter;
-	short* ColorTable =3D hueLoader-&gt;GetHue( iHue-1 )-&gt;GetColors();
-	=

-	// colorize the pixels
-	for(unsigned int y =3D 0; y &lt; h; y++){
-		for(unsigned int x =3D 0; x &lt; w; x++) {
-			// read out pixel in src graphic
-			Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca1,myFormat,src);
-			Ogre::PixelUtil::packColour(cr,cg,cb,ca1,Ogre::PF_A1R5G5B5,&amp;col);
-			// and hue the pixel
-			col =3D Filter( col, ColorTable );
-			// TODO ! respect mask instead of hueing the complete texture
-			// and store it in destination (ignoring the new alpha)
-			Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca2,Ogre::PF_A1R5G5B5,&amp;col);
-			Ogre::PixelUtil::packColour(cr,cg,cb,ca1,myFormat,src);
-			src +=3D pixelsize;
-			//dst +=3D pixelsize;
-		}
-		src +=3D rowspan - w*pixelsize;
-	}
-	=

-	// and make a texture
-	std::string newtextname =3D cOgreWrapper::GetSingleton().GetUniqueName();
-	//Ogre::DataStreamPtr texstream(new Ogre::MemoryDataStream(dst_start, siz=
e));
-	//Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().loadR=
awData(newtextname,
-	//	Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,texstream, w,h=
,myFormat);
-	=

-	Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().loadIma=
ge(newtextname,
-		Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,myImage,Ogre::TE=
X_TYPE_2D,-1,1.0f,true,Ogre::PF_UNKNOWN);
-	=

-	// free memory
-	//delete [] dst_start;
-
-	lua_pushstring(L,newtextname.c_str());
-	return 1;
-}
-	=

-/// void HueMesh(meshname, hueloader, hue)
-static int l_HueMesh (lua_State *L) { PROFILE
-	const char *meshname =3D luaL_checkstring(L,1);
-	cHueLoader *hueLoader =3D cLuaBind&lt;cHueLoader&gt;::checkudata(L,2);
-	int hue =3D luaL_checkint(L,3);
-
-	//printf(&quot;HueMesh(%s,%i,%i)\n&quot;,meshname,hueLoader,hue);
-	if(hueLoader &amp;&amp; hue &amp;&amp; meshname){
-		try	{
-			cHueFilter Filter;
-			short* ColorTable =3D hueLoader-&gt;GetHue( hue-1 )-&gt;GetColors();
-		=

-			// data seem ok, so read out the mesh
-			Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().load(meshname,=
Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
-			=

-			//printf(&quot;mesh=3D%s\n&quot;,mesh-&gt;getName().c_str());
-
-			// and iterate over all submeshes
-			Ogre::Mesh::SubMeshIterator sit =3D mesh-&gt;getSubMeshIterator();
-			while(sit.hasMoreElements()){
-				Ogre::SubMesh *submesh =3D sit.getNext();
-				//printf(&quot;submesh=3D%i\n&quot;,submesh);
-				=

-				if(!submesh-&gt;isMatInitialised())continue;
-				=

-				//printf(&quot;matname=3D%s\n&quot;,submesh-&gt;getMaterialName().c_str());
-
-				// create hued texture in the current material and update the current =

-				Ogre::MaterialPtr mat =3D Ogre::MaterialManager::getSingleton().load(s=
ubmesh-&gt;getMaterialName(),Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROU=
P_NAME);
-				if(mat.isNull()){
-					printf(&quot;ERROR HueMesh: material %s is null\n&quot;,submesh-&gt;getMaterialNam=
e().c_str());
-					continue;
-				}
-
-				// clone current material for hueing
-				std::string newname =3D cOgreWrapper::GetSingleton().GetUniqueName();
-				Ogre::MaterialPtr mat_hue =3D Ogre::MaterialManager::getSingleton().cr=
eate(newname, mat-&gt;getGroup());
-				//printf(&quot;mat=3D%s mat_hue=3D%s\n&quot;,mat-&gt;getName().c_str(),mat_hue-&gt;get=
Name().c_str());
-				mat-&gt;copyDetailsTo(mat_hue);
-
-				// iterate over all techniques
-				Ogre::Material::TechniqueIterator tit =3D mat-&gt;getTechniqueIterator();
-				Ogre::Material::TechniqueIterator tit_hue =3D mat_hue-&gt;getTechniqueIte=
rator();
-				while(tit.hasMoreElements()){
-					Ogre::Technique *tech =3D tit.getNext();
-					Ogre::Technique *tech_hue =3D tit_hue.getNext();
-					=

-					// iterate over all passes
-					Ogre::Technique::PassIterator pit =3D tech-&gt;getPassIterator();
-					Ogre::Technique::PassIterator pit_hue =3D tech_hue-&gt;getPassIterator();
-					while(pit.hasMoreElements()){
-						Ogre::Pass *pass =3D pit.getNext();
-						Ogre::Pass *pass_hue =3D pit_hue.getNext();
-						=

-						// iterate over all tex units
-						Ogre::Pass::TextureUnitStateIterator uit =3D pass-&gt;getTextureUnitSta=
teIterator();
-						Ogre::Pass::TextureUnitStateIterator uit_hue =3D pass_hue-&gt;getTextur=
eUnitStateIterator();
-						while(uit.hasMoreElements()){
-							Ogre::TextureUnitState *unit =3D uit.getNext();
-							Ogre::TextureUnitState *unit_hue =3D uit_hue.getNext();
-
-							// current texture
-							Ogre::TexturePtr tex =3D Ogre::TextureManager::getSingleton().load(=
unit-&gt;getTextureName(),Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_N=
AME);
-
-							// lock and read access buffer
-							Ogre::HardwarePixelBufferSharedPtr b =3D tex-&gt;getBuffer();
-							// calc size of complete texture
-							Ogre::Image::Box area(0, 0, b-&gt;getWidth(), b-&gt;getHeight());
-							// and lock (ro)
-							const Ogre::PixelBox box =3D b-&gt;lock(area,Ogre::HardwareBuffer::HBL=
_READ_ONLY);
-							=

-							// size of one pixel in bytes
-							unsigned int pixelsize =3D Ogre::PixelUtil::getNumElemBytes(box.for=
mat);
-							// texture size in bytes
-							unsigned int size =3D box.getConsecutiveSize();
-							=

-							char *dst =3D new char[size];
-							char *src =3D static_cast&lt;char *&gt;(box.data);
-
-							char *dst_start =3D dst;
-							char *src_start =3D src;
-
-							uint8 cr,cg,cb,ca1,ca2;
-							short col;
-							=

-							// colorize the pixels
-							for(unsigned int y =3D 0; y &lt; box.getHeight(); y++){
-								for(unsigned int x =3D 0; x &lt; box.getWidth(); x++){
-									// read out pixel in src graphic
-									Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca1,box.format,src);
-									Ogre::PixelUtil::packColour(cr,cg,cb,ca1,Ogre::PF_A1R5G5B5,&amp;col);
-									// and hue the pixel
-									col =3D Filter( col, ColorTable );
-									//printf(&quot;RGBA_1(%i,%i,%i,%i)\n&quot;,cr,cg,cb,ca);
-									// and store it in destination (ignoring the new alpha)
-									Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca2,Ogre::PF_A1R5G5B5,=
&amp;col);
-									Ogre::PixelUtil::packColour(cr,cg,cb,ca1,box.format,dst);
-									//printf(&quot;RGBA_2(%i,%i,%i,%i)\n&quot;,cr,cg,cb,ca);
-									src +=3D pixelsize;
-									dst +=3D pixelsize;
-								}
-								src +=3D box.getRowSkip();
-							}
-
-							// and make a texture
-							Ogre::DataStreamPtr texstream(new Ogre::MemoryDataStream(dst_start,=
 size));
-							Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().c=
reate(cOgreWrapper::GetSingleton().GetUniqueName(),
-								Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
-							=

-							tex_hue-&gt;loadRawData(texstream,box.getWidth(),box.getHeight(),box.f=
ormat);
-							=

-							// release the lock
-							b-&gt;unlock();
-
-							// free memory
-							delete [] dst_start;
-		=

-							// set the texture
-							unit_hue-&gt;setTextureName(tex_hue-&gt;getName());
-						}
-					}
-				}
-
-				// set new material
-				submesh-&gt;setMaterialName(mat_hue-&gt;getName());
-			}
-		} catch (Ogre::FileNotFoundException e){
-			printf(&quot;ERROR file not found, so HueMesh(%s) canceled\n&quot;,meshname);
-		}
-	}
-
-	return 0;
-}
-
-/// create a lua lookup table based on the given file
-/// usage: lookup[id] =3D new_id
-static int l_CreateLookupTableFromFile (lua_State *L) { PROFILE
-	const char *filename =3D luaL_checkstring(L, 1);
-	lua_newtable(L);
-	=

-	cFullFileLoader f(filename);
-	=

-	const uint32 *buffer =3D (const uint32 *)f.mpFullFileBuffer;
-	=

-	for(int i =3D 0;i &lt; f.miFullFileSize / 4; ++i){
-		lua_pushnumber(L,i); lua_rawseti(L,-2,buffer[i]);
-	}
-	=

-	return 1;
-}
-
-
-static int l_Client_SetSkybox (lua_State *L) { PROFILE
-	cOgreWrapper::GetSingleton().SetSkybox( (lua_gettop(L) &gt; 0 &amp;&amp; !lua_isnil(=
L,1)) ? luaL_checkstring(L, 1) : 0 , true );
-	return 0;
-}
-
-static int l_Client_SetFog (lua_State *L) { PROFILE
-	int i=3D0;
-	int numargs=3Dlua_gettop(L);
-	int iFogMode 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checkint(L,=
 ++i) : 0;
-	Ogre::Real r 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
-	Ogre::Real g 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
-	Ogre::Real b 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
-	Ogre::Real a 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
-	Ogre::Real expDensity 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_chec=
knumber(L, ++i) : 0.001;
-	Ogre::Real linearStart 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_che=
cknumber(L, ++i) : 0.0;
-	Ogre::Real linearEnd 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_check=
number(L, ++i) : 1.0;
-	/*
-	void 	setFog (FogMode mode=3DFOG_NONE, const ColourValue &amp;colour=3DColour=
Value::White, =

-					Real expDensity=3D0.001, Real linearStart=3D0.0, Real linearEnd=3D1.0)
-    0=3DFOG_NONE 	No fog. Duh.
-    1=3DFOG_EXP 	Fog density increases exponentially from the camera (fog =
=3D 1/e^(distance * density)).
-    2=3DFOG_EXP2 	Fog density increases at the square of FOG_EXP, i.e. eve=
n quicker (fog =3D 1/e^(distance * density)^2).
-    3=3DFOG_LINEAR 	Fog density increases linearly between the start and e=
nd distances.
-	*/
-	Ogre::FogMode      myFogMode =3D Ogre::FOG_NONE;
-	if (iFogMode =3D=3D 1) myFogMode =3D Ogre::FOG_EXP;
-	if (iFogMode =3D=3D 2) myFogMode =3D Ogre::FOG_EXP2;
-	if (iFogMode =3D=3D 3) myFogMode =3D Ogre::FOG_LINEAR;
-	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setFog(myFogMode,Ogre::ColourValu=
e(r,g,b,a),expDensity,linearStart,linearEnd);
-	return 0;
-}
-
-static int l_Client_RenderOneFrame (lua_State *L) { PROFILE
-	cGame::GetSingleton().RenderOneFrame();
-	return 0;
-}
-
-/// just do nothing for x seconds
-static int l_Client_Sleep (lua_State *L) { PROFILE
-	//TODO correct win handling
-#ifndef WIN32
-	sleep(luaL_checkint(L,1));
-#else
-	Sleep(luaL_checkint(L,1)*1000); // takes milliseconds
-#endif
-	return 0;
-}
-
-/// just do nothing for x milliseconds (1000msec =3D 1sec)
-static int l_Client_USleep (lua_State *L) { PROFILE
-	//TODO correct win handling
-#ifndef WIN32
-	usleep((uint32)luaL_checkint(L,1)*(uint32)1000L); // usleep takes MICROse=
conds, where 1000 =3D 1 MILLIsecond
-#else
-	Sleep(luaL_checkint(L,1)); // takes milliseconds
-#endif
-	return 0;
-}
-
-
-
-static int l_Client_SetAmbientLight (lua_State *L) { PROFILE
-	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
-	if (pSceneMgr) pSceneMgr-&gt;setAmbientLight(Ogre::ColourValue(luaL_checknum=
ber(L,1),luaL_checknumber(L,2),luaL_checknumber(L,3),luaL_checknumber(L,4))=
);
-	return 0;
-}
-
-static int l_Client_ClearLights (lua_State *L) { PROFILE
-	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
-	if (pSceneMgr) pSceneMgr-&gt;destroyAllLights();
-	return 0;
-}
-
-static int l_Client_AddPointLight (lua_State *L) { PROFILE
-	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
-	if (pSceneMgr) {
-		Ogre::Light* pLight =3D pSceneMgr-&gt;createLight( cOgreWrapper::GetSinglet=
on().GetUniqueName() );
-		pLight-&gt;setType( Ogre::Light::LT_POINT );
-		pLight-&gt;setPosition(luaL_checknumber(L,1),luaL_checknumber(L,2),luaL_che=
cknumber(L,3));
-	}
-	return 0;
-}
-
-static int l_Client_AddDirectionalLight (lua_State *L) { PROFILE
-	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
-	if (pSceneMgr) {
-		Ogre::Light* pLight =3D pSceneMgr-&gt;createLight( cOgreWrapper::GetSinglet=
on().GetUniqueName() );
-		pLight-&gt;setType( Ogre::Light::LT_DIRECTIONAL );
-		pLight-&gt;setDirection(luaL_checknumber(L,1),luaL_checknumber(L,2),luaL_ch=
ecknumber(L,3));
-	}
-	return 0;
-}
-
-static int l_Client_GetPhysStepTime (lua_State *L) { PROFILE
-	lua_pushnumber(L,cTimer::mfPhysStepTime);
-	return 1;
-}
-
-/// saved in main directory
-static int l_Client_TakeGridScreenshot (lua_State *L) { PROFILE
-	std::string filename =3D strprintf( &quot;%shighres_%d&quot;, &quot;../screenshots/&quot;, cS=
hell::GetTicks() );
-	std::string ext =3D &quot;.jpg&quot;;
-	cOgreWrapper::GetSingleton().TakeGridScreenshot(3,filename,ext,true);
-	return 0;
-}
-
-/// saved in main directory
-static int l_Client_TakeScreenshot (lua_State *L) { PROFILE
-	cOgreWrapper::GetSingleton().TakeScreenshot();
-	return 0;
-}
-
-void	OgreForceCloseFullscreen ();
-
-/// shows ogre config dialog
-static int l_Client_ShowOgreConfig (lua_State *L) { PROFILE
-	bool bIsFullscreen =3D cOgreWrapper::GetSingleton().mWindow-&gt;isFullScreen=
();
-	printf(&quot;Client_ShowOgreConfig fullscreen=3D%d\n&quot;,bIsFullscreen);
-	bIsFullscreen =3D true; // detection fails in linux ?
-	if (bIsFullscreen) {
-		// hide window to make config window visible in fullscreen mode, evil ha=
ck since this is not supported by ogre
-		OgreForceCloseFullscreen();
-	}
-	lua_pushboolean(L,cOgreWrapper::GetSingleton().mRoot-&gt;showConfigDialog());
-	if (bIsFullscreen) cShell::mbAlive =3D false;
-	// the application shoudl terminate after this
-	// terminates the game if changes were made
-	return 1;
-}
-
-static int l_BuildTerrainEntity_Simple (lua_State *L) { PROFILE
-	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
-	if (!pGroundBlockLoader) return 0;
-	int i=3D5;
-	bool bGenerateNormals=3D		(lua_gettop(L) &gt;=3D ++i &amp;&amp; !lua_isnil(L,i)) ? l=
ua_toboolean(L,i) : true;
-	std::string meshname =3D BuildTerrainEntity_Simple(
-		pGroundBlockLoader,
-		luaL_checkint(L,2),luaL_checkint(L,3),
-		luaL_checkint(L,4),luaL_checkint(L,5),bGenerateNormals);
-	if (meshname.length() =3D=3D 0) return 0;
-	lua_pushstring(L,meshname.c_str());
-	return 1;
-}
-
-static int l_BuildTerrainEntity_Shaded (lua_State *L) { PROFILE
-	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
-	if (!pGroundBlockLoader) return 0;
-	std::string meshname =3D BuildTerrainEntity_Shaded(
-		pGroundBlockLoader,
-		luaL_checkint(L,2),luaL_checkint(L,3),
-		luaL_checkint(L,4),luaL_checkint(L,5));
-	if (meshname.length() =3D=3D 0) return 0;
-	lua_pushstring(L,meshname.c_str());
-	return 1;
-}
-
-/// OBSOLETED CODE ! don't use this, hasn't been adjusted to xmirror fix
-/// for lua : TerrainRayPick(GroundBlockLoader,blockx,blocky,vBlockPosX,vB=
lockPosY,vBlockPosZ,rx,ry,rz,rvx,rvy,rvz)  -- mainly for mousepicking
-static int l_TerrainRayPick (lua_State *L) { PROFILE
-	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
-	if (!pGroundBlockLoader) return 0;
-	=

-	// don't use ++i or something here, the compiler might mix the order
-	Ogre::Vector3 	vBlockPos(luaL_checknumber(L,4),luaL_checknumber(L,5),luaL=
_checknumber(L,6));
-	Ogre::Vector3	vRayPos(luaL_checknumber(L,7),luaL_checknumber(L,8),luaL_ch=
ecknumber(L,9));
-	Ogre::Vector3	vRayDir(luaL_checknumber(L,10),luaL_checknumber(L,11),luaL_=
checknumber(L,12));
-	=

-	// feedback via lua callback TerrainRayIntersect_Hit()
-	TerrainRayIntersect(pGroundBlockLoader,luaL_checkint(L,2),luaL_checkint(L=
,3),vRayPos-vBlockPos,vRayDir);
-	return 0;
-}
-
-/// for lua : dist =3D SphereRayPick(x,y,z,rad,rx,ry,rz,rvx,rvy,rvz)  -- m=
ainly for mousepicking, dist=3Dnil if not hit
-static int l_SphereRayPick (lua_State *L) { PROFILE
-	// don't use ++i or something here, the compiler might mix the order
-	Ogre::Vector3 	vSpherePos(	luaL_checknumber(L,1),luaL_checknumber(L,2),lu=
aL_checknumber(L,3));
-	float			fSphereRad =3D luaL_checknumber(L,4);
-	Ogre::Vector3	vRayPos(	luaL_checknumber(L,5),luaL_checknumber(L,6),luaL_c=
hecknumber(L,7));
-	Ogre::Vector3	vRayDir(	luaL_checknumber(L,8),luaL_checknumber(L,9),luaL_c=
hecknumber(L,10));
-	=

-	std::pair&lt;bool, Real&gt; hit =3D Ogre::Ray(vRayPos,vRayDir).intersects(Ogre:=
:<i>Sphere(vSpherePos,fSphereRad));
</I>-	if (!hit.first) return 0;
-	lua_pushnumber(L,hit.second);
-	return 1;
-}
-
-
-static int l_UnloadMeshName (lua_State *L) { PROFILE
-	Ogre::MeshManager::getSingleton().unload(luaL_checkstring(L,1));
-	return 0;
-}
-
-static int l_CountMeshTriangles (lua_State *L) { PROFILE
-	Ogre::MeshPtr pMesh =3D Ogre::MeshManager::getSingleton().load(luaL_check=
string(L,1),
-					Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
-	int res =3D 0;
-	for (int i=3D0;i&lt;pMesh-&gt;getNumSubMeshes();++i) {
-		Ogre::SubMesh *pSub =3D pMesh-&gt;getSubMesh(i);
-		if (pSub &amp;&amp; pSub-&gt;indexData) res +=3D pSub-&gt;indexData-&gt;indexCount / 3;
-	}
-	lua_pushnumber(L,res);
-	return 1;
-}
-
-static int l_getUOPath(lua_State *L) { PROFILE
-	std::string res =3D getUOPath();
-	if (res.length() =3D=3D 0) return 0;
-	lua_pushstring(L,res.c_str());
-	return 1;
-}
-
-/// attempts to correct case-sensitivity for filepaths
-static int l_PathSearch (lua_State *L) { PROFILE
-	std::string res =3D rob_pathsearch(luaL_checkstring(L,1));
-	if (res.length() =3D=3D 0) return 0;
-	lua_pushstring(L,res.c_str());
-	return 1;
-}
-
-static int l_file_exists (lua_State *L) { PROFILE
-	std::ifstream	myFileStream(luaL_checkstring(L,1));
-	lua_pushboolean(L,myFileStream?true:false);
-	return 1;
-}
-
-static int l_file_size (lua_State *L) { PROFILE
-	std::ifstream	myFileStream(luaL_checkstring(L,1));
-	int iFileSize =3D 0;
-	if (myFileStream) {
-		myFileStream.seekg(0, std::ios::end);
-		iFileSize =3D myFileStream.tellg();
-	}
-	lua_pushnumber(L,iFileSize);
-	return 1;
-}
-
-
-// for testing bitwise ops
-static int l_GetRandomHexString 	(lua_State *L) { PROFILE lua_pushstring( =
L, strprintf(&quot;0x%08x&quot;,rand()).c_str()); return 1; }
-
-/// converts &quot;0x1234&quot; to a number
-static int l_Hex2Num 	(lua_State *L) { PROFILE =

-	std::string hexcode =3D luaL_checkstring(L,1);
-	uint32 res =3D 0;
-	sscanf(hexcode.c_str(),&quot;0x%x&quot;,&amp;res);
-	lua_pushnumber(L, res); =

-	return 1; =

-}
-
-// bitwise operations, used for networking, packet manipulation etc
-static int l_BitwiseAND 	(lua_State *L) { PROFILE
-	// keep this spread out like this to avoid strange, 32 bi
-	double g =3D luaL_checknumber(L,1);
-	double h =3D luaL_checknumber(L,2);
-	uint32 a =3D uint32(g);
-	uint32 b =3D uint32(h);	=

-	uint32 c =3D a &amp; b;
-	lua_pushnumber( L, c); =

-	return 1;
-}
-static int l_BitwiseOR 		(lua_State *L) { PROFILE
-	// keep this spread out like this to avoid strange, 32 bi
-	double g =3D luaL_checknumber(L,1);
-	double h =3D luaL_checknumber(L,2);
-	uint32 a =3D uint32(g);
-	uint32 b =3D uint32(h);	=

-	uint32 c =3D a | b;
-	lua_pushnumber( L, c); =

-	return 1;
-}
-
-
-static int l_BitwiseXOR 	(lua_State *L) { PROFILE
-	// keep this spread out like this to avoid strange, 32 bi
-	double g =3D luaL_checknumber(L,1);
-	double h =3D luaL_checknumber(L,2);
-	uint32 a =3D uint32(g);
-	uint32 b =3D uint32(h);	=

-	uint32 c =3D a ^ b;
-	lua_pushnumber( L, c); =

-	return 1;
-}
-
-// bitwise operations, used for networking, packet manipulation etc =

-static int l_BitwiseSHL 	(lua_State *L) { PROFILE =

-	// keep this spread out like this to avoid strange, 32 bi =

-	double g =3D luaL_checknumber(L,1); =

-	double h =3D luaL_checknumber(L,2); =

-	uint32 a =3D uint32(g); =

-	uint32 b =3D uint32(h);	 =

-	uint32 c =3D a &lt;&lt; b; =

-	lua_pushnumber( L, c);  =

-	return 1; =

-} =

-// bitwise operations, used for networking, packet manipulation etc =

-static int l_BitwiseSHR 	(lua_State *L) { PROFILE =

-	// keep this spread out like this to avoid strange, 32 bi =

-	double g =3D luaL_checknumber(L,1); =

-	double h =3D luaL_checknumber(L,2); =

-	uint32 a =3D uint32(g); =

-	uint32 b =3D uint32(h);	 =

-	uint32 c =3D a &gt;&gt; b; =

-	lua_pushnumber( L, c);  =

-	return 1; =

-}
-
-
-static int l_TestBit 		(lua_State *L) { PROFILE lua_pushboolean(L,(uint32(=
luaL_checknumber(L,1)) &amp; (uint32(1) &lt;&lt; luaL_checkint(L,2))) !=3D 0); return=
 1; }
-static int l_SetBit 		(lua_State *L) { PROFILE lua_pushnumber( L,(uint32(l=
uaL_checknumber(L,1)) | (uint32(1) &lt;&lt; luaL_checkint(L,2)))); return 1; }
-static int l_ClearBit 		(lua_State *L) { PROFILE =

-	uint32 input =3D uint32(luaL_checknumber(L,1));
-	uint32 mask =3D 1L &lt;&lt; uint32(luaL_checknumber(L,2));
-	lua_pushnumber(L,(input &amp; mask)?(input ^ mask):(input));  // XOR =3D ^ =
=3D toggle bit... toggle only if set (&amp;) to clear
-	return 1; =

-}
-
-
-static int l_Exit		 		(lua_State *L) { PROFILE =

-	exit((lua_gettop(L) &gt;=3D 1 &amp;&amp; !lua_isnil(L,1)) ? luaL_checkint(L,1) : 0); =

-	return 0; =

-}
-
-static int l_Crash		 		(lua_State *L) { PROFILE =

-	DisplayErrorMessage(&quot;CRASH triggered from script, see console for info (s=
tart with commandline option -c)&quot;);
-	exit(88); =

-	return 0; =

-}
-
-/// triggers a segfault, for testing our segfault handlers lua stacktrace
-static int l_CrashSegFault		 		(lua_State *L) { PROFILE =

-	DisplayErrorMessage(&quot;testing segfault handler...&quot;);
-	*((char*)0) =3D 0; // trigger segfault
-	return 0; =

-}
-
-
-static int l_DisplayNotice	(lua_State *L) { PROFILE =

-	DisplayNotice(luaL_checkstring(L,1));
-	return 0;
-}
-
-
-static int l_FatalErrorMessage	(lua_State *L) { PROFILE =

-	DisplayErrorMessage(luaL_checkstring(L,1));
-	exit(77);
-	return 0;
-}
-
-
-/// for lua :   void  ExportMesh  (meshname,filename)
-static int l_ExportMesh		(lua_State *L) { PROFILE =

-	Ogre::MeshPtr pMesh =3D Ogre::MeshManager::getSingleton().load(luaL_check=
string(L,1),
-					// autodetect group location
-					//Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
-					Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
-	Ogre::MeshSerializer myExporter;
-	//Ogre::Mesh* pMesh =3D pEntity-&gt;getMesh().get();
-	myExporter.exportMesh(pMesh.get(),luaL_checkstring(L,2)); =

-	return 0;
-}
-
-/// for lua :   x,y,z,vx,vy,vz  GetMouseRay  ()
-static int l_GetMouseRay		(lua_State *L) { PROFILE =

-	cOgreWrapper&amp; ogrewrapper =3D cOgreWrapper::GetSingleton();
-	Ogre::Ray myray(	ogrewrapper.mCamera-&gt;getCameraToViewportRay(
-				Ogre::Real(cInput::iMouse[0]) / Ogre::Real(ogrewrapper.mViewport-&gt;getA=
ctualWidth()),
-				Ogre::Real(cInput::iMouse[1]) / Ogre::Real(ogrewrapper.mViewport-&gt;getA=
ctualHeight()) ));
-	lua_pushnumber(L,myray.getOrigin().x);
-	lua_pushnumber(L,myray.getOrigin().y);
-	lua_pushnumber(L,myray.getOrigin().z);
-	lua_pushnumber(L,myray.getDirection().x);
-	lua_pushnumber(L,myray.getDirection().y);
-	lua_pushnumber(L,myray.getDirection().z);
-	return 6;
-}
-
-/// for lua :   z  GetMaxZ  ()
-static int 		l_GetMaxZ		(lua_State *L) { PROFILE =

-	lua_pushnumber(L,Ogre::Root::getSingleton().getRenderSystem()-&gt;getMaximum=
DepthInputValue());
-	return 1;
-}
-
-
-/// for lua :   bIsInFront,px,py  ProjectPos  (x,y,z)
-static int l_ProjectPos		(lua_State *L) { PROFILE =

-	bool 		bIsInFront;
-	Ogre::Real	fX,fY;
-	bIsInFront =3D cOgreWrapper::GetSingleton().ProjectPos(
-		Ogre::Vector3(luaL_checknumber(L,0),luaL_checknumber(L,1),luaL_checknumb=
er(L,2)),fX,fY);
-	lua_pushboolean(L,bIsInFront);
-	lua_pushnumber(L,fX);
-	lua_pushnumber(L,fY);
-	return 3;
-}
-
-/// for lua :   bIsInFront,px,py,cx,cy  ProjectSizeAndPos  (x,y,z,r)
-static int l_ProjectSizeAndPos		(lua_State *L) { PROFILE =

-	bool 		bIsInFront;
-	Ogre::Real	fX,fY,fCX,fCY;
-	bIsInFront =3D cOgreWrapper::GetSingleton().ProjectSizeAndPos(
-		Ogre::Vector3(luaL_checknumber(L,0),luaL_checknumber(L,1),luaL_checknumb=
er(L,2)),fX,fY,luaL_checknumber(L,3),fCX,fCY);
-	lua_pushboolean(L,bIsInFront);
-	lua_pushnumber(L,fX);
-	lua_pushnumber(L,fY);
-	lua_pushnumber(L,fCX);
-	lua_pushnumber(L,fCY);
-	return 5;
-}
-
-
-
-/// for lua :   void  CreateSceneManager  (sSceneManagerName)
-static int l_CreateSceneManager		(lua_State *L) { PROFILE  // TODO : move =
to seperate file ?
-	cOgreWrapper::GetSingleton().mRoot-&gt;createSceneManager(Ogre::ST_GENERIC,l=
uaL_checkstring(L,1));
-	return 0;
-}
-
-/// for lua :   table[id=3Dtexname...]  OgreMeshTextures  (meshfile)
-static int l_OgreMeshTextures	(lua_State *L) { PROFILE  // TODO : move to =
seperate file ?
-	Ogre::MeshSerializer* meshSerializer =3D new Ogre::MeshSerializer();
-	const char *szMeshName =3D luaL_checkstring(L,1);
-	=

-	lua_newtable(L);
-		=

-	//printf(&quot;open file: %s\n&quot;,szMeshName);
-	// model file
-	std::ifstream ifs;
-	ifs.open(szMeshName, std::ios_base::in | std::ios_base::binary);
-	Ogre::DataStreamPtr stream(new Ogre::FileStreamDataStream(&amp;ifs, false));
-
-	if(ifs.is_open()){
-		//printf(&quot;create tmp mesh\n&quot;);
-		// create tmp mesh import resource
-		Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().create(&quot;l_OgreM=
eshTextureMissing_conversion&quot;, =

-			Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
-
-		//printf(&quot;import\n&quot;);
-		// import
-		meshSerializer-&gt;importMesh(stream, mesh.getPointer());
-		=

-		if(!mesh.isNull()){
-			// iterator over submeshes
-			Ogre::Mesh::SubMeshIterator it =3D mesh-&gt;getSubMeshIterator();
-			int i =3D 1;
-			while(it.hasMoreElements()){
-				Ogre::SubMesh *submesh =3D it.getNext();
-				std::string tex =3D submesh-&gt;getMaterialName();
-				//printf(&quot;material found: %s\n&quot;,tex.c_str());
-				lua_pushstring(L,tex.c_str()); lua_rawseti(L,-2,i);
-				++i;
-			}
-		}
-		=

-		// remove all stuff
-		Ogre::MeshManager::getSingleton().remove(&quot;l_OgreMeshTextureMissing_conve=
rsion&quot;);
-		=

-		ifs.close();
-	} else {
-		printf(&quot;ERROR can't open file: %s\n&quot;,szMeshName);
-	}
-
-	delete meshSerializer;
-		=

-	return 1;
-}
-
-
-/// for lua :   void OgreShadowTechnique  (string techique)
-static int l_OgreShadowTechnique	(lua_State *L) { PROFILE  // TODO : move =
to seperate file ?
-	const char *tech =3D luaL_checkstring(L,1);
-	Ogre::SceneManager *p =3D cOgreWrapper::GetSingleton().mSceneMgr;
-	=

-	if(p){
-		if(strcmp(tech,&quot;stencil_modulative&quot;) =3D=3D 0)p-&gt;setShadowTechnique(Ogre=
::<i>SHADOWTYPE_STENCIL_MODULATIVE);
</I>-		else if(strcmp(tech,&quot;stencil_additive&quot;) =3D=3D 0)p-&gt;setShadowTechnique(O=
gre::SHADOWTYPE_STENCIL_ADDITIVE);
-		else if(strcmp(tech,&quot;texture_modulative&quot;) =3D=3D 0)p-&gt;setShadowTechnique=
(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE);
-		else if(strcmp(tech,&quot;texture_additive&quot;) =3D=3D 0)p-&gt;setShadowTechnique(O=
gre::SHADOWTYPE_TEXTURE_ADDITIVE);
-		else if(strcmp(tech,&quot;texture_additive_integrated&quot;) =3D=3D 0)p-&gt;setShadow=
Technique(Ogre::SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED);
-		else if(strcmp(tech,&quot;texture_modulative_integrated&quot;) =3D=3D 0)p-&gt;setShad=
owTechnique(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED);
-		else p-&gt;setShadowTechnique(Ogre::SHADOWTYPE_NONE);
-	}
-		=

-	return 0;
-}
-
-
-/// for lua :   void OgreAmbientLight  (r,g,b) [color value 0..1 each]
-static int l_OgreAmbientLight	(lua_State *L) { PROFILE  // TODO : move to =
seperate file ?
-	float r =3D luaL_checknumber(L,1);
-	float g =3D luaL_checknumber(L,2);
-	float b =3D luaL_checknumber(L,3);
-	Ogre::SceneManager *p =3D cOgreWrapper::GetSingleton().mSceneMgr;
-	=

-	if(p){
-		p-&gt;setAmbientLight( ColourValue( r, g, b ) );
-	}
-	=

-	return 0;
-}
-
-/// for lua :   string  GetUniqueName  ()
-static int l_GetUniqueName	(lua_State *L) { PROFILE  // TODO : move to sep=
erate file ?
-	std::string n =3D cOgreWrapper::GetSingleton().GetUniqueName();
-	lua_pushstring(L,n.c_str());
-	return 1;
-}
-
-
-/// for lua :   number OgreLastFPS  ()
-static int l_OgreLastFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWr=
apper::GetSingleton().mfLastFPS);return 1; }
-/// for lua :   number OgreAvgFPS  ()
-static int l_OgreAvgFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWra=
pper::GetSingleton().mfAvgFPS);return 1; }
-/// for lua :   number OgreBestFPS  ()
-static int l_OgreBestFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWr=
apper::GetSingleton().mfBestFPS);return 1; }
-/// for lua :   number OgreWorstFPS  ()
-static int l_OgreWorstFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreW=
rapper::GetSingleton().mfWorstFPS);return 1; }
-/// for lua :   number OgreBestFrameTime  ()
-static int l_OgreBestFrameTime	(lua_State *L) { PROFILE lua_pushnumber(L,c=
OgreWrapper::GetSingleton().miBestFrameTime);return 1; }
-/// for lua :   number OgreWorstFrameTime  ()
-static int l_OgreWorstFrameTime	(lua_State *L) { PROFILE lua_pushnumber(L,=
cOgreWrapper::GetSingleton().miWorstFrameTime);return 1; }
-/// for lua :   number OgreTriangleCount  ()
-static int l_OgreTriangleCount	(lua_State *L) { PROFILE lua_pushnumber(L,c=
OgreWrapper::GetSingleton().miTriangleCount);return 1; }
-/// for lua :   number OgreBatchCount  ()
-static int l_OgreBatchCount	(lua_State *L) { PROFILE lua_pushnumber(L,cOgr=
eWrapper::GetSingleton().miBatchCount);return 1; }
-
-/*
-static int l_Client_SetMouseSensitivity (lua_State *L) { PROFILE
-	cClient* client =3D cGame::GetSingleton().mpClient;
-	if (client) client-&gt;mfMouseSensitivity =3D luaL_checknumber(L,1);
-	return 0;
-}
-
-
-
-static int l_Client_SetInvertMouse (lua_State *L) { PROFILE
-	cClient* client =3D cGame::GetSingleton().mpClient;
-	if (client) client-&gt;mbInvertMouse =3D luaL_checkint(L,1) !=3D 0;
-	return 0;
-}
-
-
-static int l_Client_SetCamera (lua_State *L) { PROFILE
-	int i=3D0;
-	Real x =3D luaL_checknumber(L,++i);
-	Real y =3D luaL_checknumber(L,++i);
-	Real z =3D luaL_checknumber(L,++i);
-	Real qw =3D luaL_checknumber(L,++i);
-	Real qx =3D luaL_checknumber(L,++i);
-	Real qy =3D luaL_checknumber(L,++i);
-	Real qz =3D luaL_checknumber(L,++i);
-	cClient* client =3D cGame::GetSingleton().mpClient;
-	if (client)
-			client-&gt;SetCamera(Vector3(x,y,z),Quaternion(qw,qx,qy,qz));
-	else	printf(&quot;l_Client_SetCamera called from lua on non-client&quot;);
-	return 0;
-}
-
-static int l_Client_ForceCamRot (lua_State *L) { PROFILE
-	int i=3D0;
-	Real qw =3D luaL_checknumber(L,++i);
-	Real qx =3D luaL_checknumber(L,++i);
-	Real qy =3D luaL_checknumber(L,++i);
-	Real qz =3D luaL_checknumber(L,++i);
-	cClient* client =3D cGame::GetSingleton().mpClient;
-	if (client)
-			client-&gt;ForceCamRot(Quaternion(qw,qx,qy,qz));
-	else	printf(&quot;l_Client_ForceCamRot called from lua on non-client&quot;);
-	return 0;
-}
-
-static int l_Client_CameraLookAt (lua_State *L) { PROFILE
-	int i=3D0;
-	Real x =3D luaL_checknumber(L,++i);
-	Real y =3D luaL_checknumber(L,++i);
-	Real z =3D luaL_checknumber(L,++i);
-	cClient* client =3D cGame::GetSingleton().mpClient;
-	if (client)
-			client-&gt;CameraLookAt(Vector3(x,y,z));
-	else	printf(&quot;l_Client_CameraLookAt called from lua on non-client&quot;);
-	return 0;
-}
-*/
-
-
-// ***** ***** utilities and error handling ***** *****
-
-
-/// also adds a traceback to the error message in case of an error
-/// nret=3D-1 for unlimited
-/// don't use directly, used by LuaCall
-int 	PCallWithErrFuncWrapper (lua_State *L,int narg, int nret) { PROFILE
-	int status;
-	int base =3D lua_gettop(L) - narg;  // function index =

-	lua_pushliteral(L, &quot;_TRACEBACK&quot;);
-	lua_rawget(L, LUA_GLOBALSINDEX); // get traceback function =

-	lua_insert(L, base);  // put it under chunk and args =

-	// signal(SIGINT, laction); // copyed from example, no idea what this is =
good for =3D(
-	status =3D lua_pcall(L, narg, (nret=3D=3D-1) ? LUA_MULTRET : nret, base);
-	=

-	//printf(&quot;pcall end, cleaning up....\n&quot;);
-	=

-	// signal(SIGINT, SIG_DFL); // copyed from example, no idea what this is =
good for =3D(
-	lua_remove(L, base);  // remove traceback function // TODO : this might c=
rash if error handler closed the lua state =

-	=

-	//printf(&quot;pcall end\n&quot;);
-	=

-	return status;
-}
-
-
-void MyCrash				(const char* szMessage);
-
-void LuaErrorHandler (lua_State *L, const char *fmt, ...) { PROFILE
-	printf(&quot;LuaErrorHandler start\n&quot;);
-	=

-	va_list argp;
-	va_start(argp, fmt);
-	gRobStringBuffer[0] =3D 0;
-	vsnprintf(gRobStringBuffer,kRobStringBufferSize-1,fmt, argp);
-	std::string s(gRobStringBuffer);
-	va_end(argp);
-	=

-	std::string mystr(&quot;LuaError\n&quot;);
-	mystr +=3D s;
-	=

-	printf(&quot;\nLuaErrorHandler end\n&quot;);
-	=

-	//lua_close(L);
-	MyCrash(mystr.c_str());
-	// todo : attempt recovery in case of protected function call ?
-	// todo : deinit ogre to free mouse here
-}
-
-
-struct luaL_reg make_luaL_reg(const char *name,lua_CFunction func){
-  struct luaL_reg s;
-  s.name =3D name;
-  s.func =3D func;
-  return s;
-}
-
-void	cScripting::Listener_Notify (cListenable* pTarget,const size_t eventc=
ode,const size_t param,const size_t userdata) { PROFILE
-	switch (userdata) {
-		case kListenerBinding_Keys:
-			switch (eventcode) {
-				case cInput::kListenerEvent_KeyPress:
-					LuaCall(&quot;KeyDown&quot;,&quot;ii&quot;,(int)(param &amp; 255),(int)((param &gt;&gt; 8) &amp; 255));
-					//printf(&quot;keydown(%d)\n&quot;,param);
-				break;
-				case cInput::kListenerEvent_KeyRelease:
-					LuaCall(&quot;KeyUp&quot;,&quot;i&quot;,(int)param);
-					//printf(&quot;keyup(%d)\n&quot;,param);
-				break;
-			}
-			//printf(&quot;event=3D%d,key=3D%d\n&quot;,eventcode,param);
-		break;
-		// TODO : maybe timer ?
-	}
-}
-
-int		cScripting::GetGlobal	(const char* name) { PROFILE
-	lua_getglobal(L,name);
-	if (!lua_isnumber(L,-1)) { lua_pop(L,1); return 0; }
-	return (int)lua_tonumber(L,-1);
-}
-
-void	cScripting::SetGlobal	(const char* name,int value) { PROFILE
-	lua_pushnumber(L,value);
-	lua_setglobal(L,name);
-}
-
-/// this is the call_va function from the Book &quot;Programming in Lua&quot; with a=
ltered type notation :
-/// float : f
-/// int : i
-/// const char* : s
-/// returns true on successful call
-/// warning ! maybe this cannot return more than one string ! todo : check=
 doc of lua_tostring
-bool cScripting::LuaCall (const char *func, const char *sig, ...) { PROFILE
-	#ifdef PROFILE_LUACALLCOUNT
-	++gPROFILE_LUACALLCOUNT[func];
-	#endif
-
-	bool result =3D true;
-	va_list vl;
-	int narg, nres;  /* number of arguments and results */
-
-	va_start(vl, sig);
-	lua_getglobal(L, func);  /* get function */
-
-	/* push arguments */
-	narg =3D 0;
-	while (*sig) {  /* push arguments */
-		bool endwhile =3D false;
-		switch (*sig++) {
-		  case 'f':  /* float/double argument */
-			lua_pushnumber(L, va_arg(vl, double));
-			break;
-
-		  case 'i':  /* int argument (ansi printf : also use %d) */
-			lua_pushnumber(L, va_arg(vl, int));
-			break;
-
-		  case 's':  /* string argument */
-			lua_pushstring(L, va_arg(vl, char *));
-			break;
-
-		  case '&gt;':
-			endwhile =3D true;
-			break;
-		  default:
-			LuaErrorHandler(L, &quot;invalid option (%c)&quot;, *(sig - 1));
-			lua_pushnil(L);
-			break;
-		}
-		if (endwhile) break;
-		narg++;
-		luaL_checkstack(L, 1, &quot;too many arguments&quot;);
-	}
-
-	/* do the call */
-	nres =3D strlen(sig);  /* number of expected results */
-	// todo : push lua error handler function here ?!?
-	if (PCallWithErrFuncWrapper(L,narg, nres) !=3D 0) {
-	//if (lua_pcall(L, narg, nres, 0) !=3D 0)  { // old
-		/* do the call */
-		LuaErrorHandler(L, &quot;error running function `%s': %s&quot;,func, lua_tostring(=
L, -1));
-		=

-		/*
-		doku for lua_pcall last argument (errorfunc)
-		if 0 ... else that argument should be the index in the stack where the e=
rror handler function is located. Notice that, in such cases, the handler m=
ust be pushed in the stack before the function to be called and its argumen=
ts.
-		*/
-		result =3D false;
-	} else {
-		/* retrieve results */
-		int popamount =3D nres;
-		nres =3D -nres;  /* stack index of first result */
-		while (*sig) {  /* get results */
-			switch (*sig++) {
-
-			  case 'f':  /* float / double result */
-				if (!lua_isnumber(L, nres)) {
-					LuaErrorHandler(L, &quot;wrong result type&quot;);
-					*va_arg(vl, double *) =3D 0;
-				} else {
-					*va_arg(vl, double *) =3D lua_tonumber(L, nres);
-				}
-				break;
-
-			  case 'i':  /* int result */
-				if (!lua_isnumber(L, nres)) {
-					LuaErrorHandler(L, &quot;wrong result type&quot;);
-					*va_arg(vl, int *) =3D 0;
-				} else {
-					*va_arg(vl, int *) =3D (int)lua_tonumber(L, nres);
-				}
-				break;
-
-			  case 's':  /* string result */
-				if (!lua_isstring(L, nres)) {
-					LuaErrorHandler(L, &quot;wrong result type&quot;);
-					*va_arg(vl,std::string*) =3D &quot;&quot;;
-				} else {
-					*va_arg(vl,std::string*) =3D lua_tostring(L, nres); // return as std:=
:<i>string, as pure lua pointer becomes invalid with pop
</I>-				}
-				break;
-
-			  default:
-				LuaErrorHandler(L, &quot;invalid option (%c)&quot;, *(sig - 1));
-				break;
-			}
-			nres++;
-		}
-		// pop stack    =

-		lua_pop(L, popamount);
-	}
-	va_end(vl);
-	return result;
-}
-
-
-cScripting::cScripting	() : L(0) {}
-
-void	cScripting::Init () { PROFILE
-	if (sizeof(lua_Number) &lt;=3D 4) {
-		printf(&quot;sizeof(lua_Number) =3D %d, but must be greater than 4 (32 bit) f=
or bitwise ops\n&quot;,sizeof(lua_Number));
-		DisplayErrorMessage(&quot;ERROR : lua-precision wrong&quot;);
-		exit(43);
-	}
-	=

-	L =3D lua_open();
-	assert(L);
-	luaopen_base(L);
-	luaopen_table(L);
-	luaopen_io(L);
-	luaopen_string(L);
-	luaopen_math(L);
-	luaopen_debug(L);
-	=

-	lua_register(L,&quot;GetNamedKey&quot;,		l_GetNamedKey);
-	lua_register(L,&quot;GetKeyName&quot;,		l_GetKeyName);
-	lua_register(L,&quot;PollInput&quot;,			l_PollInput);
-	lua_register(L,&quot;Terminate&quot;,			l_Terminate);
-	lua_register(L,&quot;InitOgre&quot;,			l_InitOgre);
-	lua_register(L,&quot;GetPointerSize&quot;,	l_GetPointerSize);
-	lua_register(L,&quot;Client_IsAlive&quot;,	l_Client_IsAlive);
-	//lua_register(L,&quot;ServerSendMsgToClient&quot;,			l_ServerSendMsgToClient);
-	//lua_register(L,&quot;ClientSendMsgToServer&quot;,			l_ClientSendMsgToServer);
-	//lua_register(L,&quot;SoundPlayAmbient&quot;,				l_SoundPlayAmbient);
-	//lua_register(L,&quot;Server_SetMaxResyncsPerSecond&quot;,	l_Server_SetMaxResyncsP=
erSecond);
-	//lua_register(L,&quot;Server_GetMaxResyncsPerSecond&quot;,	l_Server_GetMaxResyncsP=
erSecond);
-	lua_register(L,&quot;Client_ShowOgreConfig&quot;,			l_Client_ShowOgreConfig);
-	lua_register(L,&quot;Client_TakeScreenshot&quot;,			l_Client_TakeScreenshot);
-	lua_register(L,&quot;Client_TakeGridScreenshot&quot;,			l_Client_TakeGridScreenshot=
);
-	//lua_register(L,&quot;Client_SetCamera&quot;,				l_Client_SetCamera);
-	//lua_register(L,&quot;Client_ForceCamRot&quot;,			l_Client_ForceCamRot);
-	//lua_register(L,&quot;Client_CameraLookAt&quot;,			l_Client_CameraLookAt);
-	//lua_register(L,&quot;Client_SetPlayerShip&quot;,			l_Client_SetPlayerShip);
-	//lua_register(L,&quot;Client_SetMaxFPS&quot;,				l_Client_SetMaxFPS);
-	//lua_register(L,&quot;Client_GetMaxFPS&quot;,				l_Client_GetMaxFPS);
-	lua_register(L,&quot;Client_GetCurFPS&quot;,				l_Client_GetCurFPS);
-	lua_register(L,&quot;Client_GetFrameNum&quot;,			l_Client_GetFrameNum);
-	//lua_register(L,&quot;Client_SetMouseSensitivity&quot;,	l_Client_SetMouseSensitivi=
ty);
-	//lua_register(L,&quot;Client_SetInvertMouse&quot;,			l_Client_SetInvertMouse);
-	//lua_register(L,&quot;Client_ShowMessage&quot;,			l_Client_ShowMessage);
-	lua_register(L,&quot;Client_GetTicks&quot;,				l_Client_GetTicks);
-	lua_register(L,&quot;Client_SetSkybox&quot;,				l_Client_SetSkybox);
-	lua_register(L,&quot;Client_SetFog&quot;,					l_Client_SetFog);
-	lua_register(L,&quot;Client_RenderOneFrame&quot;,			l_Client_RenderOneFrame);
-	lua_register(L,&quot;Client_Sleep&quot;,					l_Client_Sleep);
-	lua_register(L,&quot;Client_USleep&quot;,					l_Client_USleep);
-	lua_register(L,&quot;Client_SetAmbientLight&quot;,		l_Client_SetAmbientLight);
-	lua_register(L,&quot;Client_ClearLights&quot;,			l_Client_ClearLights);
-	lua_register(L,&quot;Client_AddPointLight&quot;,			l_Client_AddPointLight);
-	lua_register(L,&quot;Client_AddDirectionalLight&quot;,	l_Client_AddDirectionalLight=
);
-	lua_register(L,&quot;Client_GetPhysStepTime&quot;,		l_Client_GetPhysStepTime);
-	lua_register(L,&quot;BuildTerrainEntity_Simple&quot;,		l_BuildTerrainEntity_Simple);
-	lua_register(L,&quot;BuildTerrainEntity_Shaded&quot;,		l_BuildTerrainEntity_Shaded);
-	lua_register(L,&quot;TerrainRayPick&quot;,				l_TerrainRayPick);
-	lua_register(L,&quot;SphereRayPick&quot;,					l_SphereRayPick);
-	lua_register(L,&quot;UnloadMeshName&quot;,				l_UnloadMeshName);
-	lua_register(L,&quot;CountMeshTriangles&quot;,			l_CountMeshTriangles);
-	lua_register(L,&quot;GetUOPath&quot;,						l_getUOPath);
-	lua_register(L,&quot;PathSearch&quot;,					l_PathSearch);
-	lua_register(L,&quot;file_exists&quot;,					l_file_exists);
-	lua_register(L,&quot;file_size&quot;,						l_file_size);
-	lua_register(L,&quot;Hex2Num&quot;,						l_Hex2Num);
-	lua_register(L,&quot;GetRandomHexString&quot;,			l_GetRandomHexString);
-	lua_register(L,&quot;BitwiseAND&quot;,					l_BitwiseAND);
-	lua_register(L,&quot;BitwiseOR&quot;,						l_BitwiseOR);
-	lua_register(L,&quot;BitwiseXOR&quot;,					l_BitwiseXOR);
-	lua_register(L,&quot;BitwiseSHL&quot;,					l_BitwiseSHL);
-	lua_register(L,&quot;BitwiseSHR&quot;,					l_BitwiseSHR);
-	lua_register(L,&quot;TestBit&quot;,						l_TestBit);
-	lua_register(L,&quot;SetBit&quot;,						l_SetBit);
-	lua_register(L,&quot;ClearBit&quot;,						l_ClearBit);
-	lua_register(L,&quot;Exit&quot;,							l_Exit);
-	lua_register(L,&quot;Crash&quot;,							l_Crash);
-	lua_register(L,&quot;CrashSegFault&quot;,					l_CrashSegFault);
-	lua_register(L,&quot;DisplayNotice&quot;,					l_DisplayNotice);
-	lua_register(L,&quot;FatalErrorMessage&quot;,				l_FatalErrorMessage);
-	lua_register(L,&quot;ExportMesh&quot;,					l_ExportMesh);
-	lua_register(L,&quot;CreateSceneManager&quot;,			l_CreateSceneManager);
-	lua_register(L,&quot;GetUniqueName&quot;,					l_GetUniqueName);
-	lua_register(L,&quot;GetMouseRay&quot;,					l_GetMouseRay);
-	lua_register(L,&quot;GetMaxZ&quot;,						l_GetMaxZ);
-	lua_register(L,&quot;ProjectPos&quot;,					l_ProjectPos);
-	lua_register(L,&quot;ProjectSizeAndPos&quot;,				l_ProjectSizeAndPos);
-	lua_register(L,&quot;_TRACEBACK&quot;,					l_TRACEBACK);
-	lua_register(L,&quot;ProfileDumpCallCount&quot;,			l_ProfileDumpCallCount);
-	lua_register(L,&quot;OgreMemoryUsage&quot;,				l_OgreMemoryUsage);
-	lua_register(L,&quot;OgreMeshAvailable&quot;,				l_OgreMeshAvailable);
-	lua_register(L,&quot;OgreMaterialNameKnown&quot;,			l_OgreMaterialNameKnown);
-	lua_register(L,&quot;OgreMaterialAvailable&quot;,			l_OgreMaterialAvailable);
-	lua_register(L,&quot;OgreTextureAvailable&quot;,			l_OgreTextureAvailable);
-	lua_register(L,&quot;OgreMeshTextures&quot;,				l_OgreMeshTextures);
-	// some statistic stuff
-	lua_register(L,&quot;OgreLastFPS&quot;,				l_OgreLastFPS);
-	lua_register(L,&quot;OgreAvgFPS&quot;,				l_OgreAvgFPS);
-	lua_register(L,&quot;OgreBestFPS&quot;,				l_OgreBestFPS);
-	lua_register(L,&quot;OgreWorstFPS&quot;,				l_OgreWorstFPS);
-	lua_register(L,&quot;OgreBestFrameTime&quot;,			l_OgreBestFrameTime);
-	lua_register(L,&quot;OgreWorstFrameTime&quot;,			l_OgreWorstFrameTime);
-	lua_register(L,&quot;OgreTriangleCount&quot;,			l_OgreTriangleCount);
-	lua_register(L,&quot;OgreBatchCount&quot;,			l_OgreBatchCount);
-
-	lua_register(L,&quot;CreateGrannyHuedTexture&quot;,		l_CreateGrannyHuedTexture);
-	lua_register(L,&quot;HueMesh&quot;,						l_HueMesh);
-	lua_register(L,&quot;OgreAddCompositor&quot;,						l_OgreAddCompositor);
-	lua_register(L,&quot;OgreRemoveCompositor&quot;,						l_OgreRemoveCompositor);
-	lua_register(L,&quot;CreateLookupTableFromFile&quot;,			l_CreateLookupTableFromFile=
);
-	lua_register(L,&quot;Uo16Color2Rgb&quot;,			l_Uo16Color2Rgb);
-	// shadow stuff
-	lua_register(L,&quot;OgreShadowTechnique&quot;,				l_OgreShadowTechnique);
-	lua_register(L,&quot;OgreAmbientLight&quot;,				l_OgreAmbientLight);
-
-	// file paths for init
-	const char* szLuaUDataPath =3D &quot;../data/lua/udata.lua&quot;;
-	const char* szLuaMainPath =3D &quot;../data/lua/main.lua&quot;;
-
-
-	// check if lua files exist (otherwise working directory probably wrong)
-	std::ifstream myFileStream(szLuaMainPath);
-	if (!myFileStream) {
-		MyCrash(strprintf(&quot;%s cannot be found, probably the working directory is=
 wrong&quot;,szLuaMainPath).c_str());
-		exit(34);
-	}
-	myFileStream.close();
-	=

-	// load utils
-	int res;
-	res	=3D lua_dofile(L,szLuaUDataPath); // loads function used for register=
ing udatatypes
-	if (res) { =

-		MyCrash(&quot;error in udata script-initialisation\n&quot;); =

-		exit(44); =

-	}
-
-	RegisterLuaXML(L);
-	LuaRegisterFIFO(L);
-	LuaRegisterNet(L);
-	cGfx3D::LuaRegister(L);
-	cGfx2D::LuaRegister(L);
-	cDialog::LuaRegister(L);
-	cWidget::LuaRegister(L);
-	cBitMask::LuaRegister(L);
-	cCamera::LuaRegister(L);
-	cViewport::LuaRegister(L);
-	cRenderTexture::LuaRegister(L);
-	cSoundSource::LuaRegister(L);
-	cSpriteManager::LuaRegister(L);
-	cManualArtMaterialLoader::LuaRegister(L);
-	cSprite::LuaRegister(L);
-	Material_LuaRegister(L);
-	Granny_LuaRegister(L);
-	LuaRegisterData(L);
-	LuaRegisterBuilder(L);
-	LuaRegisterRadar(L);
-
-	cInput::GetSingleton().RegisterListener(this,kListenerBinding_Keys);
-
-	res =3D lua_dofile(L,szLuaMainPath);
-	if (res) {
-		MyCrash(&quot;error in main script-initialisation\n&quot;); =

-		exit(-1); =

-	}
-}
-
-cScripting::~cScripting	() { PROFILE
-	cInput::GetSingleton().UnRegisterListener(this,kListenerBinding_Keys);
-
-	assert(L);
-	lua_setgcthreshold(L, 0);  // collected garbage
-	lua_close(L);
-	L =3D 0;
-}
+#include &quot;prefix.h&quot;
+#include &lt;assert.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &quot;net.h&quot;
+#include &quot;fifo.h&quot;
+#include &quot;game.h&quot;
+#include &quot;listener.h&quot;
+#include &quot;scripting.h&quot;
+#include &quot;input.h&quot;
+#include &quot;robstring1.2.h&quot;
+#include &quot;gfx3D.h&quot;
+#include &quot;gfx2D.h&quot;
+#include &quot;widget.h&quot;
+#include &quot;luabind.h&quot;
+#include &quot;data.h&quot;
+#include &quot;builder.h&quot;
+#include &quot;shell.h&quot;
+#include &quot;timer.h&quot;
+#include &quot;ogrewrapper.h&quot;
+#include &quot;pathsearch.h&quot;
+#include &quot;bitmask.h&quot;
+#include &quot;camera.h&quot;
+#include &quot;viewport.h&quot;
+#include &quot;rendertexture.h&quot;
+#include &quot;sound.h&quot;
+#include &quot;terrain.h&quot;
+#include &quot;radar.h&quot;
+#include &lt;Ogre.h&gt;
+#include &lt;OgreResourceManager.h&gt;
+#include &lt;OgreFontManager.h&gt;
+#include &lt;OgreTextAreaOverlayElement.h&gt;
+#include &lt;OgreMeshSerializer.h&gt;
+#include &lt;OgreCompositorManager.h&gt;
+#include &quot;luaxml.h&quot;
+#include &quot;spritemanager.h&quot;
+#include &quot;ogremanualloader.h&quot;
+
+//#define PROFILE_LUACALLCOUNT
+#ifdef PROFILE_LUACALLCOUNT
+std::map&lt;const char*,int&gt; gPROFILE_LUACALLCOUNT;
+struct cPROFILE_LUACALLCOUNTSetCmp {
+  inline bool operator() (const std::pair&lt;const char*,int&gt;&amp; x,const  std::=
pair&lt;const char*,int&gt;&amp; y) const { =

+	return x.second &gt; y.second; =

+  }
+};
+#endif
+
+#ifdef WIN32
+#include &lt;windows.h&gt;
+#else
+#include &lt;unistd.h&gt;
+#endif
+
+extern &quot;C&quot; {
+	#include &quot;lua.h&quot;
+	#include &quot;lauxlib.h&quot;
+	#include &quot;lualib.h&quot;
+}
+
+void	DisplayNotice			(const char* szMsg); ///&lt; defined in main.cpp, OS-spe=
cific
+void	DisplayErrorMessage		(const char* szMsg); ///&lt; defined in main.cpp, O=
S-specific
+void	Material_LuaRegister	(void *L);
+void	Granny_LuaRegister		(void *L);
+void	PrintLuaStackTrace		();
+void	ProfileDumpCallCount	(); ///&lt; defined in profile.cpp, only does somet=
hing if PROFILE_CALLCOUNT is enabled
+
+void	PrintLuaStackTrace		() { PROFILE
+	printf(&quot;PrintLuaStackTrace:\n&quot;);
+	// see l_TRACEBACK() : leaves a string containing the stacktrace at the t=
op of the stack
+	std::string sMyStackTrace;
+	cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;_TRACEBACK&quot;,&quot;&gt;s&quot;,&amp;sMyStackTrace);
+	printf(&quot;%s\n&quot;,sMyStackTrace.c_str());
+}
+
+void	PrintLuaStackTrace		(const char *filename) { PROFILE
+	FILE *f =3D fopen(filename,&quot;a&quot;);
+	if(f){
+		fprintf(f,&quot;PrintLuaStackTrace:\n&quot;);
+		// see l_TRACEBACK() : leaves a string containing the stacktrace at the =
top of the stack
+		std::string sMyStackTrace;
+		cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;_TRACEBACK&quot;,&quot;&gt;s&quot;,&amp;sMyStackTrace);
+		fprintf(f,&quot;%s\n&quot;,sMyStackTrace.c_str());
+		=

+		fclose(f);
+	}
+}
+
+void	printdebug	(const char *szCategory, const char *szFormat, ...) { PROF=
ILE
+	va_list ap;
+	va_start(ap,szFormat);
+	gRobStringBuffer[0] =3D 0;
+	vsnprintf(gRobStringBuffer,kRobStringBufferSize-1,szFormat,ap);
+	cScripting::GetSingletonPtr()-&gt;LuaCall(&quot;printdebug&quot;,&quot;ss&quot;,szCategory,gRobS=
tringBuffer);
+	va_end(ap);
+}
+
+// ***** ***** global functionals exported to lua ***** *****
+
+
+cScripting*	cScripting::GetSingletonPtr	(cScripting* p) {
+	static cScripting* pSingleton =3D 0;
+	if (p) pSingleton =3D p;
+	return pSingleton;
+}
+
+
+/// called from lua : string keyname
+static int l_GetNamedKey (lua_State *L) { PROFILE
+	const char *keyname =3D luaL_checkstring(L, 1);
+	lua_pushnumber(L,cInput::GetSingleton().GetNamedKey(keyname));  // push r=
esult =

+	return 1;  // number of results =

+}
+
+/// called from lua : int keycode
+static int l_GetKeyName (lua_State *L) { PROFILE
+	int keycode =3D luaL_checkint(L, 1);
+	lua_pushstring(L,cInput::GetSingleton().GetKeyName(keycode));  // push re=
sult =

+	return 1;  // number of results =

+}
+
+/// terminates the application
+static int l_Terminate (lua_State *L) { PROFILE
+	cShell::mbAlive =3D false;
+	return 0;
+}
+
+/// only call this once at startup
+static int l_InitOgre (lua_State *L) { PROFILE
+	lua_pushboolean(L,cOgreWrapper::GetSingleton().Init());
+	return 1;
+}
+
+static int l_GetPointerSize (lua_State *L) { PROFILE
+	lua_pushnumber(L,sizeof(void*));
+	return 1;
+}
+
+/// only call this once at startup
+static int l_Client_IsAlive (lua_State *L) { PROFILE
+	lua_pushboolean(L,cShell::mbAlive);
+	return 1;
+}
+	=

+/// called from lua : no params, returns mousex,mousey,4xmousewheel info...
+static int l_PollInput (lua_State *L) { PROFILE
+	lua_pushnumber(L,cInput::iMouse[0]);
+	lua_pushnumber(L,cInput::iMouse[1]);
+	lua_pushnumber(L,cInput::iMouseWheel);
+	lua_pushnumber(L,cInput::iMouseWheel_pressed);
+	lua_pushnumber(L,cInput::iMouseWheel_all_since_last_step);
+	lua_pushnumber(L,cInput::iMouseWheel_pressed_since_last_step);
+	return 6;
+}
+
+
+static int l_ProfileDumpCallCount (lua_State *L) { PROFILE
+	ProfileDumpCallCount();
+	=

+	#ifdef PROFILE_LUACALLCOUNT
+	printf(&quot;LuaCallCounts:\n\n&quot;);
+	=

+	std::multiset&lt;std::pair&lt;const char*,int&gt;,cPROFILE_LUACALLCOUNTSetCmp&gt; myC=
allCountProfileSet;
+	typedef std::multiset&lt;std::pair&lt;const char*,int&gt;,cPROFILE_LUACALLCOUNTSet=
Cmp&gt;::iterator tLuaCallCountProfileSetItor;
+	{ for (std::map&lt;const char*,int&gt;::iterator itor=3DgPROFILE_LUACALLCOUNT.b=
egin();itor !=3D gPROFILE_LUACALLCOUNT.end();++itor)
+		myCallCountProfileSet.insert(std::make_pair((*itor).first,(*itor).second=
)); =

+	}
+	int i=3D0;
+	for (tLuaCallCountProfileSetItor itor=3DmyCallCountProfileSet.begin();ito=
r !=3D myCallCountProfileSet.end();++itor) {
+		//if (++i &gt; 10) break;
+		printf(&quot;LuaCallCallCount %16d %s\n&quot;,(*itor).second,(*itor).first);
+	}
+	#endif
+
+	return 0;
+}
+
+/// used as errfunc for lua_pcall, adds a callstack/backtrace/list_of_call=
ed_functions to the errormessage
+/// code from errorfb from /usr/src/lua-5.0.2/src/lua/ldblib.c
+/// &quot;_TRACEBACK&quot; is defined as errorfb
+/// leaves a string containing the stacktrace at the top of the stack
+#define LEVELS1	12	/* size of the first part of the stack */
+#define LEVELS2	10	/* size of the second part of the stack */
+static int l_TRACEBACK (lua_State *L) { PROFILE
+  int level =3D 1;  /* skip level 0 (it's this function) */
+  int firstpart =3D 1;  /* still before eventual `...' */
+  lua_Debug ar;
+  if (lua_gettop(L) =3D=3D 0)
+	lua_pushliteral(L, &quot;&quot;);
+  else if (!lua_isstring(L, 1)) return 1;  /* no string message */
+  else lua_pushliteral(L, &quot;\n&quot;);
+  lua_pushliteral(L, &quot;LuaStackTrace:\n&quot;);
+  while (lua_getstack(L, level++, &amp;ar)) {
+	if (level &gt; LEVELS1 &amp;&amp; firstpart) {
+	  /* no more than `LEVELS2' more levels? */
+	  if (!lua_getstack(L, level+LEVELS2, &amp;ar))
+		level--;  /* keep going */
+	  else {
+		lua_pushliteral(L, &quot;\n\t...&quot;);  /* too many levels */
+		while (lua_getstack(L, level+LEVELS2, &amp;ar))  /* find last levels */
+		  level++;
+	  }
+	  firstpart =3D 0;
+	  continue;
+	}
+	lua_pushliteral(L, &quot;\n\t&quot;);
+	lua_getinfo(L, &quot;Snl&quot;, &amp;ar);
+	lua_pushfstring(L, &quot;%s:&quot;, ar.short_src);
+	if (ar.currentline &gt; 0)
+	  lua_pushfstring(L, &quot;%d:&quot;, ar.currentline);
+	switch (*ar.namewhat) {
+	  case 'g':  /* global */ =

+	  case 'l':  /* local */
+	  case 'f':  /* field */
+	  case 'm':  /* method */
+		lua_pushfstring(L, &quot; in function `%s'&quot;, ar.name);
+		break;
+	  default: {
+		if (*ar.what =3D=3D 'm')  /* main? */
+		  lua_pushfstring(L, &quot; in main chunk&quot;);
+		else if (*ar.what =3D=3D 'C' || *ar.what =3D=3D 't')
+		  lua_pushliteral(L, &quot; ?&quot;);  /* C function or tail call */
+		else
+		  lua_pushfstring(L, &quot; in function &lt;%s:%d&gt;&quot;,
+							 ar.short_src, ar.linedefined);
+	  }
+	}
+	lua_concat(L, lua_gettop(L));
+  }
+  lua_concat(L, lua_gettop(L));
+  return 1;
+}
+
+
+
+static int l_Client_GetCurFPS (lua_State *L) { PROFILE
+	lua_pushnumber(L, (cTimer::miTimeSinceLastFrame &gt; 0) ? (float(1000.0) / f=
loat(cTimer::miTimeSinceLastFrame)) : 0.0 );
+	return 1;
+}
+
+static int l_Client_GetFrameNum (lua_State *L) { PROFILE
+	lua_pushnumber(L, cTimer::miCurFrameNum );
+	return 1;
+}
+
+static int l_Client_GetTicks (lua_State *L) { PROFILE
+	lua_pushnumber(L, cShell::GetTicks());
+	return 1;
+}
+
+
+/// void OgreAddCompositor(compositor script name)
+static int l_OgreAddCompositor (lua_State *L) { PROFILE
+	const char *name =3D luaL_checkstring(L,1);
+	Ogre::CompositorManager::getSingleton().addCompositor(cOgreWrapper::GetSi=
ngleton().mViewport, name);
+//	Ogre::CompositorManager::getSingleton().setCompositorEnabled(cOgreWrapp=
er::GetSingleton().mViewport, name, true);
+	return 0;
+}
+
+/// void OgreRemoveCompositor(compositor script name)
+static int l_OgreRemoveCompositor (lua_State *L) { PROFILE
+	const char *name =3D luaL_checkstring(L,1);
+//	Ogre::CompositorManager::getSingleton().setCompositorEnabled(cOgreWrapp=
er::GetSingleton().mViewport, name, false);
+	Ogre::CompositorManager::getSingleton().removeCompositor(cOgreWrapper::Ge=
tSingleton().mViewport, name);
+	return 0;
+}
+
+/// int =3D OgreMemoryUsage(part)
+/// part in {compositor,font,gpuprogram,highlevelgpuprogram,material,mesh,=
skeleton,texture,all}
+/// returns memory usage in byte
+static int l_OgreMemoryUsage (lua_State *L) { PROFILE
+	std::string part(luaL_checkstring(L,1));
+	size_t mem =3D 0;
+	=

+#ifdef OGRE_VERSION_SUFFIX
+	if(part.find(&quot;compositor&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=
=3D std::string::npos)mem +=3D Ogre::CompositorManager::getSingleton().getM=
emoryUsage();
+	if(part.find(&quot;font&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D std:=
:<i>string::npos)mem +=3D Ogre::FontManager::getSingleton().getMemoryUsage();
</I>+	if(part.find(&quot;gpuprogram&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=
=3D std::string::npos)mem +=3D Ogre::GpuProgramManager::getSingleton().getM=
emoryUsage();
+	if(part.find(&quot;highlevelgpuprogram&quot;) !=3D std::string::npos || part.find(&quot;=
all&quot;) !=3D std::string::npos)mem +=3D Ogre::HighLevelGpuProgramManager::get=
Singleton().getMemoryUsage();
+	if(part.find(&quot;material&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D =
std::string::npos)mem +=3D Ogre::MaterialManager::getSingleton().getMemoryU=
sage();
+	if(part.find(&quot;mesh&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D std:=
:<i>string::npos)mem +=3D Ogre::MeshManager::getSingleton().getMemoryUsage();
</I>+	if(part.find(&quot;skeleton&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D =
std::string::npos)mem +=3D Ogre::SkeletonManager::getSingleton().getMemoryU=
sage();
+	if(part.find(&quot;texture&quot;) !=3D std::string::npos || part.find(&quot;all&quot;) !=3D s=
td::string::npos)mem +=3D Ogre::TextureManager::getSingleton().getMemoryUsa=
ge();
+#endif
+	=

+	lua_pushnumber(L, mem);
+	return 1;
+}
+
+/// bool =3D OgreMeshAvailable(ressourcename)
+static int l_OgreMeshAvailable (lua_State *L) { PROFILE
+	const char *name =3D luaL_checkstring(L,1);
+	bool ret;
+	=

+	try {
+		Ogre::MeshManager::getSingleton().load(name,Ogre::ResourceGroupManager::=
DEFAULT_RESOURCE_GROUP_NAME);
+		ret =3D true;
+	} catch (...) {
+			ret =3D false;
+	}
+	=

+	lua_pushboolean(L, ret);
+	return 1;
+}
+
+/// see also OgreMaterialAvailable below
+/// bool =3D OgreMaterialNameKnown(ressourcename)
+/// returns false if name is empty string or nil
+static int l_OgreMaterialNameKnown (lua_State *L) { PROFILE =

+	std::string sMatName =3D (lua_gettop(L) &gt;=3D 1 &amp;&amp; !lua_isnil(L,1)) ? luaL=
_checkstring(L,1) : &quot;&quot;;
+	if (sMatName.size() &gt; 0) { =

+		Ogre::MaterialPtr pMaterial =3D Ogre::MaterialManager::getSingleton().ge=
tByName(sMatName.c_str());
+		lua_pushboolean(L,!pMaterial.isNull());
+	} else {
+		lua_pushboolean(L,false);
+	}
+	return 1;
+}
+
+/// bool =3D OgreMaterialAvailable(ressourcename)
+static int l_OgreMaterialAvailable (lua_State *L) { PROFILE
+	assert(0 &amp;&amp; &quot;DON'T USE ME, ALWAYS RETURNS TRUE&quot;); =

+	// TODO, this code does not work, use l_OgreMaterialNameKnown  above
+	const char *name =3D luaL_checkstring(L,1);
+	bool ret;
+	=

+	try {
+		Ogre::MaterialManager::getSingleton().load(name,Ogre::ResourceGroupManag=
er::DEFAULT_RESOURCE_GROUP_NAME);
+		ret =3D true;
+	} catch (...) {
+			ret =3D false;
+	}
+	=

+	lua_pushboolean(L, ret);
+	return 1;
+}
+
+/// bool =3D OgreTextureAvailable(ressourcename)
+static int l_OgreTextureAvailable (lua_State *L) { PROFILE
+	const char *name =3D luaL_checkstring(L,1);
+	bool ret;
+	=

+	try {
+		Ogre::TextureManager::getSingleton().load(name,Ogre::ResourceGroupManage=
r::DEFAULT_RESOURCE_GROUP_NAME);
+		ret =3D true;
+	} catch (...) {
+			ret =3D false;
+	}
+	=

+	lua_pushboolean(L, ret);
+	return 1;
+}
+
+/// r,g,b =3D Uo16Color2Rgb(color)
+static int l_Uo16Color2Rgb (lua_State *L) { PROFILE
+	unsigned short color =3D luaL_checkint(L,1);
+	=

+	float r =3D float((color &gt;&gt; 10) &amp; 0x1F)/float(0x1f);
+	float g =3D float((color &gt;&gt;  5) &amp; 0x1F)/float(0x1f);
+	float b =3D float((color &gt;&gt;  0) &amp; 0x1F)/float(0x1f);
+				=

+	lua_pushnumber(L, r);
+	lua_pushnumber(L, g);
+	lua_pushnumber(L, b);
+	return 3;
+}
+
+/// CreateGrannyHuedTexture(GrannyTextureHook(texturepath),GrannyTextureHo=
ok(texturepath),gHueLoader,hue)
+static int l_CreateGrannyHuedTexture (lua_State *L) { PROFILE
+	std::string sTexturePath	=3D luaL_checkstring(L,1);
+	std::string sMaskPath		=3D luaL_checkstring(L,2);
+	cHueLoader *hueLoader 		=3D cLuaBind&lt;cHueLoader&gt;::checkudata(L,3);
+	int iHue					=3D luaL_checkint(L,4);
+	=

+	if (iHue =3D=3D 0 || !hueLoader) {
+		lua_pushstring(L,sTexturePath.c_str());
+		return 1;
+	}
+	=

+	// load image
+	Ogre::Image myImage;
+	myImage.load(sTexturePath,Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GR=
OUP_NAME);
+	=

+	// get image infos
+	Ogre::PixelFormat myFormat =3D myImage.getFormat();
+	unsigned int size =3D myImage.getSize();
+	unsigned int w =3D myImage.getWidth();
+	unsigned int h =3D myImage.getHeight();
+	unsigned int rowspan =3D myImage.getRowSpan();
+	unsigned int pixelsize =3D Ogre::PixelUtil::getNumElemBytes(myFormat);
+	//Ogre::uchar* dst =3D new Ogre::uchar[size];
+	Ogre::uchar* src =3D myImage.getData();
+	//Ogre::uchar* dst_start =3D dst;
+	Ogre::uchar* src_start =3D src;
+	uint8 cr,cg,cb,ca1,ca2;
+	short col;
+	=

+	// debug info
+	//printf(&quot;image size=3D%d w=3D%d h=3D%d d=3D%d f=3D%d bpp=3D%d rowspan=3D=
%d bIsNonZero2=3D%d\n&quot;,size,w,h,
+	//	myImage.getDepth(),myImage.getNumFaces(),myImage.getBPP(),rowspan,bIsN=
onZero2?1:0);
+	=

+	// hue filter
+	cHueFilter Filter;
+	short* ColorTable =3D hueLoader-&gt;GetHue( iHue-1 )-&gt;GetColors();
+	=

+	// colorize the pixels
+	for(unsigned int y =3D 0; y &lt; h; y++){
+		for(unsigned int x =3D 0; x &lt; w; x++) {
+			// read out pixel in src graphic
+			Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca1,myFormat,src);
+			Ogre::PixelUtil::packColour(cr,cg,cb,ca1,Ogre::PF_A1R5G5B5,&amp;col);
+			// and hue the pixel
+			col =3D Filter( col, ColorTable );
+			// TODO ! respect mask instead of hueing the complete texture
+			// and store it in destination (ignoring the new alpha)
+			Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca2,Ogre::PF_A1R5G5B5,&amp;col);
+			Ogre::PixelUtil::packColour(cr,cg,cb,ca1,myFormat,src);
+			src +=3D pixelsize;
+			//dst +=3D pixelsize;
+		}
+		src +=3D rowspan - w*pixelsize;
+	}
+	=

+	// and make a texture
+	std::string newtextname =3D cOgreWrapper::GetSingleton().GetUniqueName();
+	//Ogre::DataStreamPtr texstream(new Ogre::MemoryDataStream(dst_start, siz=
e));
+	//Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().loadR=
awData(newtextname,
+	//	Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,texstream, w,h=
,myFormat);
+	=

+	Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().loadIma=
ge(newtextname,
+		Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,myImage,Ogre::TE=
X_TYPE_2D,-1,1.0f,true,Ogre::PF_UNKNOWN);
+	=

+	// free memory
+	//delete [] dst_start;
+
+	lua_pushstring(L,newtextname.c_str());
+	return 1;
+}
+	=

+/// void HueMesh(meshname, hueloader, hue)
+static int l_HueMesh (lua_State *L) { PROFILE
+	const char *meshname =3D luaL_checkstring(L,1);
+	cHueLoader *hueLoader =3D cLuaBind&lt;cHueLoader&gt;::checkudata(L,2);
+	int hue =3D luaL_checkint(L,3);
+
+	//printf(&quot;HueMesh(%s,%i,%i)\n&quot;,meshname,hueLoader,hue);
+	if(hueLoader &amp;&amp; hue &amp;&amp; meshname){
+		try	{
+			cHueFilter Filter;
+			short* ColorTable =3D hueLoader-&gt;GetHue( hue-1 )-&gt;GetColors();
+		=

+			// data seem ok, so read out the mesh
+			Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().load(meshname,=
Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+			=

+			//printf(&quot;mesh=3D%s\n&quot;,mesh-&gt;getName().c_str());
+
+			// and iterate over all submeshes
+			Ogre::Mesh::SubMeshIterator sit =3D mesh-&gt;getSubMeshIterator();
+			while(sit.hasMoreElements()){
+				Ogre::SubMesh *submesh =3D sit.getNext();
+				//printf(&quot;submesh=3D%i\n&quot;,submesh);
+				=

+				if(!submesh-&gt;isMatInitialised())continue;
+				=

+				//printf(&quot;matname=3D%s\n&quot;,submesh-&gt;getMaterialName().c_str());
+
+				// create hued texture in the current material and update the current =

+				Ogre::MaterialPtr mat =3D Ogre::MaterialManager::getSingleton().load(s=
ubmesh-&gt;getMaterialName(),Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROU=
P_NAME);
+				if(mat.isNull()){
+					printf(&quot;ERROR HueMesh: material %s is null\n&quot;,submesh-&gt;getMaterialNam=
e().c_str());
+					continue;
+				}
+
+				// clone current material for hueing
+				std::string newname =3D cOgreWrapper::GetSingleton().GetUniqueName();
+				Ogre::MaterialPtr mat_hue =3D Ogre::MaterialManager::getSingleton().cr=
eate(newname, mat-&gt;getGroup());
+				//printf(&quot;mat=3D%s mat_hue=3D%s\n&quot;,mat-&gt;getName().c_str(),mat_hue-&gt;get=
Name().c_str());
+				mat-&gt;copyDetailsTo(mat_hue);
+
+				// iterate over all techniques
+				Ogre::Material::TechniqueIterator tit =3D mat-&gt;getTechniqueIterator();
+				Ogre::Material::TechniqueIterator tit_hue =3D mat_hue-&gt;getTechniqueIte=
rator();
+				while(tit.hasMoreElements()){
+					Ogre::Technique *tech =3D tit.getNext();
+					Ogre::Technique *tech_hue =3D tit_hue.getNext();
+					=

+					// iterate over all passes
+					Ogre::Technique::PassIterator pit =3D tech-&gt;getPassIterator();
+					Ogre::Technique::PassIterator pit_hue =3D tech_hue-&gt;getPassIterator();
+					while(pit.hasMoreElements()){
+						Ogre::Pass *pass =3D pit.getNext();
+						Ogre::Pass *pass_hue =3D pit_hue.getNext();
+						=

+						// iterate over all tex units
+						Ogre::Pass::TextureUnitStateIterator uit =3D pass-&gt;getTextureUnitSta=
teIterator();
+						Ogre::Pass::TextureUnitStateIterator uit_hue =3D pass_hue-&gt;getTextur=
eUnitStateIterator();
+						while(uit.hasMoreElements()){
+							Ogre::TextureUnitState *unit =3D uit.getNext();
+							Ogre::TextureUnitState *unit_hue =3D uit_hue.getNext();
+
+							// current texture
+							Ogre::TexturePtr tex =3D Ogre::TextureManager::getSingleton().load(=
unit-&gt;getTextureName(),Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_N=
AME);
+
+							// lock and read access buffer
+							Ogre::HardwarePixelBufferSharedPtr b =3D tex-&gt;getBuffer();
+							// calc size of complete texture
+							Ogre::Image::Box area(0, 0, b-&gt;getWidth(), b-&gt;getHeight());
+							// and lock (ro)
+							const Ogre::PixelBox box =3D b-&gt;lock(area,Ogre::HardwareBuffer::HBL=
_READ_ONLY);
+							=

+							// size of one pixel in bytes
+							unsigned int pixelsize =3D Ogre::PixelUtil::getNumElemBytes(box.for=
mat);
+							// texture size in bytes
+							unsigned int size =3D box.getConsecutiveSize();
+							=

+							char *dst =3D new char[size];
+							char *src =3D static_cast&lt;char *&gt;(box.data);
+
+							char *dst_start =3D dst;
+							char *src_start =3D src;
+
+							uint8 cr,cg,cb,ca1,ca2;
+							short col;
+							=

+							// colorize the pixels
+							for(unsigned int y =3D 0; y &lt; box.getHeight(); y++){
+								for(unsigned int x =3D 0; x &lt; box.getWidth(); x++){
+									// read out pixel in src graphic
+									Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca1,box.format,src);
+									Ogre::PixelUtil::packColour(cr,cg,cb,ca1,Ogre::PF_A1R5G5B5,&amp;col);
+									// and hue the pixel
+									col =3D Filter( col, ColorTable );
+									//printf(&quot;RGBA_1(%i,%i,%i,%i)\n&quot;,cr,cg,cb,ca);
+									// and store it in destination (ignoring the new alpha)
+									Ogre::PixelUtil::unpackColour(&amp;cr,&amp;cg,&amp;cb,&amp;ca2,Ogre::PF_A1R5G5B5,=
&amp;col);
+									Ogre::PixelUtil::packColour(cr,cg,cb,ca1,box.format,dst);
+									//printf(&quot;RGBA_2(%i,%i,%i,%i)\n&quot;,cr,cg,cb,ca);
+									src +=3D pixelsize;
+									dst +=3D pixelsize;
+								}
+								src +=3D box.getRowSkip();
+							}
+
+							// and make a texture
+							Ogre::DataStreamPtr texstream(new Ogre::MemoryDataStream(dst_start,=
 size));
+							Ogre::TexturePtr tex_hue =3D Ogre::TextureManager::getSingleton().c=
reate(cOgreWrapper::GetSingleton().GetUniqueName(),
+								Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+							=

+							tex_hue-&gt;loadRawData(texstream,box.getWidth(),box.getHeight(),box.f=
ormat);
+							=

+							// release the lock
+							b-&gt;unlock();
+
+							// free memory
+							delete [] dst_start;
+		=

+							// set the texture
+							unit_hue-&gt;setTextureName(tex_hue-&gt;getName());
+						}
+					}
+				}
+
+				// set new material
+				submesh-&gt;setMaterialName(mat_hue-&gt;getName());
+			}
+		} catch (Ogre::FileNotFoundException e){
+			printf(&quot;ERROR file not found, so HueMesh(%s) canceled\n&quot;,meshname);
+		}
+	}
+
+	return 0;
+}
+
+/// create a lua lookup table based on the given file
+/// usage: lookup[id] =3D new_id
+static int l_CreateLookupTableFromFile (lua_State *L) { PROFILE
+	const char *filename =3D luaL_checkstring(L, 1);
+	lua_newtable(L);
+	=

+	cFullFileLoader f(filename);
+	=

+	const uint32 *buffer =3D (const uint32 *)f.mpFullFileBuffer;
+	=

+	for(int i =3D 0;i &lt; f.miFullFileSize / 4; ++i){
+		lua_pushnumber(L,i); lua_rawseti(L,-2,buffer[i]);
+	}
+	=

+	return 1;
+}
+
+
+static int l_Client_SetSkybox (lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().SetSkybox( (lua_gettop(L) &gt; 0 &amp;&amp; !lua_isnil(=
L,1)) ? luaL_checkstring(L, 1) : 0 , true );
+	return 0;
+}
+
+static int l_Client_SetFog (lua_State *L) { PROFILE
+	int i=3D0;
+	int numargs=3Dlua_gettop(L);
+	int iFogMode 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checkint(L,=
 ++i) : 0;
+	Ogre::Real r 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
+	Ogre::Real g 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
+	Ogre::Real b 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
+	Ogre::Real a 			=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_checknumber=
(L, ++i) : 1;
+	Ogre::Real expDensity 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_chec=
knumber(L, ++i) : 0.001;
+	Ogre::Real linearStart 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_che=
cknumber(L, ++i) : 0.0;
+	Ogre::Real linearEnd 	=3D (numargs &gt; i &amp;&amp; !lua_isnil(L,i+1)) ? luaL_check=
number(L, ++i) : 1.0;
+	/*
+	void 	setFog (FogMode mode=3DFOG_NONE, const ColourValue &amp;colour=3DColour=
Value::White, =

+					Real expDensity=3D0.001, Real linearStart=3D0.0, Real linearEnd=3D1.0)
+    0=3DFOG_NONE 	No fog. Duh.
+    1=3DFOG_EXP 	Fog density increases exponentially from the camera (fog =
=3D 1/e^(distance * density)).
+    2=3DFOG_EXP2 	Fog density increases at the square of FOG_EXP, i.e. eve=
n quicker (fog =3D 1/e^(distance * density)^2).
+    3=3DFOG_LINEAR 	Fog density increases linearly between the start and e=
nd distances.
+	*/
+	Ogre::FogMode      myFogMode =3D Ogre::FOG_NONE;
+	if (iFogMode =3D=3D 1) myFogMode =3D Ogre::FOG_EXP;
+	if (iFogMode =3D=3D 2) myFogMode =3D Ogre::FOG_EXP2;
+	if (iFogMode =3D=3D 3) myFogMode =3D Ogre::FOG_LINEAR;
+	cOgreWrapper::GetSingleton().mSceneMgr-&gt;setFog(myFogMode,Ogre::ColourValu=
e(r,g,b,a),expDensity,linearStart,linearEnd);
+	return 0;
+}
+
+static int l_Client_RenderOneFrame (lua_State *L) { PROFILE
+	cGame::GetSingleton().RenderOneFrame();
+	return 0;
+}
+
+/// just do nothing for x seconds
+static int l_Client_Sleep (lua_State *L) { PROFILE
+	//TODO correct win handling
+#ifndef WIN32
+	sleep(luaL_checkint(L,1));
+#else
+	Sleep(luaL_checkint(L,1)*1000); // takes milliseconds
+#endif
+	return 0;
+}
+
+/// just do nothing for x milliseconds (1000msec =3D 1sec)
+static int l_Client_USleep (lua_State *L) { PROFILE
+	//TODO correct win handling
+#ifndef WIN32
+	usleep((uint32)luaL_checkint(L,1)*(uint32)1000L); // usleep takes MICROse=
conds, where 1000 =3D 1 MILLIsecond
+#else
+	Sleep(luaL_checkint(L,1)); // takes milliseconds
+#endif
+	return 0;
+}
+
+
+
+static int l_Client_SetAmbientLight (lua_State *L) { PROFILE
+	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
+	if (pSceneMgr) pSceneMgr-&gt;setAmbientLight(Ogre::ColourValue(luaL_checknum=
ber(L,1),luaL_checknumber(L,2),luaL_checknumber(L,3),luaL_checknumber(L,4))=
);
+	return 0;
+}
+
+static int l_Client_ClearLights (lua_State *L) { PROFILE
+	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
+	if (pSceneMgr) pSceneMgr-&gt;destroyAllLights();
+	return 0;
+}
+
+static int l_Client_AddPointLight (lua_State *L) { PROFILE
+	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
+	if (pSceneMgr) {
+		Ogre::Light* pLight =3D pSceneMgr-&gt;createLight( cOgreWrapper::GetSinglet=
on().GetUniqueName() );
+		pLight-&gt;setType( Ogre::Light::LT_POINT );
+		pLight-&gt;setPosition(luaL_checknumber(L,1),luaL_checknumber(L,2),luaL_che=
cknumber(L,3));
+	}
+	return 0;
+}
+
+static int l_Client_AddDirectionalLight (lua_State *L) { PROFILE
+	Ogre::SceneManager* pSceneMgr =3D cOgreWrapper::GetSingleton().mSceneMgr;
+	if (pSceneMgr) {
+		Ogre::Light* pLight =3D pSceneMgr-&gt;createLight( cOgreWrapper::GetSinglet=
on().GetUniqueName() );
+		pLight-&gt;setType( Ogre::Light::LT_DIRECTIONAL );
+		pLight-&gt;setDirection(luaL_checknumber(L,1),luaL_checknumber(L,2),luaL_ch=
ecknumber(L,3));
+	}
+	return 0;
+}
+
+static int l_Client_GetPhysStepTime (lua_State *L) { PROFILE
+	lua_pushnumber(L,cTimer::mfPhysStepTime);
+	return 1;
+}
+
+/// saved in main directory
+static int l_Client_TakeGridScreenshot (lua_State *L) { PROFILE
+	std::string filename =3D strprintf( &quot;%shighres_%d&quot;, &quot;../screenshots/&quot;, cS=
hell::GetTicks() );
+	std::string ext =3D &quot;.jpg&quot;;
+	cOgreWrapper::GetSingleton().TakeGridScreenshot(3,filename,ext,true);
+	return 0;
+}
+
+/// saved in main directory
+static int l_Client_TakeScreenshot (lua_State *L) { PROFILE
+	cOgreWrapper::GetSingleton().TakeScreenshot();
+	return 0;
+}
+
+void	OgreForceCloseFullscreen ();
+
+/// shows ogre config dialog
+static int l_Client_ShowOgreConfig (lua_State *L) { PROFILE
+	bool bIsFullscreen =3D cOgreWrapper::GetSingleton().mWindow-&gt;isFullScreen=
();
+	printf(&quot;Client_ShowOgreConfig fullscreen=3D%d\n&quot;,bIsFullscreen);
+	bIsFullscreen =3D true; // detection fails in linux ?
+	if (bIsFullscreen) {
+		// hide window to make config window visible in fullscreen mode, evil ha=
ck since this is not supported by ogre
+		OgreForceCloseFullscreen();
+	}
+	lua_pushboolean(L,cOgreWrapper::GetSingleton().mRoot-&gt;showConfigDialog());
+	if (bIsFullscreen) cShell::mbAlive =3D false;
+	// the application shoudl terminate after this
+	// terminates the game if changes were made
+	return 1;
+}
+
+static int l_BuildTerrainEntity_Simple (lua_State *L) { PROFILE
+	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
+	if (!pGroundBlockLoader) return 0;
+	int i=3D5;
+	bool bGenerateNormals=3D		(lua_gettop(L) &gt;=3D ++i &amp;&amp; !lua_isnil(L,i)) ? l=
ua_toboolean(L,i) : true;
+	std::string meshname =3D BuildTerrainEntity_Simple(
+		pGroundBlockLoader,
+		luaL_checkint(L,2),luaL_checkint(L,3),
+		luaL_checkint(L,4),luaL_checkint(L,5),bGenerateNormals);
+	if (meshname.length() =3D=3D 0) return 0;
+	lua_pushstring(L,meshname.c_str());
+	return 1;
+}
+
+static int l_BuildTerrainEntity_Shaded (lua_State *L) { PROFILE
+	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
+	if (!pGroundBlockLoader) return 0;
+	std::string meshname =3D BuildTerrainEntity_Shaded(
+		pGroundBlockLoader,
+		luaL_checkint(L,2),luaL_checkint(L,3),
+		luaL_checkint(L,4),luaL_checkint(L,5));
+	if (meshname.length() =3D=3D 0) return 0;
+	lua_pushstring(L,meshname.c_str());
+	return 1;
+}
+
+/// OBSOLETED CODE ! don't use this, hasn't been adjusted to xmirror fix
+/// for lua : TerrainRayPick(GroundBlockLoader,blockx,blocky,vBlockPosX,vB=
lockPosY,vBlockPosZ,rx,ry,rz,rvx,rvy,rvz)  -- mainly for mousepicking
+static int l_TerrainRayPick (lua_State *L) { PROFILE
+	cGroundBlockLoader* pGroundBlockLoader =3D cLuaBind&lt;cGroundBlockLoader&gt;::=
checkudata(L,1);
+	if (!pGroundBlockLoader) return 0;
+	=

+	// don't use ++i or something here, the compiler might mix the order
+	Ogre::Vector3 	vBlockPos(luaL_checknumber(L,4),luaL_checknumber(L,5),luaL=
_checknumber(L,6));
+	Ogre::Vector3	vRayPos(luaL_checknumber(L,7),luaL_checknumber(L,8),luaL_ch=
ecknumber(L,9));
+	Ogre::Vector3	vRayDir(luaL_checknumber(L,10),luaL_checknumber(L,11),luaL_=
checknumber(L,12));
+	=

+	// feedback via lua callback TerrainRayIntersect_Hit()
+	TerrainRayIntersect(pGroundBlockLoader,luaL_checkint(L,2),luaL_checkint(L=
,3),vRayPos-vBlockPos,vRayDir);
+	return 0;
+}
+
+/// for lua : dist =3D SphereRayPick(x,y,z,rad,rx,ry,rz,rvx,rvy,rvz)  -- m=
ainly for mousepicking, dist=3Dnil if not hit
+static int l_SphereRayPick (lua_State *L) { PROFILE
+	// don't use ++i or something here, the compiler might mix the order
+	Ogre::Vector3 	vSpherePos(	luaL_checknumber(L,1),luaL_checknumber(L,2),lu=
aL_checknumber(L,3));
+	float			fSphereRad =3D luaL_checknumber(L,4);
+	Ogre::Vector3	vRayPos(	luaL_checknumber(L,5),luaL_checknumber(L,6),luaL_c=
hecknumber(L,7));
+	Ogre::Vector3	vRayDir(	luaL_checknumber(L,8),luaL_checknumber(L,9),luaL_c=
hecknumber(L,10));
+	=

+	std::pair&lt;bool, Real&gt; hit =3D Ogre::Ray(vRayPos,vRayDir).intersects(Ogre:=
:<i>Sphere(vSpherePos,fSphereRad));
</I>+	if (!hit.first) return 0;
+	lua_pushnumber(L,hit.second);
+	return 1;
+}
+
+
+static int l_UnloadMeshName (lua_State *L) { PROFILE
+	Ogre::MeshManager::getSingleton().unload(luaL_checkstring(L,1));
+	return 0;
+}
+
+static int l_CountMeshTriangles (lua_State *L) { PROFILE
+	Ogre::MeshPtr pMesh =3D Ogre::MeshManager::getSingleton().load(luaL_check=
string(L,1),
+					Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
+	int res =3D 0;
+	for (int i=3D0;i&lt;pMesh-&gt;getNumSubMeshes();++i) {
+		Ogre::SubMesh *pSub =3D pMesh-&gt;getSubMesh(i);
+		if (pSub &amp;&amp; pSub-&gt;indexData) res +=3D pSub-&gt;indexData-&gt;indexCount / 3;
+	}
+	lua_pushnumber(L,res);
+	return 1;
+}
+
+static int l_getUOPath(lua_State *L) { PROFILE
+	std::string res =3D getUOPath();
+	if (res.length() =3D=3D 0) return 0;
+	lua_pushstring(L,res.c_str());
+	return 1;
+}
+
+/// attempts to correct case-sensitivity for filepaths
+static int l_PathSearch (lua_State *L) { PROFILE
+	std::string res =3D rob_pathsearch(luaL_checkstring(L,1));
+	if (res.length() =3D=3D 0) return 0;
+	lua_pushstring(L,res.c_str());
+	return 1;
+}
+
+static int l_file_exists (lua_State *L) { PROFILE
+	std::ifstream	myFileStream(luaL_checkstring(L,1));
+	lua_pushboolean(L,myFileStream?true:false);
+	return 1;
+}
+
+static int l_file_size (lua_State *L) { PROFILE
+	std::ifstream	myFileStream(luaL_checkstring(L,1));
+	int iFileSize =3D 0;
+	if (myFileStream) {
+		myFileStream.seekg(0, std::ios::end);
+		iFileSize =3D myFileStream.tellg();
+	}
+	lua_pushnumber(L,iFileSize);
+	return 1;
+}
+
+
+// for testing bitwise ops
+static int l_GetRandomHexString 	(lua_State *L) { PROFILE lua_pushstring( =
L, strprintf(&quot;0x%08x&quot;,rand()).c_str()); return 1; }
+
+/// converts &quot;0x1234&quot; to a number
+static int l_Hex2Num 	(lua_State *L) { PROFILE =

+	std::string hexcode =3D luaL_checkstring(L,1);
+	uint32 res =3D 0;
+	sscanf(hexcode.c_str(),&quot;0x%x&quot;,&amp;res);
+	lua_pushnumber(L, res); =

+	return 1; =

+}
+
+// bitwise operations, used for networking, packet manipulation etc
+static int l_BitwiseAND 	(lua_State *L) { PROFILE
+	// keep this spread out like this to avoid strange, 32 bi
+	double g =3D luaL_checknumber(L,1);
+	double h =3D luaL_checknumber(L,2);
+	uint32 a =3D uint32(g);
+	uint32 b =3D uint32(h);	=

+	uint32 c =3D a &amp; b;
+	lua_pushnumber( L, c); =

+	return 1;
+}
+static int l_BitwiseOR 		(lua_State *L) { PROFILE
+	// keep this spread out like this to avoid strange, 32 bi
+	double g =3D luaL_checknumber(L,1);
+	double h =3D luaL_checknumber(L,2);
+	uint32 a =3D uint32(g);
+	uint32 b =3D uint32(h);	=

+	uint32 c =3D a | b;
+	lua_pushnumber( L, c); =

+	return 1;
+}
+
+
+static int l_BitwiseXOR 	(lua_State *L) { PROFILE
+	// keep this spread out like this to avoid strange, 32 bi
+	double g =3D luaL_checknumber(L,1);
+	double h =3D luaL_checknumber(L,2);
+	uint32 a =3D uint32(g);
+	uint32 b =3D uint32(h);	=

+	uint32 c =3D a ^ b;
+	lua_pushnumber( L, c); =

+	return 1;
+}
+
+// bitwise operations, used for networking, packet manipulation etc =

+static int l_BitwiseSHL 	(lua_State *L) { PROFILE =

+	// keep this spread out like this to avoid strange, 32 bi =

+	double g =3D luaL_checknumber(L,1); =

+	double h =3D luaL_checknumber(L,2); =

+	uint32 a =3D uint32(g); =

+	uint32 b =3D uint32(h);	 =

+	uint32 c =3D a &lt;&lt; b; =

+	lua_pushnumber( L, c);  =

+	return 1; =

+} =

+// bitwise operations, used for networking, packet manipulation etc =

+static int l_BitwiseSHR 	(lua_State *L) { PROFILE =

+	// keep this spread out like this to avoid strange, 32 bi =

+	double g =3D luaL_checknumber(L,1); =

+	double h =3D luaL_checknumber(L,2); =

+	uint32 a =3D uint32(g); =

+	uint32 b =3D uint32(h);	 =

+	uint32 c =3D a &gt;&gt; b; =

+	lua_pushnumber( L, c);  =

+	return 1; =

+}
+
+
+static int l_TestBit 		(lua_State *L) { PROFILE lua_pushboolean(L,(uint32(=
luaL_checknumber(L,1)) &amp; (uint32(1) &lt;&lt; luaL_checkint(L,2))) !=3D 0); return=
 1; }
+static int l_SetBit 		(lua_State *L) { PROFILE lua_pushnumber( L,(uint32(l=
uaL_checknumber(L,1)) | (uint32(1) &lt;&lt; luaL_checkint(L,2)))); return 1; }
+static int l_ClearBit 		(lua_State *L) { PROFILE =

+	uint32 input =3D uint32(luaL_checknumber(L,1));
+	uint32 mask =3D 1L &lt;&lt; uint32(luaL_checknumber(L,2));
+	lua_pushnumber(L,(input &amp; mask)?(input ^ mask):(input));  // XOR =3D ^ =
=3D toggle bit... toggle only if set (&amp;) to clear
+	return 1; =

+}
+
+
+static int l_Exit		 		(lua_State *L) { PROFILE =

+	exit((lua_gettop(L) &gt;=3D 1 &amp;&amp; !lua_isnil(L,1)) ? luaL_checkint(L,1) : 0); =

+	return 0; =

+}
+
+static int l_Crash		 		(lua_State *L) { PROFILE =

+	DisplayErrorMessage(&quot;CRASH triggered from script, see console for info (s=
tart with commandline option -c)&quot;);
+	exit(88); =

+	return 0; =

+}
+
+/// triggers a segfault, for testing our segfault handlers lua stacktrace
+static int l_CrashSegFault		 		(lua_State *L) { PROFILE =

+	DisplayErrorMessage(&quot;testing segfault handler...&quot;);
+	*((char*)0) =3D 0; // trigger segfault
+	return 0; =

+}
+
+
+static int l_DisplayNotice	(lua_State *L) { PROFILE =

+	DisplayNotice(luaL_checkstring(L,1));
+	return 0;
+}
+
+
+static int l_FatalErrorMessage	(lua_State *L) { PROFILE =

+	DisplayErrorMessage(luaL_checkstring(L,1));
+	exit(77);
+	return 0;
+}
+
+
+/// for lua :   void  ExportMesh  (meshname,filename)
+static int l_ExportMesh		(lua_State *L) { PROFILE =

+	Ogre::MeshPtr pMesh =3D Ogre::MeshManager::getSingleton().load(luaL_check=
string(L,1),
+					// autodetect group location
+					//Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
+					Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
+	Ogre::MeshSerializer myExporter;
+	//Ogre::Mesh* pMesh =3D pEntity-&gt;getMesh().get();
+	myExporter.exportMesh(pMesh.get(),luaL_checkstring(L,2)); =

+	return 0;
+}
+
+/// for lua :   x,y,z,vx,vy,vz  GetMouseRay  ()
+static int l_GetMouseRay		(lua_State *L) { PROFILE =

+	cOgreWrapper&amp; ogrewrapper =3D cOgreWrapper::GetSingleton();
+	Ogre::Ray myray(	ogrewrapper.mCamera-&gt;getCameraToViewportRay(
+				Ogre::Real(cInput::iMouse[0]) / Ogre::Real(ogrewrapper.mViewport-&gt;getA=
ctualWidth()),
+				Ogre::Real(cInput::iMouse[1]) / Ogre::Real(ogrewrapper.mViewport-&gt;getA=
ctualHeight()) ));
+	lua_pushnumber(L,myray.getOrigin().x);
+	lua_pushnumber(L,myray.getOrigin().y);
+	lua_pushnumber(L,myray.getOrigin().z);
+	lua_pushnumber(L,myray.getDirection().x);
+	lua_pushnumber(L,myray.getDirection().y);
+	lua_pushnumber(L,myray.getDirection().z);
+	return 6;
+}
+
+/// for lua :   z  GetMaxZ  ()
+static int 		l_GetMaxZ		(lua_State *L) { PROFILE =

+	lua_pushnumber(L,Ogre::Root::getSingleton().getRenderSystem()-&gt;getMaximum=
DepthInputValue());
+	return 1;
+}
+
+
+/// for lua :   bIsInFront,px,py  ProjectPos  (x,y,z)
+static int l_ProjectPos		(lua_State *L) { PROFILE =

+	bool 		bIsInFront;
+	Ogre::Real	fX,fY;
+	bIsInFront =3D cOgreWrapper::GetSingleton().ProjectPos(
+		Ogre::Vector3(luaL_checknumber(L,0),luaL_checknumber(L,1),luaL_checknumb=
er(L,2)),fX,fY);
+	lua_pushboolean(L,bIsInFront);
+	lua_pushnumber(L,fX);
+	lua_pushnumber(L,fY);
+	return 3;
+}
+
+/// for lua :   bIsInFront,px,py,cx,cy  ProjectSizeAndPos  (x,y,z,r)
+static int l_ProjectSizeAndPos		(lua_State *L) { PROFILE =

+	bool 		bIsInFront;
+	Ogre::Real	fX,fY,fCX,fCY;
+	bIsInFront =3D cOgreWrapper::GetSingleton().ProjectSizeAndPos(
+		Ogre::Vector3(luaL_checknumber(L,0),luaL_checknumber(L,1),luaL_checknumb=
er(L,2)),fX,fY,luaL_checknumber(L,3),fCX,fCY);
+	lua_pushboolean(L,bIsInFront);
+	lua_pushnumber(L,fX);
+	lua_pushnumber(L,fY);
+	lua_pushnumber(L,fCX);
+	lua_pushnumber(L,fCY);
+	return 5;
+}
+
+
+
+/// for lua :   void  CreateSceneManager  (sSceneManagerName)
+static int l_CreateSceneManager		(lua_State *L) { PROFILE  // TODO : move =
to seperate file ?
+	cOgreWrapper::GetSingleton().mRoot-&gt;createSceneManager(Ogre::ST_GENERIC,l=
uaL_checkstring(L,1));
+	return 0;
+}
+
+/// for lua :   table[id=3Dtexname...]  OgreMeshTextures  (meshfile)
+static int l_OgreMeshTextures	(lua_State *L) { PROFILE  // TODO : move to =
seperate file ?
+	Ogre::MeshSerializer* meshSerializer =3D new Ogre::MeshSerializer();
+	const char *szMeshName =3D luaL_checkstring(L,1);
+	=

+	lua_newtable(L);
+		=

+	//printf(&quot;open file: %s\n&quot;,szMeshName);
+	// model file
+	std::ifstream ifs;
+	ifs.open(szMeshName, std::ios_base::in | std::ios_base::binary);
+	Ogre::DataStreamPtr stream(new Ogre::FileStreamDataStream(&amp;ifs, false));
+
+	if(ifs.is_open()){
+		//printf(&quot;create tmp mesh\n&quot;);
+		// create tmp mesh import resource
+		Ogre::MeshPtr mesh =3D Ogre::MeshManager::getSingleton().create(&quot;l_OgreM=
eshTextureMissing_conversion&quot;, =

+			Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+
+		//printf(&quot;import\n&quot;);
+		// import
+		meshSerializer-&gt;importMesh(stream, mesh.getPointer());
+		=

+		if(!mesh.isNull()){
+			// iterator over submeshes
+			Ogre::Mesh::SubMeshIterator it =3D mesh-&gt;getSubMeshIterator();
+			int i =3D 1;
+			while(it.hasMoreElements()){
+				Ogre::SubMesh *submesh =3D it.getNext();
+				std::string tex =3D submesh-&gt;getMaterialName();
+				//printf(&quot;material found: %s\n&quot;,tex.c_str());
+				lua_pushstring(L,tex.c_str()); lua_rawseti(L,-2,i);
+				++i;
+			}
+		}
+		=

+		// remove all stuff
+		Ogre::MeshManager::getSingleton().remove(&quot;l_OgreMeshTextureMissing_conve=
rsion&quot;);
+		=

+		ifs.close();
+	} else {
+		printf(&quot;ERROR can't open file: %s\n&quot;,szMeshName);
+	}
+
+	delete meshSerializer;
+		=

+	return 1;
+}
+
+
+/// for lua :   void OgreShadowTechnique  (string techique)
+static int l_OgreShadowTechnique	(lua_State *L) { PROFILE  // TODO : move =
to seperate file ?
+	const char *tech =3D luaL_checkstring(L,1);
+	Ogre::SceneManager *p =3D cOgreWrapper::GetSingleton().mSceneMgr;
+	=

+	if(p){
+		if(strcmp(tech,&quot;stencil_modulative&quot;) =3D=3D 0)p-&gt;setShadowTechnique(Ogre=
::<i>SHADOWTYPE_STENCIL_MODULATIVE);
</I>+		else if(strcmp(tech,&quot;stencil_additive&quot;) =3D=3D 0)p-&gt;setShadowTechnique(O=
gre::SHADOWTYPE_STENCIL_ADDITIVE);
+		else if(strcmp(tech,&quot;texture_modulative&quot;) =3D=3D 0)p-&gt;setShadowTechnique=
(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE);
+		else if(strcmp(tech,&quot;texture_additive&quot;) =3D=3D 0)p-&gt;setShadowTechnique(O=
gre::SHADOWTYPE_TEXTURE_ADDITIVE);
+		else if(strcmp(tech,&quot;texture_additive_integrated&quot;) =3D=3D 0)p-&gt;setShadow=
Technique(Ogre::SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED);
+		else if(strcmp(tech,&quot;texture_modulative_integrated&quot;) =3D=3D 0)p-&gt;setShad=
owTechnique(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED);
+		else p-&gt;setShadowTechnique(Ogre::SHADOWTYPE_NONE);
+	}
+		=

+	return 0;
+}
+
+
+/// for lua :   void OgreAmbientLight  (r,g,b) [color value 0..1 each]
+static int l_OgreAmbientLight	(lua_State *L) { PROFILE  // TODO : move to =
seperate file ?
+	float r =3D luaL_checknumber(L,1);
+	float g =3D luaL_checknumber(L,2);
+	float b =3D luaL_checknumber(L,3);
+	Ogre::SceneManager *p =3D cOgreWrapper::GetSingleton().mSceneMgr;
+	=

+	if(p){
+		p-&gt;setAmbientLight( ColourValue( r, g, b ) );
+	}
+	=

+	return 0;
+}
+
+/// for lua :   string  GetUniqueName  ()
+static int l_GetUniqueName	(lua_State *L) { PROFILE  // TODO : move to sep=
erate file ?
+	std::string n =3D cOgreWrapper::GetSingleton().GetUniqueName();
+	lua_pushstring(L,n.c_str());
+	return 1;
+}
+
+
+/// for lua :   number OgreLastFPS  ()
+static int l_OgreLastFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWr=
apper::GetSingleton().mfLastFPS);return 1; }
+/// for lua :   number OgreAvgFPS  ()
+static int l_OgreAvgFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWra=
pper::GetSingleton().mfAvgFPS);return 1; }
+/// for lua :   number OgreBestFPS  ()
+static int l_OgreBestFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreWr=
apper::GetSingleton().mfBestFPS);return 1; }
+/// for lua :   number OgreWorstFPS  ()
+static int l_OgreWorstFPS	(lua_State *L) { PROFILE lua_pushnumber(L,cOgreW=
rapper::GetSingleton().mfWorstFPS);return 1; }
+/// for lua :   number OgreBestFrameTime  ()
+static int l_OgreBestFrameTime	(lua_State *L) { PROFILE lua_pushnumber(L,c=
OgreWrapper::GetSingleton().miBestFrameTime);return 1; }
+/// for lua :   number OgreWorstFrameTime  ()
+static int l_OgreWorstFrameTime	(lua_State *L) { PROFILE lua_pushnumber(L,=
cOgreWrapper::GetSingleton().miWorstFrameTime);return 1; }
+/// for lua :   number OgreTriangleCount  ()
+static int l_OgreTriangleCount	(lua_State *L) { PROFILE lua_pushnumber(L,c=
OgreWrapper::GetSingleton().miTriangleCount);return 1; }
+/// for lua :   number OgreBatchCount  ()
+static int l_OgreBatchCount	(lua_State *L) { PROFILE lua_pushnumber(L,cOgr=
eWrapper::GetSingleton().miBatchCount);return 1; }
+
+/*
+static int l_Client_SetMouseSensitivity (lua_State *L) { PROFILE
+	cClient* client =3D cGame::GetSingleton().mpClient;
+	if (client) client-&gt;mfMouseSensitivity =3D luaL_checknumber(L,1);
+	return 0;
+}
+
+
+
+static int l_Client_SetInvertMouse (lua_State *L) { PROFILE
+	cClient* client =3D cGame::GetSingleton().mpClient;
+	if (client) client-&gt;mbInvertMouse =3D luaL_checkint(L,1) !=3D 0;
+	return 0;
+}
+
+
+static int l_Client_SetCamera (lua_State *L) { PROFILE
+	int i=3D0;
+	Real x =3D luaL_checknumber(L,++i);
+	Real y =3D luaL_checknumber(L,++i);
+	Real z =3D luaL_checknumber(L,++i);
+	Real qw =3D luaL_checknumber(L,++i);
+	Real qx =3D luaL_checknumber(L,++i);
+	Real qy =3D luaL_checknumber(L,++i);
+	Real qz =3D luaL_checknumber(L,++i);
+	cClient* client =3D cGame::GetSingleton().mpClient;
+	if (client)
+			client-&gt;SetCamera(Vector3(x,y,z),Quaternion(qw,qx,qy,qz));
+	else	printf(&quot;l_Client_SetCamera called from lua on non-client&quot;);
+	return 0;
+}
+
+static int l_Client_ForceCamRot (lua_State *L) { PROFILE
+	int i=3D0;
+	Real qw =3D luaL_checknumber(L,++i);
+	Real qx =3D luaL_checknumber(L,++i);
+	Real qy =3D luaL_checknumber(L,++i);
+	Real qz =3D luaL_checknumber(L,++i);
+	cClient* client =3D cGame::GetSingleton().mpClient;
+	if (client)
+			client-&gt;ForceCamRot(Quaternion(qw,qx,qy,qz));
+	else	printf(&quot;l_Client_ForceCamRot called from lua on non-client&quot;);
+	return 0;
+}
+
+static int l_Client_CameraLookAt (lua_State *L) { PROFILE
+	int i=3D0;
+	Real x =3D luaL_checknumber(L,++i);
+	Real y =3D luaL_checknumber(L,++i);
+	Real z =3D luaL_checknumber(L,++i);
+	cClient* client =3D cGame::GetSingleton().mpClient;
+	if (client)
+			client-&gt;CameraLookAt(Vector3(x,y,z));
+	else	printf(&quot;l_Client_CameraLookAt called from lua on non-client&quot;);
+	return 0;
+}
+*/
+
+
+// ***** ***** utilities and error handling ***** *****
+
+
+/// also adds a traceback to the error message in case of an error
+/// nret=3D-1 for unlimited
+/// don't use directly, used by LuaCall
+int 	PCallWithErrFuncWrapper (lua_State *L,int narg, int nret) { PROFILE
+	int status;
+	int base =3D lua_gettop(L) - narg;  // function index =

+	lua_pushliteral(L, &quot;_TRACEBACK&quot;);
+	lua_rawget(L, LUA_GLOBALSINDEX); // get traceback function =

+	lua_insert(L, base);  // put it under chunk and args =

+	// signal(SIGINT, laction); // copyed from example, no idea what this is =
good for =3D(
+	status =3D lua_pcall(L, narg, (nret=3D=3D-1) ? LUA_MULTRET : nret, base);
+	=

+	//printf(&quot;pcall end, cleaning up....\n&quot;);
+	=

+	// signal(SIGINT, SIG_DFL); // copyed from example, no idea what this is =
good for =3D(
+	lua_remove(L, base);  // remove traceback function // TODO : this might c=
rash if error handler closed the lua state =

+	=

+	//printf(&quot;pcall end\n&quot;);
+	=

+	return status;
+}
+
+
+void MyCrash				(const char* szMessage);
+
+void LuaErrorHandler (lua_State *L, const char *fmt, ...) { PROFILE
+	printf(&quot;LuaErrorHandler start\n&quot;);
+	=

+	va_list argp;
+	va_start(argp, fmt);
+	gRobStringBuffer[0] =3D 0;
+	vsnprintf(gRobStringBuffer,kRobStringBufferSize-1,fmt, argp);
+	std::string s(gRobStringBuffer);
+	va_end(argp);
+	=

+	std::string mystr(&quot;LuaError\n&quot;);
+	mystr +=3D s;
+	=

+	printf(&quot;\nLuaErrorHandler end\n&quot;);
+	=

+	//lua_close(L);
+	MyCrash(mystr.c_str());
+	// todo : attempt recovery in case of protected function call ?
+	// todo : deinit ogre to free mouse here
+}
+
+
+struct luaL_reg make_luaL_reg(const char *name,lua_CFunction func){
+  struct luaL_reg s;
+  s.name =3D name;
+  s.func =3D func;
+  return s;
+}
+
+void	cScripting::Listener_Notify (cListenable* pTarget,const size_t eventc=
ode,const size_t param,const size_t userdata) { PROFILE
+	switch (userdata) {
+		case kListenerBinding_Keys:
+			switch (eventcode) {
+				case cInput::kListenerEvent_KeyPress:
+					LuaCall(&quot;KeyDown&quot;,&quot;ii&quot;,(int)(param &amp; 255),(int)((param &gt;&gt; 8) &amp; 255));
+					//printf(&quot;keydown(%d)\n&quot;,param);
+				break;
+				case cInput::kListenerEvent_KeyRelease:
+					LuaCall(&quot;KeyUp&quot;,&quot;i&quot;,(int)param);
+					//printf(&quot;keyup(%d)\n&quot;,param);
+				break;
+			}
+			//printf(&quot;event=3D%d,key=3D%d\n&quot;,eventcode,param);
+		break;
+		// TODO : maybe timer ?
+	}
+}
+
+int		cScripting::GetGlobal	(const char* name) { PROFILE
+	lua_getglobal(L,name);
+	if (!lua_isnumber(L,-1)) { lua_pop(L,1); return 0; }
+	return (int)lua_tonumber(L,-1);
+}
+
+void	cScripting::SetGlobal	(const char* name,int value) { PROFILE
+	lua_pushnumber(L,value);
+	lua_setglobal(L,name);
+}
+
+/// this is the call_va function from the Book &quot;Programming in Lua&quot; with a=
ltered type notation :
+/// float : f
+/// int : i
+/// const char* : s
+/// returns true on successful call
+/// warning ! maybe this cannot return more than one string ! todo : check=
 doc of lua_tostring
+bool cScripting::LuaCall (const char *func, const char *sig, ...) { PROFILE
+	#ifdef PROFILE_LUACALLCOUNT
+	++gPROFILE_LUACALLCOUNT[func];
+	#endif
+
+	bool result =3D true;
+	va_list vl;
+	int narg, nres;  /* number of arguments and results */
+
+	va_start(vl, sig);
+	lua_getglobal(L, func);  /* get function */
+
+	/* push arguments */
+	narg =3D 0;
+	while (*sig) {  /* push arguments */
+		bool endwhile =3D false;
+		switch (*sig++) {
+		  case 'f':  /* float/double argument */
+			lua_pushnumber(L, va_arg(vl, double));
+			break;
+
+		  case 'i':  /* int argument (ansi printf : also use %d) */
+			lua_pushnumber(L, va_arg(vl, int));
+			break;
+
+		  case 's':  /* string argument */
+			lua_pushstring(L, va_arg(vl, char *));
+			break;
+
+		  case '&gt;':
+			endwhile =3D true;
+			break;
+		  default:
+			LuaErrorHandler(L, &quot;invalid option (%c)&quot;, *(sig - 1));
+			lua_pushnil(L);
+			break;
+		}
+		if (endwhile) break;
+		narg++;
+		luaL_checkstack(L, 1, &quot;too many arguments&quot;);
+	}
+
+	/* do the call */
+	nres =3D strlen(sig);  /* number of expected results */
+	// todo : push lua error handler function here ?!?
+	if (PCallWithErrFuncWrapper(L,narg, nres) !=3D 0) {
+	//if (lua_pcall(L, narg, nres, 0) !=3D 0)  { // old
+		/* do the call */
+		LuaErrorHandler(L, &quot;error running function `%s': %s&quot;,func, lua_tostring(=
L, -1));
+		=

+		/*
+		doku for lua_pcall last argument (errorfunc)
+		if 0 ... else that argument should be the index in the stack where the e=
rror handler function is located. Notice that, in such cases, the handler m=
ust be pushed in the stack before the function to be called and its argumen=
ts.
+		*/
+		result =3D false;
+	} else {
+		/* retrieve results */
+		int popamount =3D nres;
+		nres =3D -nres;  /* stack index of first result */
+		while (*sig) {  /* get results */
+			switch (*sig++) {
+
+			  case 'f':  /* float / double result */
+				if (!lua_isnumber(L, nres)) {
+					LuaErrorHandler(L, &quot;wrong result type&quot;);
+					*va_arg(vl, double *) =3D 0;
+				} else {
+					*va_arg(vl, double *) =3D lua_tonumber(L, nres);
+				}
+				break;
+
+			  case 'i':  /* int result */
+				if (!lua_isnumber(L, nres)) {
+					LuaErrorHandler(L, &quot;wrong result type&quot;);
+					*va_arg(vl, int *) =3D 0;
+				} else {
+					*va_arg(vl, int *) =3D (int)lua_tonumber(L, nres);
+				}
+				break;
+
+			  case 's':  /* string result */
+				if (!lua_isstring(L, nres)) {
+					LuaErrorHandler(L, &quot;wrong result type&quot;);
+					*va_arg(vl,std::string*) =3D &quot;&quot;;
+				} else {
+					*va_arg(vl,std::string*) =3D lua_tostring(L, nres); // return as std:=
:<i>string, as pure lua pointer becomes invalid with pop
</I>+				}
+				break;
+
+			  default:
+				LuaErrorHandler(L, &quot;invalid option (%c)&quot;, *(sig - 1));
+				break;
+			}
+			nres++;
+		}
+		// pop stack    =

+		lua_pop(L, popamount);
+	}
+	va_end(vl);
+	return result;
+}
+
+
+cScripting::cScripting	() : L(0) {}
+
+void	cScripting::Init () { PROFILE
+	if (sizeof(lua_Number) &lt;=3D 4) {
+		printf(&quot;sizeof(lua_Number) =3D %d, but must be greater than 4 (32 bit) f=
or bitwise ops\n&quot;,sizeof(lua_Number));
+		DisplayErrorMessage(&quot;ERROR : lua-precision wrong&quot;);
+		exit(43);
+	}
+	=

+	L =3D lua_open();
+	assert(L);
+	luaopen_base(L);
+	luaopen_table(L);
+	luaopen_io(L);
+	luaopen_string(L);
+	luaopen_math(L);
+	luaopen_debug(L);
+	=

+	lua_register(L,&quot;GetNamedKey&quot;,		l_GetNamedKey);
+	lua_register(L,&quot;GetKeyName&quot;,		l_GetKeyName);
+	lua_register(L,&quot;PollInput&quot;,			l_PollInput);
+	lua_register(L,&quot;Terminate&quot;,			l_Terminate);
+	lua_register(L,&quot;InitOgre&quot;,			l_InitOgre);
+	lua_register(L,&quot;GetPointerSize&quot;,	l_GetPointerSize);
+	lua_register(L,&quot;Client_IsAlive&quot;,	l_Client_IsAlive);
+	//lua_register(L,&quot;ServerSendMsgToClient&quot;,			l_ServerSendMsgToClient);
+	//lua_register(L,&quot;ClientSendMsgToServer&quot;,			l_ClientSendMsgToServer);
+	//lua_register(L,&quot;SoundPlayAmbient&quot;,				l_SoundPlayAmbient);
+	//lua_register(L,&quot;Server_SetMaxResyncsPerSecond&quot;,	l_Server_SetMaxResyncsP=
erSecond);
+	//lua_register(L,&quot;Server_GetMaxResyncsPerSecond&quot;,	l_Server_GetMaxResyncsP=
erSecond);
+	lua_register(L,&quot;Client_ShowOgreConfig&quot;,			l_Client_ShowOgreConfig);
+	lua_register(L,&quot;Client_TakeScreenshot&quot;,			l_Client_TakeScreenshot);
+	lua_register(L,&quot;Client_TakeGridScreenshot&quot;,			l_Client_TakeGridScreenshot=
);
+	//lua_register(L,&quot;Client_SetCamera&quot;,				l_Client_SetCamera);
+	//lua_register(L,&quot;Client_ForceCamRot&quot;,			l_Client_ForceCamRot);
+	//lua_register(L,&quot;Client_CameraLookAt&quot;,			l_Client_CameraLookAt);
+	//lua_register(L,&quot;Client_SetPlayerShip&quot;,			l_Client_SetPlayerShip);
+	//lua_register(L,&quot;Client_SetMaxFPS&quot;,				l_Client_SetMaxFPS);
+	//lua_register(L,&quot;Client_GetMaxFPS&quot;,				l_Client_GetMaxFPS);
+	lua_register(L,&quot;Client_GetCurFPS&quot;,				l_Client_GetCurFPS);
+	lua_register(L,&quot;Client_GetFrameNum&quot;,			l_Client_GetFrameNum);
+	//lua_register(L,&quot;Client_SetMouseSensitivity&quot;,	l_Client_SetMouseSensitivi=
ty);
+	//lua_register(L,&quot;Client_SetInvertMouse&quot;,			l_Client_SetInvertMouse);
+	//lua_register(L,&quot;Client_ShowMessage&quot;,			l_Client_ShowMessage);
+	lua_register(L,&quot;Client_GetTicks&quot;,				l_Client_GetTicks);
+	lua_register(L,&quot;Client_SetSkybox&quot;,				l_Client_SetSkybox);
+	lua_register(L,&quot;Client_SetFog&quot;,					l_Client_SetFog);
+	lua_register(L,&quot;Client_RenderOneFrame&quot;,			l_Client_RenderOneFrame);
+	lua_register(L,&quot;Client_Sleep&quot;,					l_Client_Sleep);
+	lua_register(L,&quot;Client_USleep&quot;,					l_Client_USleep);
+	lua_register(L,&quot;Client_SetAmbientLight&quot;,		l_Client_SetAmbientLight);
+	lua_register(L,&quot;Client_ClearLights&quot;,			l_Client_ClearLights);
+	lua_register(L,&quot;Client_AddPointLight&quot;,			l_Client_AddPointLight);
+	lua_register(L,&quot;Client_AddDirectionalLight&quot;,	l_Client_AddDirectionalLight=
);
+	lua_register(L,&quot;Client_GetPhysStepTime&quot;,		l_Client_GetPhysStepTime);
+	lua_register(L,&quot;BuildTerrainEntity_Simple&quot;,		l_BuildTerrainEntity_Simple);
+	lua_register(L,&quot;BuildTerrainEntity_Shaded&quot;,		l_BuildTerrainEntity_Shaded);
+	lua_register(L,&quot;TerrainRayPick&quot;,				l_TerrainRayPick);
+	lua_register(L,&quot;SphereRayPick&quot;,					l_SphereRayPick);
+	lua_register(L,&quot;UnloadMeshName&quot;,				l_UnloadMeshName);
+	lua_register(L,&quot;CountMeshTriangles&quot;,			l_CountMeshTriangles);
+	lua_register(L,&quot;GetUOPath&quot;,						l_getUOPath);
+	lua_register(L,&quot;PathSearch&quot;,					l_PathSearch);
+	lua_register(L,&quot;file_exists&quot;,					l_file_exists);
+	lua_register(L,&quot;file_size&quot;,						l_file_size);
+	lua_register(L,&quot;Hex2Num&quot;,						l_Hex2Num);
+	lua_register(L,&quot;GetRandomHexString&quot;,			l_GetRandomHexString);
+	lua_register(L,&quot;BitwiseAND&quot;,					l_BitwiseAND);
+	lua_register(L,&quot;BitwiseOR&quot;,						l_BitwiseOR);
+	lua_register(L,&quot;BitwiseXOR&quot;,					l_BitwiseXOR);
+	lua_register(L,&quot;BitwiseSHL&quot;,					l_BitwiseSHL);
+	lua_register(L,&quot;BitwiseSHR&quot;,					l_BitwiseSHR);
+	lua_register(L,&quot;TestBit&quot;,						l_TestBit);
+	lua_register(L,&quot;SetBit&quot;,						l_SetBit);
+	lua_register(L,&quot;ClearBit&quot;,						l_ClearBit);
+	lua_register(L,&quot;Exit&quot;,							l_Exit);
+	lua_register(L,&quot;Crash&quot;,							l_Crash);
+	lua_register(L,&quot;CrashSegFault&quot;,					l_CrashSegFault);
+	lua_register(L,&quot;DisplayNotice&quot;,					l_DisplayNotice);
+	lua_register(L,&quot;FatalErrorMessage&quot;,				l_FatalErrorMessage);
+	lua_register(L,&quot;ExportMesh&quot;,					l_ExportMesh);
+	lua_register(L,&quot;CreateSceneManager&quot;,			l_CreateSceneManager);
+	lua_register(L,&quot;GetUniqueName&quot;,					l_GetUniqueName);
+	lua_register(L,&quot;GetMouseRay&quot;,					l_GetMouseRay);
+	lua_register(L,&quot;GetMaxZ&quot;,						l_GetMaxZ);
+	lua_register(L,&quot;ProjectPos&quot;,					l_ProjectPos);
+	lua_register(L,&quot;ProjectSizeAndPos&quot;,				l_ProjectSizeAndPos);
+	lua_register(L,&quot;_TRACEBACK&quot;,					l_TRACEBACK);
+	lua_register(L,&quot;ProfileDumpCallCount&quot;,			l_ProfileDumpCallCount);
+	lua_register(L,&quot;OgreMemoryUsage&quot;,				l_OgreMemoryUsage);
+	lua_register(L,&quot;OgreMeshAvailable&quot;,				l_OgreMeshAvailable);
+	lua_register(L,&quot;OgreMaterialNameKnown&quot;,			l_OgreMaterialNameKnown);
+	lua_register(L,&quot;OgreMaterialAvailable&quot;,			l_OgreMaterialAvailable);
+	lua_register(L,&quot;OgreTextureAvailable&quot;,			l_OgreTextureAvailable);
+	lua_register(L,&quot;OgreMeshTextures&quot;,				l_OgreMeshTextures);
+	// some statistic stuff
+	lua_register(L,&quot;OgreLastFPS&quot;,				l_OgreLastFPS);
+	lua_register(L,&quot;OgreAvgFPS&quot;,				l_OgreAvgFPS);
+	lua_register(L,&quot;OgreBestFPS&quot;,				l_OgreBestFPS);
+	lua_register(L,&quot;OgreWorstFPS&quot;,				l_OgreWorstFPS);
+	lua_register(L,&quot;OgreBestFrameTime&quot;,			l_OgreBestFrameTime);
+	lua_register(L,&quot;OgreWorstFrameTime&quot;,			l_OgreWorstFrameTime);
+	lua_register(L,&quot;OgreTriangleCount&quot;,			l_OgreTriangleCount);
+	lua_register(L,&quot;OgreBatchCount&quot;,			l_OgreBatchCount);
+
+	lua_register(L,&quot;CreateGrannyHuedTexture&quot;,		l_CreateGrannyHuedTexture);
+	lua_register(L,&quot;HueMesh&quot;,						l_HueMesh);
+	lua_register(L,&quot;OgreAddCompositor&quot;,						l_OgreAddCompositor);
+	lua_register(L,&quot;OgreRemoveCompositor&quot;,						l_OgreRemoveCompositor);
+	lua_register(L,&quot;CreateLookupTableFromFile&quot;,			l_CreateLookupTableFromFile=
);
+	lua_register(L,&quot;Uo16Color2Rgb&quot;,			l_Uo16Color2Rgb);
+	// shadow stuff
+	lua_register(L,&quot;OgreShadowTechnique&quot;,				l_OgreShadowTechnique);
+	lua_register(L,&quot;OgreAmbientLight&quot;,				l_OgreAmbientLight);
+
+	// file paths for init
+	const char* szLuaUDataPath =3D &quot;../data/lua/udata.lua&quot;;
+	const char* szLuaMainPath =3D &quot;../data/lua/main.lua&quot;;
+
+
+	// check if lua files exist (otherwise working directory probably wrong)
+	std::ifstream myFileStream(szLuaMainPath);
+	if (!myFileStream) {
+		MyCrash(strprintf(&quot;%s cannot be found, probably the working directory is=
 wrong&quot;,szLuaMainPath).c_str());
+		exit(34);
+	}
+	myFileStream.close();
+	=

+	// load utils
+	int res;
+	res	=3D lua_dofile(L,szLuaUDataPath); // loads function used for register=
ing udatatypes
+	if (res) { =

+		MyCrash(&quot;error in udata script-initialisation\n&quot;); =

+		exit(44); =

+	}
+
+	RegisterLuaXML(L);
+	LuaRegisterFIFO(L);
+	LuaRegisterNet(L);
+	cGfx3D::LuaRegister(L);
+	cGfx2D::LuaRegister(L);
+	cDialog::LuaRegister(L);
+	cWidget::LuaRegister(L);
+	cBitMask::LuaRegister(L);
+	cCamera::LuaRegister(L);
+	cViewport::LuaRegister(L);
+	cRenderTexture::LuaRegister(L);
+	cSoundSource::LuaRegister(L);
+	cSpriteManager::LuaRegister(L);
+	cManualArtMaterialLoader::LuaRegister(L);
+	cSprite::LuaRegister(L);
+	Material_LuaRegister(L);
+	Granny_LuaRegister(L);
+	LuaRegisterData(L);
+	LuaRegisterBuilder(L);
+	LuaRegisterRadar(L);
+
+	cInput::GetSingleton().RegisterListener(this,kListenerBinding_Keys);
+
+	res =3D lua_dofile(L,szLuaMainPath);
+	if (res) {
+		MyCrash(&quot;error in main script-initialisation\n&quot;); =

+		exit(-1); =

+	}
+}
+
+cScripting::~cScripting	() { PROFILE
+	cInput::GetSingleton().UnRegisterListener(this,kListenerBinding_Keys);
+
+	assert(L);
+	lua_setgcthreshold(L, 0);  // collected garbage
+	lua_close(L);
+	L =3D 0;
+}

Modified: trunk/vc8/iris.vcproj
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/vc8/iris.vcproj (original)
+++ trunk/vc8/iris.vcproj Mon Jun 11 00:35:06 2007
@@ -38,7 +38,7 @@
 			&lt;Tool
 				Name=3D&quot;VCCLCompilerTool&quot;
 				Optimization=3D&quot;0&quot;
-				AdditionalIncludeDirectories=3D&quot;&quot;$(INCLUDE)&quot;;&quot;$(OGRE_HO=
ME)\include\&quot;;&quot;$(OGRE_HOME)\include\OIS&quot;;..\include;..\inclu=
de\boost;..\include\fmod;..\include\lua;..\include\sdl;..\include\zlib&quot;
+				AdditionalIncludeDirectories=3D&quot;&quot;C:\Programme\Microsoft Platform =
SDK\Include\&quot;;&quot;$(INCLUDE)&quot;;&quot;$(OGRE_HOME)\include\&quot;=
;&quot;$(OGRE_HOME)\include\OIS&quot;;..\include;..\include\boost;..\includ=
e\fmodx;..\include\lua;..\include\sdl;..\include\zlib&quot;
 				PreprocessorDefinitions=3D&quot;WIN32&quot;
 				RuntimeLibrary=3D&quot;1&quot;
 				RuntimeTypeInfo=3D&quot;false&quot;
@@ -57,11 +57,11 @@
 			/&gt;
 			&lt;Tool
 				Name=3D&quot;VCLinkerTool&quot;
-				AdditionalDependencies=3D&quot;AdvAPI32.Lib ws2_32.lib OgreMain_d.lib OIS_d=
.lib zlibd.lib LibLua.lib LibLuaLib.lib SDL.lib fmodvc.lib&quot;
+				AdditionalDependencies=3D&quot;AdvAPI32.Lib User32.Lib zlibd.lib ws2_32.lib=
 LibLua.lib LibLuaLib.lib OgreMain_d.lib SDL.lib OIS_d.lib fmodex_vc.lib&quot;
 				OutputFile=3D&quot;$(OutDir)\..\..\bin\$(ProjectName)_d.exe&quot;
-				AdditionalLibraryDirectories=3D&quot;&quot;$(LIB)&quot;;&quot;$(OGRE_HOME)\=
lib\&quot;;..\libs\fmod;..\libs\lua;..\libs\sdl;..\libs\zlib&quot;
+				AdditionalLibraryDirectories=3D&quot;&quot;C:\Programme\Microsoft Platform =
SDK\Lib\&quot;;&quot;$(LIB)&quot;;&quot;$(OGRE_HOME)\lib\&quot;;..\libs\fmo=
dx;..\libs\lua;..\libs\sdl;..\libs\zlib&quot;
 				IgnoreAllDefaultLibraries=3D&quot;false&quot;
-				IgnoreDefaultLibraryNames=3D&quot;LIBCMTD.lib&quot;
+				IgnoreDefaultLibraryNames=3D&quot;LIBCMT.lib;LIBCMTD.lib&quot;
 				GenerateDebugInformation=3D&quot;true&quot;
 				AssemblyDebug=3D&quot;0&quot;
 				GenerateMapFile=3D&quot;false&quot;
@@ -145,7 +145,7 @@
 			/&gt;
 			&lt;Tool
 				Name=3D&quot;VCLinkerTool&quot;
-				AdditionalDependencies=3D&quot;zlib.lib LIBCMT.lib LIBCPMT.LIB User32.Lib A=
dvAPI32.Lib ws2_32.lib LibLua+CRT.lib LibLuaLib+CRT.lib OgreMain.lib SDL.li=
b OIS.lib fmodex_vc.lib&quot;
+				AdditionalDependencies=3D&quot;LIBCMT.lib LIBCPMT.LIB AdvAPI32.Lib User32.L=
ib zlib.lib ws2_32.lib LibLua+CRT.lib LibLuaLib+CRT.lib OgreMain.lib SDL.li=
b OIS.lib fmodex_vc.lib&quot;
 				OutputFile=3D&quot;$(OutDir)\..\..\bin\iris2.exe&quot;
 				AdditionalLibraryDirectories=3D&quot;&quot;C:\Programme\Microsoft Platform =
SDK\Lib\&quot;;&quot;$(OGRE_HOME)\lib\&quot;;..\libs\fmodx;..\libs\zlib;..\=
libs\sdl;..\libs\lua&quot;
 				GenerateManifest=3D&quot;true&quot;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000001.html">[Iris-commit] [IRIS] r1185 - /trunk/data/lua/lib.data.lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#0">[ date ]</a>
              <a href="thread.html#0">[ thread ]</a>
              <a href="subject.html#0">[ subject ]</a>
              <a href="author.html#0">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/iris-commit">More information about the Iris-commit
mailing list</a><br>
</body></html>
