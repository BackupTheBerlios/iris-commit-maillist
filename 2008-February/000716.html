<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Iris-commit] [IRIS] r1904 - in /trunk: bin/iris2.exe lua/filter/filter.granny.lua lua/gui/gui.hotbar.lua lua/lib.gfm.lua lua/lib.gumpparser.lua lua/lib.uodragdrop.lua lua/net/net.mobile.lua lua/net/net.other.lua
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/iris-commit/2008-February/index.html" >
   <LINK REL="made" HREF="mailto:iris-commit%40lists.berlios.de?Subject=Re%3A%20%5BIris-commit%5D%20%5BIRIS%5D%20r1904%20-%20in%20/trunk%3A%20bin/iris2.exe%0A%20lua/filter/filter.granny.lua%20lua/gui/gui.hotbar.lua%20lua/lib.gfm.lua%0A%20lua/lib.gumpparser.lua%20lua/lib.uodragdrop.lua%20lua/net/net.mobile.lua%0A%20lua/net/net.other.lua&In-Reply-To=%3C20080213230931.4DFC51C186F1%40zwischenwelt.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000715.html">
   <LINK REL="Next"  HREF="000717.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Iris-commit] [IRIS] r1904 - in /trunk: bin/iris2.exe lua/filter/filter.granny.lua lua/gui/gui.hotbar.lua lua/lib.gfm.lua lua/lib.gumpparser.lua lua/lib.uodragdrop.lua lua/net/net.mobile.lua lua/net/net.other.lua</H1>
    <B>no-reply at zwischenwelt.org</B> 
    <A HREF="mailto:iris-commit%40lists.berlios.de?Subject=Re%3A%20%5BIris-commit%5D%20%5BIRIS%5D%20r1904%20-%20in%20/trunk%3A%20bin/iris2.exe%0A%20lua/filter/filter.granny.lua%20lua/gui/gui.hotbar.lua%20lua/lib.gfm.lua%0A%20lua/lib.gumpparser.lua%20lua/lib.uodragdrop.lua%20lua/net/net.mobile.lua%0A%20lua/net/net.other.lua&In-Reply-To=%3C20080213230931.4DFC51C186F1%40zwischenwelt.org%3E"
       TITLE="[Iris-commit] [IRIS] r1904 - in /trunk: bin/iris2.exe lua/filter/filter.granny.lua lua/gui/gui.hotbar.lua lua/lib.gfm.lua lua/lib.gumpparser.lua lua/lib.uodragdrop.lua lua/net/net.mobile.lua lua/net/net.other.lua">no-reply at zwischenwelt.org
       </A><BR>
    <I>Thu Feb 14 00:09:31 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000715.html">[Iris-commit] [IRIS] r1903 - in /trunk: data/config.lua.dist lua/lib.3d.map.lua lua/lib.terrain.multitex.lua
</A></li>
        <LI>Next message: <A HREF="000717.html">[Iris-commit] [IRIS] r1905 - in /trunk: data/ data/guis/naked/ lua/
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#716">[ date ]</a>
              <a href="thread.html#716">[ thread ]</a>
              <a href="subject.html#716">[ subject ]</a>
              <a href="author.html#716">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: sience
Date: Thu Feb 14 00:09:30 2008
New Revision: 1904

Log:
-new w32 binary
-gumpparser enhanced (position of gumps is now save)
-some bugfixes
-cougars filter added to filter.granny.lua

Modified:
    trunk/bin/iris2.exe
    trunk/lua/filter/filter.granny.lua
    trunk/lua/gui/gui.hotbar.lua
    trunk/lua/lib.gfm.lua
    trunk/lua/lib.gumpparser.lua
    trunk/lua/lib.uodragdrop.lua
    trunk/lua/net/net.mobile.lua
    trunk/lua/net/net.other.lua

Modified: trunk/bin/iris2.exe
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
Binary files - no diff available.

Modified: trunk/lua/filter/filter.granny.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/lua/filter/filter.granny.lua (original)
+++ trunk/lua/filter/filter.granny.lua Thu Feb 14 00:09:30 2008
@@ -24,6 +24,19 @@
 	return nil
 end
 =

+function GrannySkeletonOverride(bodyid)
+	if (gGrannyFilter[bodyid]) then
+		if (gGrannyFilter[bodyid].skeleton) then
+			printdebug(&quot;granny&quot;,&quot;OverrideSkeleton: GrannyID to Skeleton &quot;,bodyid,&quot; =
-&gt; &quot;,gGrannyFilter[bodyid].skeleton)
+			return gGrannyFilter[bodyid].skeleton
+		end
+	end
+	return nil
+end
+
+-- custom models can be applyed instead to grannys, just tell the meshname
+--gGrannyFilter[220]	=3D{meshname=3D&quot;Lich.mesh&quot;}
+
 gGrannyFilter[987]	=3D{grannyid=3D400}
 gGrannyFilter[1987]	=3D{grannyid=3D401}
 gGrannyFilter[778]	=3D{grannyid=3D16}
@@ -34,31 +47,78 @@
 =

 --[[
 -- wrong animations - but raw model is displayed correct, so no animation =
should be played
-gGrannyFilter[46]	=3D{animbroken}	--mf_dragon_rust
-gGrannyFilter[122]	=3D{animbroken}	--equines_unicorn
-gGrannyFilter[192]	=3D{animbroken}	--equines_unicorn_ethereal
-gGrannyFilter[791]	=3D{animbroken}	--giant_beetle
-gGrannyFilter[195]	=3D{animbroken}	--giant_beetle_ethereal
-gGrannyFilter[30]	=3D{animbroken}	--harpies_harpy
-gGrannyFilter[73]	=3D{animbroken}	--harpies_harpy_stone
-gGrannyFilter[797]	=3D{animbroken}	--red dragon
-gGrannyFilter[798]	=3D{animbroken}	--blue dragon
-gGrannyFilter[39]	=3D{animbroken}
-gGrannyFilter[194]	=3D{animbroken}	--rideable dragon
-gGrannyFilter[312]	=3D{animbroken}
-gGrannyFilter[313]	=3D{animbroken}
-gGrannyFilter[314]	=3D{animbroken}
-gGrannyFilter[315]	=3D{animbroken}
-gGrannyFilter[316]	=3D{animbroken}
-gGrannyFilter[789]	=3D{animbroken}
-gGrannyFilter[169]	=3D{animbroken}
+gGrannyFilter[46]	=3D{animbroken}	-- mf_dragon_rust ( Completely broken )
+gGrannyFilter[122]	=3D{animbroken}	-- equines_unicorn ( Completely broken )
+gGrannyFilter[192]	=3D{animbroken}	-- equines_unicorn_ethereal ( Completel=
y broken )
+gGrannyFilter[791]	=3D{animbroken}	-- giant_beetle ( Completely broken )
+gGrannyFilter[195]	=3D{animbroken}	-- giant_beetle_ethereal ( Completely b=
roken )
+gGrannyFilter[30]	=3D{animbroken}	-- harpies_harpy ( Completely broken )
+gGrannyFilter[73]	=3D{animbroken}	-- harpies_harpy_stone ( Completely brok=
en )
+gGrannyFilter[797]	=3D{animbroken}	-- red dragon ( Completely broken )
+gGrannyFilter[798]	=3D{animbroken}	-- blue dragon ( Completely broken )
+gGrannyFilter[39]	=3D{animbroken}	-- ?? ( Completely broken )
+gGrannyFilter[194]	=3D{animbroken}	-- rideable dragon
+gGrannyFilter[312]	=3D{animbroken}	-- Completely broken
+gGrannyFilter[313]	=3D{animbroken}	-- Completely broken/Offset
+gGrannyFilter[314]	=3D{animbroken}	-- Completely broken
+gGrannyFilter[315]	=3D{animbroken}	-- Completely broken
+gGrannyFilter[316]	=3D{animbroken}	-- Completely broken
+gGrannyFilter[789]	=3D{animbroken}	-- size/wrong z
+gGrannyFilter[169]	=3D{animbroken}	-- Completely broken
 =

 -- nogfx
-gGrannyFilter[786]	=3D{animbroken}	--chariot (no gfx)
-gGrannyFilter[58]	=3D{animbroken}	--etherals_wisp (no gfx)
-gGrannyFilter[164]	=3D{animbroken}	--etherals_energy_vortex (no gfx)
-gGrannyFilter[165]	=3D{animbroken}	--etherals_wisp (no gfx)
+gGrannyFilter[786]	=3D{animbroken}	-- chariot (no gfx)
+gGrannyFilter[58]	=3D{animbroken}	-- etherals_wisp (no gfx)
+gGrannyFilter[164]	=3D{animbroken}	-- etherals_energy_vortex (no gfx)
+gGrannyFilter[165]	=3D{animbroken}	-- etherals_wisp (no gfx)
 ]]--
 =

--- custom models can be applyed instead to grannys, just tell the meshname
---gGrannyFilter[220]	=3D{meshname=3D&quot;Lich.mesh&quot;}
+--[[
+ArtID:
+221				=

+212
+213
+167
+97
+98
+225
+99
+23
+25
+27
+100
+34
+37
+38 (invisible)
+84
+85
+2
+18
+765
+770
+767 (wrong z)
+769 (wrong z)
+772 (wrong z)
+773
+17
+41
+181
+182
+775
+840 (Invis/Missing)
+841 (Invis/Missing)
+842 (Invis/Missing)
+790 (Invis/Missing)
+152
+70
+71
+72
+319 =

+777
+785 (upside down)
+788 (size)
+247
+261 (Invis/Missing)
+273 (Invis/Missing)
+276
+]]--

Modified: trunk/lua/gui/gui.hotbar.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/lua/gui/gui.hotbar.lua (original)
+++ trunk/lua/gui/gui.hotbar.lua Thu Feb 14 00:09:30 2008
@@ -9,14 +9,13 @@
 		=

 function ToggleHotbar ()
 	if (gHotbarDialog) then
-		-- store current positoin
+		-- store current position
 		gHotbarDialog_LastPositionX, gHotbarDialog_LastPositionY =3D gHotbarDial=
og.rootwidget.gfx:GetPos()
 		-- and close
 		gHotbarDialog:Close()
 	else
 		-- ..........do something before hotbar creation (get spells/items ?!)
-		print(&quot;create hotbar&quot;)
-		gHotbarDialog =3D guimaker.MyCreateDialog()
+		gHotbarDialog =3D guimaker.MakeSortedDialog()	--guimaker.MyCreateDialog()
 		gHotbarDialog.rootwidget =3D guimaker.MakePlane(gHotbarDialog,gNewGuiSty=
le..&quot;/hotbar&quot;,0,0,515,65)
 =

 		-- restore last positoin if available
@@ -37,7 +36,6 @@
 		end
 =

 		dialog.onMouseDown =3D function (widget,mousebutton)
-			--if (mousebutton =3D=3D 2) then widget.dialog:Close() end
 			if (mousebutton =3D=3D 1) then widget.dialog:BringToFront() gui.StartMo=
veDialog(widget.dialog.rootwidget) end
 		end
 =


Modified: trunk/lua/lib.gfm.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/lua/lib.gfm.lua (original)
+++ trunk/lua/lib.gfm.lua Thu Feb 14 00:09:30 2008
@@ -174,13 +174,15 @@
 	return widget
 end
 =

+-- Obsolete, only for testing
+--[[
 gGumpTestIndex =3D (hex2num(&quot;0xA28&quot;))
 function GumpTestAdd (i) =

 	gGumpTestIndex =3D gGumpTestIndex + i
 	=

 	if (gGumpTestDlg.widget) then
 		gGumpTestDlg.widget:Destroy()
-		gGumpTestDlg.widget =3D false
+		gGumpTestDlg.widget =3D nil
 	end
 	=

 	local testmat =3D gGumpLoader:CreateMaterial(gGumpTestIndex)
@@ -194,6 +196,7 @@
 		widget.gfx:SetAlignment(kGfx2DAlign_Center,kGfx2DAlign_Center)
 	end
 end
+]]--
 =

 function CreateGumpDlgFromGfm (path) =

 	local dialog =3D guimaker.MakeSortedDialog()
@@ -267,6 +270,8 @@
 	end
 end
 =

+-- Obsolete, only for testing
+--[[
 function GfmDump (path)
 	print(&quot;GfmDump&quot;,path)
 	local formnode =3D xmlchild(LuaXML_ParseFile(path),&quot;form&quot;)
@@ -304,4 +309,4 @@
 		end
 	end end
 end
-
+]]--

Modified: trunk/lua/lib.gumpparser.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/lua/lib.gumpparser.lua (original)
+++ trunk/lua/lib.gumpparser.lua Thu Feb 14 00:09:30 2008
@@ -8,12 +8,11 @@
 Description:  Similar to xmfhtmlgumpcolor command, but the parameter order=
 is different and an additionally [argument]
 entry enclosed with @'s can be used. With this you can specify texts that =
will be added to the CliLoc entry.
 ]]--
-gXGumppos=3D0
-gYGumppos=3D0
 =

 gHorizontal_Textcorrection=3D5
 =

 gServerSideGump =3D {}
+gGumpPosition =3D {}
 =

 function ServerSideGump_GetParams (dialogId)
 	local params =3D {}
@@ -34,375 +33,382 @@
 =

 function CloseServerSideGump (playerId, dialogId, buttonId)
 	if (buttonId) then
-		print(&quot;CloseServerSideGump dialogId=3D&quot;..dialogId..&quot; buttonId=3D&quot;..butto=
nId)
+		printdebug(&quot;gump&quot;,&quot;CloseServerSideGump dialogId=3D&quot;..dialogId..&quot; buttonI=
d=3D&quot;..buttonId)
 	else
-		print(&quot;CloseServerSideGump dialogId=3D&quot;..dialogId..&quot; buttonId=3Dnil&quot;)
+		printdebug(&quot;gump&quot;,&quot;CloseServerSideGump dialogId=3D&quot;..dialogId..&quot; buttonI=
d=3Dnil&quot;)
 	end
 	=

 	local dialog =3D gServerSideGump[dialogId]
-	if (not dialog) then print(&quot;CloseServerSideGump : dialog not found=3D&quot;,di=
alogId) return end
+	if (not dialog) then printdebug(&quot;gump&quot;,&quot;CloseServerSideGump : dialog not =
found=3D&quot;,dialogId) return end
 	=

 	local params =3D ServerSideGump_GetParams(dialogId)
+	GumpReturnMsg(playerId, dialogId, buttonId, params)
+	=

+	--print(&quot;CloseServerSideGump:dialogID=3D&quot;..dialogId)
 	dialog:Close()
-	GumpReturnMsg(playerId, dialogId, buttonId, params)
 end
 =

---gGumpPositions[serial] =3D { x=3Dwidget.gfx:GetDerivedLeft() , y=3Dwidge=
t.gfx:GetDerivedTop() }  z.b.
 function GumpParser(Gumpdata)
+	if (not gGumpLoader) then return end
+
+	-- close already existing dialog with the same id
+	if gServerSideGump[Gumpdata.dialogId] then
+		CloseServerSideGump(Gumpdata.playerid, Gumpdata.dialogId, 0)
+	end
+
+	-- create new Dialog
 	local dialog =3D guimaker.MakeSortedDialog()
+	--print(&quot;create gump&quot;)
+
+	-- set Dialog ID / Serial
+	dialog.dialogId =3D Gumpdata.dialogId
+	--print(&quot;dialogID=3D&quot;..dialog.dialogId)
+
 	dialog.Close =3D function (dialog)
-        -- TODO : close this properly, destroy widgets etc... =

+	--print(&quot;Close:dialogID=3D&quot;..dialog.dialogId)
+		gGumpPosition[dialog.dialogId] =3D { x=3Ddialog.rootwidget.gfx:GetDerive=
dLeft() , y=3Ddialog.rootwidget.gfx:GetDerivedTop() }
         dialog:SetVisible(false)
 		gServerSideGump[dialog.dialogId] =3D nil
+		dialog:Destroy()
 		dialog =3D nil
-	end
-	dialog.dialogId =3D Gumpdata.dialogId
-	=

-	-- close already existing dialog with the same id
-	if gServerSideGump[dialog.dialogId] then
-		CloseServerSideGump(Gumpdata.playerid, Gumpdata.dialogId, 0)
-	end
-	=

-	gServerSideGump[dialog.dialogId] =3D dialog
-	=

-	if (gGumpLoader) then
-		dialog.rootwidget.gfx:SetPos(gXGumppos or Gumpdata.x,gYGumppos or Gumpda=
ta.y)
-		dialog.controls =3D {} -- associative list of controlls, key=3Dname of c=
ontroll
-		dialog.childs =3D {} -- all controls, also those without name
-		dialog.uo_radio =3D {}
-		dialog.uo_check =3D {}
-		dialog.uo_text =3D {}
-
-		dialog.onMouseDown =3D function (widget,mousebutton)
-               					if (mousebutton =3D=3D 2) then
-									CloseServerSideGump(Gumpdata.playerid, Gumpdata.dialogId, 0)
-               					end
-               					if (mousebutton =3D=3D 1) then widget.dialog:BringToFr=
ont() gui.StartMoveDialog(widget.dialog.rootwidget) end
-               				end
-        dialog.onMouseUp =3D function (widget,mousebutton)
-									gXGumppos=3Dwidget.gfx:GetDerivedLeft()
-									gYGumppos=3Dwidget.gfx:GetDerivedTop()
-       						end
-		-- hide all except page 0 and pagenum
-		dialog.ShowPage =3D function (dialog,pagenum) =

-			local myc =3D 0
-			for k,widget in pairs(dialog.childs) do if (widget.pagenum =3D=3D pagen=
um) then myc =3D myc + 1 end end
-			print(&quot;dialog.ShowPage&quot;,pagenum,myc)
+		--print(&quot;close / destory gump&quot;)
+	end
+
+	dialog.controls =3D {} -- associative list of controlls, key=3Dname of co=
ntroll
+	dialog.childs =3D {} -- all controls, also those without name
+	dialog.uo_radio =3D {}
+	dialog.uo_check =3D {}
+	dialog.uo_text =3D {}
+
+	dialog.onMouseDown =3D function (widget,mousebutton)
+		if (mousebutton =3D=3D 2) then CloseServerSideGump(Gumpdata.playerid, Gu=
mpdata.dialogId, 0) end
+		if (mousebutton =3D=3D 1) then widget.dialog:BringToFront() gui.StartMov=
eDialog(widget.dialog.rootwidget) end
+	end
+
+	-- hide all except page 0 and pagenum
+	dialog.ShowPage =3D function (dialog,pagenum) =

+		local myc =3D 0
+		for k,widget in pairs(dialog.childs) do if (widget.pagenum =3D=3D pagenu=
m) then myc =3D myc + 1 end end
+		printdebug(&quot;gump&quot;,&quot;dialog.ShowPage&quot;,pagenum,myc)
 			=

-			for k,widget in pairs(dialog.childs) do =

-				widget.gfx:SetVisible((widget.pagenum =3D=3D 0) or (widget.pagenum =3D=
=3D pagenum))
-			end
-		end
-		local curparent =3D dialog.rootwidget
-
+		for k,widget in pairs(dialog.childs) do =

+			widget.gfx:SetVisible((widget.pagenum =3D=3D 0) or (widget.pagenum =3D=
=3D pagenum))
+		end
+	end
 		=

-		local pages =3D {}
-		dialog.pages =3D pages
+	local pages =3D {}
+	dialog.pages =3D pages
 		=

-		-- Make a Standard Page 0 (like OSI does this)
-		local curpage =3D guimaker.MakePage(0)
-		pages[0] =3D curpage
-
-		-- read out and group all data by page first, as it can be in random ord=
er
-		local aToken=3Dstrsplit(&quot;{&quot;,Gumpdata.Data)
-		for k,v in pairs(aToken) do
-			local bToken =3D {}
-			for token in string.gfind(v, &quot;%w+&quot;) do table.insert(bToken,token) end
-			if (bToken[1]) then
-				local command =3D string.lower(bToken[1])
-				--Description:  Specifies which page to define. Page 0 is already pres=
ent and visible with all other Pages (1,2,3,etc) =

-				if ((command =3D=3D &quot;page&quot;) and (table.getn(bToken)&gt;=3D 2)) then
-					local pagenum=3Dtonumber(bToken[2])
-					curpage =3D pages[pagenum]
-					if (not curpage) then
-						curpage =3D guimaker.MakePage(pagenum)
-						pages[pagenum] =3D curpage
-					end
-				else
-					table.insert(curpage.tokenlists,bToken)
-				end
-			end
-		end
+	-- Make a Standard Page 0 (like OSI does this)
+	local curpage =3D guimaker.MakePage(0)
+	pages[0] =3D curpage
+
+	-- read out and group all data by page first, as it can be in random order
+	local aToken=3Dstrsplit(&quot;{&quot;,Gumpdata.Data)
+	for k,v in pairs(aToken) do
+		local bToken =3D {}
+		for token in string.gfind(v, &quot;%w+&quot;) do table.insert(bToken,token) end
+		if (bToken[1]) then
+			local command =3D string.lower(bToken[1])
+			--Description:  Specifies which page to define. Page 0 is already prese=
nt and visible with all other Pages (1,2,3,etc) =

+			if ((command =3D=3D &quot;page&quot;) and (table.getn(bToken)&gt;=3D 2)) then
+				local pagenum=3Dtonumber(bToken[2])
+				curpage =3D pages[pagenum]
+				if (not curpage) then
+					curpage =3D guimaker.MakePage(pagenum)
+					pages[pagenum] =3D curpage
+				end
+			else
+				table.insert(curpage.tokenlists,bToken)
+			end
+		end
+	end
+
+	-- set gumpposition
+	local gumpposition =3D gGumpPosition[Gumpdata.dialogId]
+	if (gumpposition) then
+		dialog.rootwidget.gfx:SetPos(gumpposition.x or 0, gumpposition.y or 0)
+	else
+		dialog.rootwidget.gfx:SetPos(Gumpdata.x or 0, Gumpdata.y or 0)
+	end
+
+	-- init pagenum of basic widgets =

+	for k,widget in pairs(dialog.childs) do widget.pagenum =3D 0 end
 		=

-		-- init pagenum of basic widgets =

-		for k,widget in pairs(dialog.childs) do widget.pagenum =3D 0 end
+	-- now construct widgets in an orderly per page fashion
+	local curparent =3D dialog.rootwidget
+	local pageorder =3D {}
+	for iCurPageNum,page in pairs(pages) do table.insert(pageorder,page.pagen=
um) end
+	table.sort(pageorder)
 		=

-		-- now construct widgets in an orderly per page fashion
-		local pageorder =3D {}
-		for iCurPageNum,page in pairs(pages) do table.insert(pageorder,page.page=
num) end
-		table.sort(pageorder)
-		=

-		for k,pagenum in pairs(pageorder) do
-			local page =3D pages[pagenum]
-			for k,bToken in pairs(page.tokenlists) do
-				local command =3D string.lower(bToken[1])
-
-				----------------------------------------------------------------------=
----------------------
-
-				if (command =3D=3D &quot;noclose&quot;) then
-					print(&quot;todo - Generic Gump Command: noclose&quot;)
-				elseif (command =3D=3D &quot;nomove&quot;) then
-					print(&quot;todo - Generic Gump Command: noclose&quot;)
-				elseif (command =3D=3D &quot;nodispose&quot;) then
-					print(&quot;todo - Generic Gump Command: nodispose&quot;)
-				elseif (command =3D=3D &quot;noresize&quot;) then
-					print(&quot;todo - Generic Gump Command: noresize&quot;)
-				--Group &lt;groupnumber&gt;
-				--Description:  Links radio buttons to a group. Group is send before r=
adiobuttons. Seems only to work on page 0 and 1.  =

-				elseif (command =3D=3D &quot;group&quot;) then
-					print(&quot;todo - Generic Gump Command: group&quot;)
-
-				----------------------------------------------------------------------=
----------------------
-
-				--resizepic &lt;x&gt; &lt;y&gt; &lt;gumpid&gt; &lt;width&gt; &lt;height&gt;
-				elseif ((command =3D=3D &quot;resizepic&quot;) and (table.getn(bToken)&gt;=3D 6)) t=
hen
---					print(&quot;x=3D&quot;..bToken[2]..&quot; y=3D&quot;..bToken[3]..&quot; gumpid=3D&quot;..bToken[4=
]..&quot; width=3D&quot;..bToken[5]..&quot; height=3D&quot;..bToken[6])
-					if (tonumber(bToken[4])~=3D0) then
-						local widgetarr =3D MakeBorderGump(curparent,bToken[4],bToken[2],bTo=
ken[3],bToken[5],bToken[6])
-						if (widgetarr) then
-							for k,widget in pairs(widgetarr) do
-								widget.mbIgnoreMouseOver =3D false
-							end
+	for k,pagenum in pairs(pageorder) do
+		local page =3D pages[pagenum]
+		for k,bToken in pairs(page.tokenlists) do
+			local command =3D string.lower(bToken[1])
+
+			-----------------------------------------------------------------------=
---------------------
+			if (command =3D=3D &quot;noclose&quot;) then
+				printdebug(&quot;gump&quot;,&quot;todo - Generic Gump Command: noclose&quot;)
+			elseif (command =3D=3D &quot;nomove&quot;) then
+				printdebug(&quot;gump&quot;,&quot;todo - Generic Gump Command: noclose&quot;)
+			elseif (command =3D=3D &quot;nodispose&quot;) then
+				printdebug(&quot;gump&quot;,&quot;todo - Generic Gump Command: nodispose&quot;)
+			elseif (command =3D=3D &quot;noresize&quot;) then
+				printdebug(&quot;gump&quot;,&quot;todo - Generic Gump Command: noresize&quot;)
+			--Group &lt;groupnumber&gt;
+			--Description:  Links radio buttons to a group. Group is send before ra=
diobuttons. Seems only to work on page 0 and 1.  =

+			elseif (command =3D=3D &quot;group&quot;) then
+				printdebug(&quot;gump&quot;,&quot;todo - Generic Gump Command: group&quot;)
+			-----------------------------------------------------------------------=
---------------------
+			--resizepic &lt;x&gt; &lt;y&gt; &lt;gumpid&gt; &lt;width&gt; &lt;height&gt;
+			elseif ((command =3D=3D &quot;resizepic&quot;) and (table.getn(bToken)&gt;=3D 6)) th=
en
+				printdebug(&quot;gump&quot;,&quot;x=3D&quot;..bToken[2]..&quot; y=3D&quot;..bToken[3]..&quot; gumpid=3D&quot;.=
.bToken[4]..&quot; width=3D&quot;..bToken[5]..&quot; height=3D&quot;..bToken[6])
+				if (tonumber(bToken[4])~=3D0) then
+					local widgetarr =3D MakeBorderGump(curparent,bToken[4],bToken[2],bTok=
en[3],bToken[5],bToken[6])
+					if (widgetarr) then
+						for k,widget in pairs(widgetarr) do
+							widget.mbIgnoreMouseOver =3D false
 						end
 					end
-				--xmfhtmlgump &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;Cliloc Message ID&gt; &lt;background=
&gt;<i> &lt;scrollbar&gt;
</I>-				--Description:	&lt;background&gt; and &lt;scrollbar&gt; can be 0 or 1 and define w=
hether the background is transparent and
-				--				a scrollbar s displayed.
-				-- TODO : width, height, background, scrollbar
-				elseif ((command =3D=3D &quot;xmfhtmlgump&quot;) and (table.getn(bToken)&gt;=3D 8))=
 then
-					local msg =3D HtmlParser( gClilocLoader and gClilocLoader:Get(bToken[=
6]) or &quot;no_cliloc&quot; )
---					print(&quot;Cliloc Msg (&quot;..bToken[6]..&quot;): &quot;..msg.text)
-					local widget =3D guimaker.MakeWrappedClippedText (curparent, bToken[2=
], bToken[3]+gHorizontal_Textcorrection,
-																	bToken[4], bToken[5], UnicodeFix(msg.text), msg.charh, {1=
.0,1.0,1.0,1.0},
-																	msg.center, msg.div, gFontNameDefault)
-				--xmfhtmlgumpcolor &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;cliloc-nr&gt; &lt;background&gt; &lt;=
scrollbar&gt; &lt;color&gt;
-				--Description:	&lt;background&gt; and &lt;scrollbar&gt; can be 0 or 1 and define w=
hether the background is transparent and
-				--				a scrollbar s displayed.
-				-- TODO : background, scrollbar, HUE-color
-				elseif ((command =3D=3D &quot;xmfhtmlgumpcolor&quot;) and (table.getn(bToken)&gt;=
=3D 9)) then
-					local msg =3D HtmlParser(  gClilocLoader and gClilocLoader:Get(bToken=
[6]) or &quot;no_cliloc&quot; )
---					print(&quot;Cliloc Msg (&quot;..bToken[6]..&quot;): &quot;..msg.text)
-					local widget =3D guimaker.MakeWrappedClippedText (curparent, bToken[2=
], bToken[3]+gHorizontal_Textcorrection,
-																	bToken[4], bToken[5], UnicodeFix(msg.text), msg.charh, {1=
.0,1.0,1.0,1.0},
-																	msg.center, msg.div, gFontNameDefault)
-				--gumppic &lt;x&gt; &lt;y&gt; &lt;gumpid&gt; [hue=3D353]
-				--Description:  Adds a graphic to the gump, where &lt;id&gt; ist the graphic=
 id of an item.
-				--				Optionaly there is a color parameter. =

-				-- TODO : HUE
-				elseif ((command =3D=3D &quot;gumppic&quot;) and (table.getn(bToken)&gt;=3D 4)) then
-					local huenumber=3DbToken[6] or 0
-					local widget =3D MakeBorderGumpPart( curparent, bToken[4], bToken[2],=
 bToken[3], 0, 0, 0, tonumber(huenumber) )
-					widget.mbIgnoreMouseOver =3D false
-					if (bToken[8]) then print(&quot;gumppic class=3D&quot;..bToken[8]) end
-				--gumppictiled &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;gumpid&gt;
-				--Description:  Similar to GumpPic, but the gumppic is tiled to the gi=
ven &lt;height&gt; and &lt;width&gt;.
-				elseif ((command =3D=3D &quot;gumppictiled&quot;) and (table.getn(bToken)&gt;=3D 6)=
) then
-					local widget =3D MakeBorderGumpPart(curparent, bToken[6], bToken[2], =
bToken[3], bToken[4], bToken[5])
-					widget.mbIgnoreMouseOver =3D false
-				--checkertrans &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt;
-				--Description:  Creates a transparent rectangle on position &lt;x,y&gt; usin=
g &lt;width&gt; and &lt;height&gt;.
-				elseif ((command =3D=3D &quot;checkertrans&quot;) and (table.getn(bToken)&gt;=3D 5)=
) then
-					--print(&quot;todo - checkertrans&quot;)
-				--text &lt;x&gt; &lt;y&gt; &lt;hue&gt; &lt;textline-id&gt;
-				--Description:  Defines the position and color of a text (data) entry.
-				-- TODO : HUE-color
-				elseif ((command =3D=3D &quot;text&quot;) and (table.getn(bToken)&gt;=3D 5)) then
-					local text =3D Gumpdata.textline[tonumber(bToken[5])] or &quot;No text&quot;
-					local widget =3D guimaker.MakeText (curparent, bToken[2], bToken[3]+g=
Horizontal_Textcorrection, UnicodeFix(text),
-														gFontGumpSize, {190/255,237/255,231/255,1.0}, gFontNameDefau=
lt)
-				--Button &lt;x&gt; &lt;y&gt; &lt;released-id&gt; &lt;pressed-id&gt; &lt;quit&gt; &lt;page-id&gt; &lt;return-v=
alue&gt;
-				--Description:  Adds a button to the gump with the specified coordinat=
es and button graphics.
-				--				&lt;released-id&gt; and &lt;pressed-id&gt; specify the buttongraphic. If pre=
ssed check for &lt;return-value&gt;.
-				--				Use &lt;page-id&gt; to switch between pages and &lt;quit&gt;=3D1/0 to close =
the gump.
-				elseif ((command =3D=3D &quot;button&quot;) and (table.getn(bToken)&gt;=3D 7)) then=
	-- &gt;=3D7 because pol buttons returns 7 or 8 arguments
-					local widget =3D MakeGumpButton (curparent,bToken[4],bToken[4],bToken=
[5],bToken[2],bToken[3],nil,nil,false)
-					if (bToken[8]) then widget.returnmsg =3D tonumber(bToken[8]) end
-					widget.page			=3D tonumber(bToken[7])
-					widget.onLeftClick =3D function (widget)
-											if (widget.returnmsg) then
-												print(&quot;Button pressed -&gt; Send button return_message: &quot;..widget=
.returnmsg)
-												GumpReturnMsg(Gumpdata.playerid, Gumpdata.dialogId, widget.ret=
urnmsg, ServerSideGump_GetParams(Gumpdata.dialogId))
+				end
+			--xmfhtmlgump &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;Cliloc Message ID&gt; &lt;background&gt;=
 &lt;scrollbar&gt;
+			--Description:	&lt;background&gt; and &lt;scrollbar&gt; can be 0 or 1 and define wh=
ether the background is transparent and
+			--				a scrollbar s displayed.
+			-- TODO : width, height, background, scrollbar
+			elseif ((command =3D=3D &quot;xmfhtmlgump&quot;) and (table.getn(bToken)&gt;=3D 8)) =
then
+				local msg =3D HtmlParser( gClilocLoader and gClilocLoader:Get(bToken[6=
]) or &quot;no_cliloc&quot; )
+				printdebug(&quot;gump&quot;,&quot;Cliloc Msg (&quot;..bToken[6]..&quot;): &quot;..msg.text)
+				local widget =3D guimaker.MakeWrappedClippedText (curparent, bToken[2]=
, bToken[3]+gHorizontal_Textcorrection,
+																bToken[4], bToken[5], UnicodeFix(msg.text), msg.charh, {1.=
0,1.0,1.0,1.0},
+																msg.center, msg.div, gFontNameDefault)
+			--xmfhtmlgumpcolor &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;cliloc-nr&gt; &lt;background&gt; &lt;s=
crollbar&gt; &lt;color&gt;
+			--Description:	&lt;background&gt; and &lt;scrollbar&gt; can be 0 or 1 and define wh=
ether the background is transparent and
+			--				a scrollbar s displayed.
+			-- TODO : background, scrollbar, HUE-color
+			elseif ((command =3D=3D &quot;xmfhtmlgumpcolor&quot;) and (table.getn(bToken)&gt;=3D=
 9)) then
+				local msg =3D HtmlParser(  gClilocLoader and gClilocLoader:Get(bToken[=
6]) or &quot;no_cliloc&quot; )
+				printdebug(&quot;gump&quot;,&quot;Cliloc Msg (&quot;..bToken[6]..&quot;): &quot;..msg.text)
+				local widget =3D guimaker.MakeWrappedClippedText (curparent, bToken[2]=
, bToken[3]+gHorizontal_Textcorrection,
+																bToken[4], bToken[5], UnicodeFix(msg.text), msg.charh, {1.=
0,1.0,1.0,1.0},
+																msg.center, msg.div, gFontNameDefault)
+			--gumppic &lt;x&gt; &lt;y&gt; &lt;gumpid&gt; [hue=3D353]
+			--Description:  Adds a graphic to the gump, where &lt;id&gt; ist the graphic =
id of an item.
+			--				Optionaly there is a color parameter. =

+			-- TODO : HUE
+			elseif ((command =3D=3D &quot;gumppic&quot;) and (table.getn(bToken)&gt;=3D 4)) then
+				local huenumber=3DbToken[6] or 0
+				local widget =3D MakeBorderGumpPart( curparent, bToken[4], bToken[2], =
bToken[3], 0, 0, 0, tonumber(huenumber) )
+				widget.mbIgnoreMouseOver =3D false
+				if (bToken[8]) then
+					printdebug(&quot;gump&quot;,&quot;gumppic class=3D&quot;..bToken[8])
+				end
+			--gumppictiled &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;gumpid&gt;
+			--Description:  Similar to GumpPic, but the gumppic is tiled to the giv=
en &lt;height&gt; and &lt;width&gt;.
+			elseif ((command =3D=3D &quot;gumppictiled&quot;) and (table.getn(bToken)&gt;=3D 6))=
 then
+				local widget =3D MakeBorderGumpPart(curparent, bToken[6], bToken[2], b=
Token[3], bToken[4], bToken[5])
+				widget.mbIgnoreMouseOver =3D false
+			--checkertrans &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt;
+			--Description:  Creates a transparent rectangle on position &lt;x,y&gt; using=
 &lt;width&gt; and &lt;height&gt;.
+			elseif ((command =3D=3D &quot;checkertrans&quot;) and (table.getn(bToken)&gt;=3D 5))=
 then
+				printdebug(&quot;gump&quot;,&quot;todo - checkertrans&quot;)
+			--text &lt;x&gt; &lt;y&gt; &lt;hue&gt; &lt;textline-id&gt;
+			--Description:  Defines the position and color of a text (data) entry.
+			-- TODO : HUE-color
+			elseif ((command =3D=3D &quot;text&quot;) and (table.getn(bToken)&gt;=3D 5)) then
+				local text =3D Gumpdata.textline[tonumber(bToken[5])] or &quot;No text&quot;
+				local widget =3D guimaker.MakeText (curparent, bToken[2], bToken[3]+gH=
orizontal_Textcorrection, UnicodeFix(text),
+													gFontGumpSize, {190/255,237/255,231/255,1.0}, gFontNameDefaul=
t)
+			--Button &lt;x&gt; &lt;y&gt; &lt;released-id&gt; &lt;pressed-id&gt; &lt;quit&gt; &lt;page-id&gt; &lt;return-va=
lue&gt;
+			--Description:  Adds a button to the gump with the specified coordinate=
s and button graphics.
+			--				&lt;released-id&gt; and &lt;pressed-id&gt; specify the buttongraphic. If pres=
sed check for &lt;return-value&gt;.
+			--				Use &lt;page-id&gt; to switch between pages and &lt;quit&gt;=3D1/0 to close t=
he gump.
+			elseif ((command =3D=3D &quot;button&quot;) and (table.getn(bToken)&gt;=3D 7)) then	=
-- &gt;=3D7 because pol buttons returns 7 or 8 arguments
+				local widget =3D MakeGumpButton (curparent,bToken[4],bToken[4],bToken[=
5],bToken[2],bToken[3],nil,nil,false)
+				if (bToken[8]) then widget.returnmsg =3D tonumber(bToken[8]) end
+				widget.page			=3D tonumber(bToken[7])
+				widget.onLeftClick =3D function (widget)
+										if (widget.returnmsg) then
+											printdebug(&quot;gump&quot;,&quot;Button pressed -&gt; Send button return_message=
:<i> &quot;..widget.returnmsg)
</I>+											GumpReturnMsg(Gumpdata.playerid, Gumpdata.dialogId, widget.retu=
rnmsg, ServerSideGump_GetParams(Gumpdata.dialogId))
+										end
+										if (widget.page &gt; 0 and not(widget.page &gt; table.getn(pages)) ) t=
hen
+											printdebug(&quot;gump&quot;,&quot;Parsegump Button: Switch to Page &quot;..widget.p=
age..&quot;/&quot;..table.getn(pages))
+											widget.dialog:ShowPage(widget.page)
+										else
+											widget.dialog:Close()
+										end
+									end
+			--buttontileart &lt;x&gt; &lt;y&gt; &lt;released-id&gt; &lt;pressed-id&gt; &lt;quit&gt; &lt;page-id&gt; &lt;re=
turn-value&gt; &lt;tilepic-id&gt; &lt;hue&gt; &lt;tile-x&gt; &lt;tile-y&gt;
+			--Client introduced: between 4.0.4d and 5.0.2b
+			--Description:  Adds a button to the gump with the specified coordinate=
s and tilepic as graphic.
+			--				&lt;tile-x&gt; and &lt;tile-y&gt; define the coordinates of the tile graphic =
and are relative to &lt;x&gt; and &lt;y&gt;.
+			--{ buttontileart 432 248 9010 9010 1 0 33 1352 0 100 20 }
+			elseif ((command =3D=3D &quot;buttontileart&quot;) and (table.getn(bToken)&gt;=3D 12=
)) then
+				local widget =3D MakeGumpButton (curparent,bToken[4],bToken[4],bToken[=
5],bToken[2],bToken[3])
+				local widgetart =3D MakeArtGumpPart (curparent,bToken[9],bToken[2]+bTo=
ken[11],bToken[3]+bToken[12],0,0,0,bToken[10])
+				if (bToken[8]) then widget.returnmsg =3D tonumber(bToken[8]) end
+				widget.page			=3D tonumber(bToken[7])
+				widget.onLeftClick =3D function (widget)
+										if (widget.returnmsg) then
+											printdebug(&quot;gump&quot;,&quot;Button pressed -&gt; Send buttontileart return_=
message: &quot;..widget.returnmsg)
+											GumpReturnMsg(Gumpdata.playerid, Gumpdata.dialogId, widget.retu=
rnmsg, ServerSideGump_GetParams(Gumpdata.dialogId))
+										end
+										if (widget.page &gt; 0 and not(widget.page &gt; table.getn(pages)) ) t=
hen
+											printdebug(&quot;gump&quot;,&quot;Parsegump Button: Switch to Page &quot;..widget.p=
age..&quot;/&quot;..table.getn(pages))
+											widget.dialog:ShowPage(widget.page)
+										else
+											widget.dialog:Close()
+										end
+									end
+			--textentry &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;hue&gt; &lt;return-value&gt; &lt;default-text=
-id&gt;
+			--Description:  Defines an area where the &lt;default-text-id&gt; is displaye=
d.
+			--				The player can modify this data. To get this data check the &lt;retu=
rn-value&gt;.
+			--TODO: HUE
+			elseif ((command =3D=3D &quot;textentry&quot;) and (table.getn(bToken)&gt;=3D 8)) th=
en
+				local widget =3D CreatePlainEditText (curparent, bToken[2], bToken[3],=
 bToken[4], bToken[5], {1.0,1.0,1.0,1.0})
+				local text =3D Gumpdata.textline[tonumber(bToken[8])] or &quot;No textentry&quot;
+				widget:SetText(UnicodeFix(text))
+
+				widget.mbIgnoreMouseOver =3D false
+				widget.returnmsg =3D tonumber(bToken[7])
+				widget.returndefid =3D tonumber(bToken[8])
+				widget.onMouseDown =3D function (widget,mousebutton)
+											if (mousebutton =3D=3D 1) then
+												widget:Activate()
 											end
-											if (widget.page &gt; 0 and not(widget.page &gt; table.getn(pages)) ) =
then
-												print(&quot;Parsegump Button: Switch to Page &quot;..widget.page..&quot;/&quot;..t=
able.getn(pages))
-												widget.dialog:ShowPage(widget.page)
+									   end
+				widget.onMouseLeave =3D function (widget)
+											widget:Deactivate()
+										end
+				table.insert(dialog.uo_text,widget)
+					=

+			--tilepic &lt;x&gt; &lt;y&gt; &lt;id&gt;
+			--Description:  Adds a Tilepicture to the gump. &lt;id&gt; defines the tile g=
raphic-id.
+			elseif ((command =3D=3D &quot;tilepic&quot;) and (table.getn(bToken)&gt;=3D4)) then
+				local widget =3D MakeArtGumpPart (curparent, bToken[4], bToken[2], bTo=
ken[3])
+			--TilePicHue &lt;x&gt; &lt;y&gt; &lt;id&gt; &lt;hue&gt;
+			--Description:  Similar to the tilepic command, but with an additional =
hue parameter.
+			-- TODO : HUE
+			elseif ((command =3D=3D &quot;tilepichue&quot;) and (table.getn(bToken)&gt;=3D5)) th=
en
+				local widget =3D MakeArtGumpPart (curparent, bToken[4], bToken[2], bTo=
ken[3], 0, 0, 0, bToken[5])
+			--croppedtext &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;color&gt; &lt;text-id&gt;
+			--Description:  Adds a text field to the gump. This is similar to the t=
ext command,
+			--but the text is cropped to the defined area.
+			-- TODO : HUE
+			elseif ((command =3D=3D &quot;croppedtext&quot;) and (table.getn(bToken)&gt;=3D 7)) =
then
+				local msg =3D HtmlParser( Gumpdata.textline[tonumber(bToken[7])] )
+				local widget =3D guimaker.MakeWrappedClippedText (curparent, bToken[2]=
, bToken[3]+gHorizontal_Textcorrection,
+																bToken[4], bToken[5], UnicodeFix(msg.text), msg.charh, {92=
/255,92/255,178/255,1.0},
+																msg.center, msg.div, gFontNameDefault)
+			--radio &lt;x&gt; &lt;y&gt; &lt;released gumpid&gt; &lt;pressed gumpid&gt; &lt;status&gt; &lt;return-val=
ue&gt;
+			--Description:  Same as Checkbox, but only one Radiobutton can be press=
ed at the same time, except they are per linked via the 'Group' command.
+			-- TODO : make radio buttons work
+			elseif ((command =3D=3D &quot;radio&quot;) and (table.getn(bToken)&gt;=3D 7)) then
+				local radio_x =3D bToken[2]
+				local radio_y =3D bToken[3]
+				local radio_norm =3D bToken[4]
+				local radio_down =3D bToken[5]
+				local radio_state =3D tonumber(bToken[6])
+				local radio_rtn =3D tonumber(bToken[7])
+				local widget
+				if (radio_state=3D=3D0) then
+					widget =3D MakeBorderGumpPart(curparent, radio_norm, radio_x, radio_y)
+				else
+					widget =3D MakeBorderGumpPart(curparent, radio_down, radio_x, radio_y)
+				end
+				widget.state=3Dradio_state
+				widget.returnmsg=3Dradio_rtn
+				widget.mbIgnoreMouseOver =3D false
+				widget.mat_normal 	=3D GetGumpMat(radio_norm)
+				widget.mat_pressed 	=3D GetGumpMat(radio_down)
+
+				table.insert(dialog.uo_radio,widget)
+				widget.onMouseDown	=3D function (widget,mousebutton)
+										if (mousebutton =3D=3D 1) then
+											if (widget.state=3D=3D0) then
+												widget.gfx:SetMaterial(widget.mat_pressed)
+												widget.state=3D1
 											else
-												widget.dialog:Close()
+												widget.gfx:SetMaterial(widget.mat_normal)
+												widget.state=3D0
 											end
-										end
-				--buttontileart &lt;x&gt; &lt;y&gt; &lt;released-id&gt; &lt;pressed-id&gt; &lt;quit&gt; &lt;page-id&gt; &lt;r=
eturn-value&gt; &lt;tilepic-id&gt; &lt;hue&gt; &lt;tile-x&gt; &lt;tile-y&gt;
-				--Client introduced: between 4.0.4d and 5.0.2b
-				--Description:  Adds a button to the gump with the specified coordinat=
es and tilepic as graphic.
-				--				&lt;tile-x&gt; and &lt;tile-y&gt; define the coordinates of the tile graphic=
 and are relative to &lt;x&gt; and &lt;y&gt;.
-				--{ buttontileart 432 248 9010 9010 1 0 33 1352 0 100 20 }
-				elseif ((command =3D=3D &quot;buttontileart&quot;) and (table.getn(bToken)&gt;=3D 1=
2)) then
-					local widget =3D MakeGumpButton (curparent,bToken[4],bToken[4],bToken=
[5],bToken[2],bToken[3])
-					local widgetart =3D MakeArtGumpPart (curparent,bToken[9],bToken[2]+bT=
oken[11],bToken[3]+bToken[12],0,0,0,bToken[10])
-					if (bToken[8]) then widget.returnmsg =3D tonumber(bToken[8]) end
-					widget.page			=3D tonumber(bToken[7])
-					widget.onLeftClick =3D function (widget)
-											if (widget.returnmsg) then
-												print(&quot;Button pressed -&gt; Send buttontileart return_message: &quot;.=
.widget.returnmsg)
-												GumpReturnMsg(Gumpdata.playerid, Gumpdata.dialogId, widget.ret=
urnmsg, ServerSideGump_GetParams(Gumpdata.dialogId))
+											printdebug(&quot;gump&quot;,&quot;RadioButton changed : id=3D&quot;..widget.returnm=
sg..&quot; state=3D&quot;..widget.state)
+										end
+									  end
+			--checkbox &lt;x&gt; &lt;y&gt; &lt;released-id&gt; &lt;pressed-id&gt; &lt;status&gt; &lt;return-value&gt;
+			--Description:  Adds a CheckBox to the gump. Multiple CheckBoxes can be=
 pressed at the same time.
+			--				Check the &lt;return-value&gt; if you want to know which CheckBoxes wer=
e selected.
+			elseif (command =3D=3D &quot;checkbox&quot; and (table.getn(bToken)&gt;=3D 7)) then
+				local check_x =3D bToken[2]
+				local check_y =3D bToken[3]
+				local check_norm =3D bToken[4]
+				local check_down =3D bToken[5]
+				local check_state =3D tonumber(bToken[6])
+				local check_rtn =3D tonumber(bToken[7])
+				local widget
+				if (check_state=3D=3D0) then
+					widget =3D MakeBorderGumpPart(curparent, check_norm, check_x, check_y)
+				else
+					widget =3D MakeBorderGumpPart(curparent, check_down, check_x, check_y)
+				end
+				widget.state=3Dcheck_state
+				widget.returnmsg=3Dcheck_rtn
+				widget.mbIgnoreMouseOver =3D false
+				widget.mat_normal 	=3D GetGumpMat(check_norm)
+				widget.mat_pressed 	=3D GetGumpMat(check_down)
+				table.insert(dialog.uo_check,widget)
+
+				widget.onMouseDown	=3D function (widget,mousebutton)
+										if (mousebutton =3D=3D 1) then
+											if (widget.state=3D=3D0) then
+												widget.gfx:SetMaterial(widget.mat_pressed)
+												widget.state=3D1
+											else
+												widget.gfx:SetMaterial(widget.mat_normal)
+												widget.state=3D0
 											end
-											if (widget.page &gt; 0 and not(widget.page &gt; table.getn(pages)) ) =
then
-												print(&quot;Parsegump Button: Switch to Page &quot;..widget.page..&quot;/&quot;..t=
able.getn(pages))
-												widget.dialog:ShowPage(widget.page)
-											else
-												widget.dialog:Close()
-											end
-										end
-				--textentry &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;hue&gt; &lt;return-value&gt; &lt;default-tex=
t-id&gt;
-				--Description:  Defines an area where the &lt;default-text-id&gt; is display=
ed.
-				--				The player can modify this data. To get this data check the &lt;ret=
urn-value&gt;.
-				--TODO: HUE
-				elseif ((command =3D=3D &quot;textentry&quot;) and (table.getn(bToken)&gt;=3D 8)) t=
hen
-					local widget =3D CreatePlainEditText (curparent, bToken[2], bToken[3]=
, bToken[4], bToken[5], {1.0,1.0,1.0,1.0})
-					local text =3D Gumpdata.textline[tonumber(bToken[8])] or &quot;No textentr=
y&quot;
-					widget:SetText(UnicodeFix(text))
-
-					widget.mbIgnoreMouseOver =3D false
-					widget.returnmsg =3D tonumber(bToken[7])
-					widget.returndefid =3D tonumber(bToken[8])
-					widget.onMouseDown =3D function (widget,mousebutton)
-												if (mousebutton =3D=3D 1) then
-													widget:Activate()
-												end
-										   end
-					widget.onMouseLeave =3D function (widget)
-												widget:Deactivate()
-											end
-					table.insert(dialog.uo_text,widget)
-					=

-				--tilepic &lt;x&gt; &lt;y&gt; &lt;id&gt;
-				--Description:  Adds a Tilepicture to the gump. &lt;id&gt; defines the tile =
graphic-id.
-				elseif ((command =3D=3D &quot;tilepic&quot;) and (table.getn(bToken)&gt;=3D4)) then
-					local widget =3D MakeArtGumpPart (curparent, bToken[4], bToken[2], bT=
oken[3])
-				--TilePicHue &lt;x&gt; &lt;y&gt; &lt;id&gt; &lt;hue&gt;
-				--Description:  Similar to the tilepic command, but with an additional=
 hue parameter.
-				-- TODO : HUE
-				elseif ((command =3D=3D &quot;tilepichue&quot;) and (table.getn(bToken)&gt;=3D5)) t=
hen
-					local widget =3D MakeArtGumpPart (curparent, bToken[4], bToken[2], bT=
oken[3], 0, 0, 0, bToken[5])
-				--croppedtext &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;color&gt; &lt;text-id&gt;
-				--Description:  Adds a text field to the gump. This is similar to the =
text command,
-				--but the text is cropped to the defined area.
-				-- TODO : HUE
-				elseif ((command =3D=3D &quot;croppedtext&quot;) and (table.getn(bToken)&gt;=3D 7))=
 then
-					local msg =3D HtmlParser( Gumpdata.textline[tonumber(bToken[7])] )
-					local widget =3D guimaker.MakeWrappedClippedText (curparent, bToken[2=
], bToken[3]+gHorizontal_Textcorrection,
-																	bToken[4], bToken[5], UnicodeFix(msg.text), msg.charh, {9=
2/255,92/255,178/255,1.0},
-																	msg.center, msg.div, gFontNameDefault)
-				--radio &lt;x&gt; &lt;y&gt; &lt;released gumpid&gt; &lt;pressed gumpid&gt; &lt;status&gt; &lt;return-va=
lue&gt;
-				--Description:  Same as Checkbox, but only one Radiobutton can be pres=
sed at the same time, except they are per linked via the 'Group' command.
-				-- TODO : make radio buttons work
-				elseif ((command =3D=3D &quot;radio&quot;) and (table.getn(bToken)&gt;=3D 7)) then
-					local radio_x =3D bToken[2]
-					local radio_y =3D bToken[3]
-					local radio_norm =3D bToken[4]
-					local radio_down =3D bToken[5]
-					local radio_state =3D tonumber(bToken[6])
-					local radio_rtn =3D tonumber(bToken[7])
-					local widget
-					if (radio_state=3D=3D0) then
-						widget =3D MakeBorderGumpPart(curparent, radio_norm, radio_x, radio_=
y)
-					else
-						widget =3D MakeBorderGumpPart(curparent, radio_down, radio_x, radio_=
y)
-					end
-					widget.state=3Dradio_state
-					widget.returnmsg=3Dradio_rtn
-					widget.mbIgnoreMouseOver =3D false
-					widget.mat_normal 	=3D GetGumpMat(radio_norm)
-					widget.mat_pressed 	=3D GetGumpMat(radio_down)
-
-					table.insert(dialog.uo_radio,widget)
-					widget.onMouseDown	=3D function (widget,mousebutton)
-											if (mousebutton =3D=3D 1) then
-												if (widget.state=3D=3D0) then
-													widget.gfx:SetMaterial(widget.mat_pressed)
-													widget.state=3D1
-												else
-													widget.gfx:SetMaterial(widget.mat_normal)
-													widget.state=3D0
-												end
-												print(&quot;RadioButton changed : id=3D&quot;..widget.returnmsg..&quot; state=
=3D&quot;..widget.state)
-											end
-										  end
-				--checkbox &lt;x&gt; &lt;y&gt; &lt;released-id&gt; &lt;pressed-id&gt; &lt;status&gt; &lt;return-value&gt;
-				--Description:  Adds a CheckBox to the gump. Multiple CheckBoxes can b=
e pressed at the same time.
-				--				Check the &lt;return-value&gt; if you want to know which CheckBoxes we=
re selected.
-				elseif (command =3D=3D &quot;checkbox&quot; and (table.getn(bToken)&gt;=3D 7)) then
-					local check_x =3D bToken[2]
-					local check_y =3D bToken[3]
-					local check_norm =3D bToken[4]
-					local check_down =3D bToken[5]
-					local check_state =3D tonumber(bToken[6])
-					local check_rtn =3D tonumber(bToken[7])
-					local widget
-					if (check_state=3D=3D0) then
-						widget =3D MakeBorderGumpPart(curparent, check_norm, check_x, check_=
y)
-					else
-						widget =3D MakeBorderGumpPart(curparent, check_down, check_x, check_=
y)
-					end
-					widget.state=3Dcheck_state
-					widget.returnmsg=3Dcheck_rtn
-					widget.mbIgnoreMouseOver =3D false
-					widget.mat_normal 	=3D GetGumpMat(check_norm)
-					widget.mat_pressed 	=3D GetGumpMat(check_down)
-					table.insert(dialog.uo_check,widget)
-
-					widget.onMouseDown	=3D function (widget,mousebutton)
-											if (mousebutton =3D=3D 1) then
-												if (widget.state=3D=3D0) then
-													widget.gfx:SetMaterial(widget.mat_pressed)
-													widget.state=3D1
-												else
-													widget.gfx:SetMaterial(widget.mat_normal)
-													widget.state=3D0
-												end
-												print(&quot;Checkbox changed : id=3D&quot;..widget.returnmsg..&quot; state=3D=
&quot;..widget.state)
-											end
-										  end
-				--HtmlGump &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;text-id&gt; &lt;background&gt; &lt;scrollbar&gt;
-				--Description:  Defines a text-area where Html-commands are allowed.
-				--				&lt;background&gt; and &lt;scrollbar&gt; can be 0 or 1 and define whether th=
e background is transparent and a scrollbar is displayed.
-				--{ htmlgump 10 8 100 20 0 0 0 }
-				elseif ((command =3D=3D &quot;htmlgump&quot;) and (table.getn(bToken)&gt;=3D 8)) th=
en
-					local msg =3D HtmlParser( Gumpdata.textline[tonumber(bToken[6])] )
-					local widget =3D guimaker.MakeWrappedClippedText (curparent, bToken[2=
], bToken[3]+gHorizontal_Textcorrection,
-																	bToken[4], bToken[5], msg.text, msg.charh, {1.0,1.0,1.0,1=
.0},
-																	msg.center, msg.div, gFontNameDefault)
-				--tooltip &lt;cliloc-nr&gt;
-				--Description:  Adds to the previous layoutarray entry a Tooltip with =
the in [cliloc-nr] defined Cliloc entry.
-				-- TODO : display tooltip
-				elseif ((command =3D=3D &quot;tooltip&quot;) and (table.getn(bToken)&gt;=3D 2)) then
-					local msg =3D HtmlParser( gClilocLoader and gClilocLoader:Get(bToken[=
2]) or &quot;no_cliloc&quot; )
-					AddFadeLines(&quot;HtmlGumpparser - tooltip (TODO):&quot;..msg.text)
-				else
-					print(&quot;UNKNOWN Generic Gump Command: &quot;..command)
-				end
-
-			end
+											printdebug(&quot;gump&quot;,&quot;Checkbox changed : id=3D&quot;..widget.returnmsg.=
.&quot; state=3D&quot;..widget.state)
+										end
+									  end
+			--HtmlGump &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;text-id&gt; &lt;background&gt; &lt;scrollbar&gt;
+			--Description:  Defines a text-area where Html-commands are allowed.
+			--				&lt;background&gt; and &lt;scrollbar&gt; can be 0 or 1 and define whether the=
 background is transparent and a scrollbar is displayed.
+			--{ htmlgump 10 8 100 20 0 0 0 }
+			elseif ((command =3D=3D &quot;htmlgump&quot;) and (table.getn(bToken)&gt;=3D 8)) then
+				local msg =3D HtmlParser( Gumpdata.textline[tonumber(bToken[6])] )
+				local widget =3D guimaker.MakeWrappedClippedText (curparent, bToken[2]=
, bToken[3]+gHorizontal_Textcorrection,
+																bToken[4], bToken[5], msg.text, msg.charh, {1.0,1.0,1.0,1.=
0},
+																msg.center, msg.div, gFontNameDefault)
+			--tooltip &lt;cliloc-nr&gt;
+			--Description:  Adds to the previous layoutarray entry a Tooltip with t=
he in [cliloc-nr] defined Cliloc entry.
+			-- TODO : display tooltip
+			elseif ((command =3D=3D &quot;tooltip&quot;) and (table.getn(bToken)&gt;=3D 2)) then
+				local msg =3D HtmlParser( gClilocLoader and gClilocLoader:Get(bToken[2=
]) or &quot;no_cliloc&quot; )
+				AddFadeLines(&quot;HtmlGumpparser - tooltip (TODO):&quot;..msg.text)
+			else
+				printdebug(&quot;gump&quot;,&quot;UNKNOWN Generic Gump Command: &quot;..command)
+			end
+		end
 			=

-			-- add all newly created widgets to current page
-			local myc =3D 0
-			for k,widget in pairs(dialog.childs) do =

-				if (not widget.pagenum) then
-					myc =3D myc + 1
-					widget.pagenum =3D page.pagenum
-					table.insert(page.pagewidgets,widget)
-				end
-			end
-			printdebug(&quot;gump&quot;,&quot;ServerSideGump page &quot;,page.pagenum,&quot; childs: &quot;,myc)
-		end
-		=

-		-- hide all except page 0 and 1
-		dialog:ShowPage(1)
-		=

-	end -- endif gGumpLoader
+		-- add all newly created widgets to current page
+		local myc =3D 0
+		for k,widget in pairs(dialog.childs) do =

+			if (not widget.pagenum) then
+				myc =3D myc + 1
+				widget.pagenum =3D page.pagenum
+				table.insert(page.pagewidgets,widget)
+			end
+		end
+		printdebug(&quot;gump&quot;,&quot;ServerSideGump page &quot;,page.pagenum,&quot; childs: &quot;,myc)
+	end
+
+	gServerSideGump[Gumpdata.dialogId] =3D dialog
+
+	-- hide all except page 0 and 1
+	dialog:ShowPage(1)
 	=

 	-- TODO : set correct Alpha Value
 	--SetDialogAlpha(dialog, 1.0)
-	return dialog
 end
 =

 --[[
@@ -466,21 +472,21 @@
 	--parse tokens
 	for z=3D1, table.getn(bToken) do
 		local command =3D string.lower(bToken[z])
-		--print(command)
+--		printdebug(&quot;gump&quot;,command)
 =

 		if (command =3D=3D &quot;basefont&quot;) then
 			if (table.getn(bToken)&gt;=3D z+2) then
 				if (string.lower(bToken[z+1])=3D=3D&quot;color&quot;) then
 					--could be a hex value &quot;msg_hue: 0xFFFFFF&quot; or a colorname like &quot;msg_h=
ue: 0xYELLOW&quot;
 					msg.hue =3D &quot;0x&quot;..bToken[z+2]
---					print(&quot;basefont msg.hue=3D&quot;..msg.hue)
+--					printdebug(&quot;gump&quot;,&quot;basefont msg.hue=3D&quot;..msg.hue)
 					z=3Dz+2
 				end
 			end
 			if (table.getn(bToken)&gt;=3D z+2) then
 				if (string.lower(bToken[z+1])=3D=3D&quot;size&quot;) then
 					msg.charh =3D msg.charh+bToken[z+2]
---					print(&quot;basefont msg.charh=3D&quot;..msg.charh)
+--					printdebug(&quot;gump&quot;,&quot;basefont msg.charh=3D&quot;..msg.charh)
 					z=3Dz+2
 				end
 			end
@@ -526,6 +532,6 @@
 		end
 	end
 =

---	print(&quot;formated-html-string: &quot;..msg.text)
+--	printdebug(&quot;gump&quot;,&quot;formated-html-string: &quot;..msg.text)
 	return msg
 end

Modified: trunk/lua/lib.uodragdrop.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/lua/lib.uodragdrop.lua (original)
+++ trunk/lua/lib.uodragdrop.lua Thu Feb 14 00:09:30 2008
@@ -257,7 +257,7 @@
 function DestroyDragDropItemBySerial (serial)
 	if (gDragDrop and gDragDrop.item.serial =3D=3D serial) then
 		gDragDrop.bItemDestroyed =3D true
-		gDragDrop.widget =3D false		=

+		gDragDrop.widget =3D nil		=

 		-- item is kept &quot;on the cursor&quot; even if it was removed from inventory af=
ter Send_Take_Object()
 	end
 end

Modified: trunk/lua/net/net.mobile.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/lua/net/net.mobile.lua (original)
+++ trunk/lua/net/net.mobile.lua Thu Feb 14 00:09:30 2008
@@ -292,5 +292,9 @@
 	local input =3D GetRecvFIFO()
 	local id =3D input:PopNetUint8()
 	local action =3D input:PopNetUint8()
+
+	-- &gt; BandagePacket ( BandagePacket.cs ) ??????	=

+	--local item_serial =3D input:PopNetUint32()		-- use item on target mobile
+	--local mobile_target =3D input:PopNetUint32()
 	printdebug(&quot;mobile&quot;,sprintf(&quot;NET: kPacket_Death: player is now (2=3Dghost=
, 1=3Dresurrect, 0=3Dfrom server)=3D%i\n&quot;,action))
 end

Modified: trunk/lua/net/net.other.lua
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D
--- trunk/lua/net/net.other.lua (original)
+++ trunk/lua/net/net.other.lua Thu Feb 14 00:09:30 2008
@@ -633,16 +633,17 @@
 =

 	for k,v in pairs(newgump) do printdebug(&quot;gump&quot;,sprintf(&quot;newgump.%s =3D &quot;,=
k),v) end
 	=

-	local totaltext =3D &quot;&quot;
+--	local totaltext =3D &quot;&quot;
+	local textlen =3D 0
 	newgump.textline =3D {}
 	--Index 0 because Serverside Gump Commands use this Index as textline ref=
erences
 	for i =3D 0,newgump.numTextLines-1 do
-		local textlen =3D input:PopNetUint16()
+		textlen =3D input:PopNetUint16()
 		printdebug(&quot;gump&quot;,&quot;reading text line &quot;,i,&quot; with length &quot;,textlen)
 		newgump.textline[i] =3D input:PopUnicodeString(textlen) -- warning, data=
 is sent as unicode, we only interpret the asci part at the moment
 		-- TODO : maybe textlen / 2 ?
 		printdebug(&quot;gump&quot;,sprintf(&quot;newgump.textline[%d](len=3D%d)=3D\n&quot;,i,textle=
n),newgump.textline[i])
-		totaltext =3D totaltext .. &quot;\n&quot; .. newgump.textline[i]
+--		totaltext =3D totaltext .. &quot;\n&quot; .. newgump.textline[i]
 	end
 =

 	GumpParser(newgump)
@@ -699,16 +700,17 @@
 		-- print gumpdata
 		for k,v in pairs(newgump) do printdebug(&quot;gump&quot;,sprintf(&quot;newgump.%s =3D &quot;=
,k),v) end
 		=

-		local totaltext =3D &quot;&quot;
+--		local totaltext =3D &quot;&quot;
+		local textlen =3D 0
 		newgump.textline =3D {}
 		--Index 0 because Serverside Gump Commands use this Index as textline re=
ferences
 		for i =3D 0,newgump.numTextLines-1 do
-			local textlen =3D decompressed:PopNetUint16()
+			textlen =3D decompressed:PopNetUint16()
 			printdebug(&quot;gump&quot;,&quot;reading text line &quot;,i,&quot; with length &quot;,textlen)
 			newgump.textline[i] =3D decompressed:PopUnicodeString(textlen) -- warni=
ng, data is sent as unicode, we only interpret the asci part at the moment
 			-- TODO : maybe textlen / 2 ?
 			printdebug(&quot;gump&quot;,sprintf(&quot;newgump.textline[%d](len=3D%d)=3D\n&quot;,i,textl=
en),newgump.textline[i])
-			totaltext =3D totaltext .. &quot;\n&quot; .. newgump.textline[i]
+--			totaltext =3D totaltext .. &quot;\n&quot; .. newgump.textline[i]
 		end
 	end
 =



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000715.html">[Iris-commit] [IRIS] r1903 - in /trunk: data/config.lua.dist lua/lib.3d.map.lua lua/lib.terrain.multitex.lua
</A></li>
	<LI>Next message: <A HREF="000717.html">[Iris-commit] [IRIS] r1905 - in /trunk: data/ data/guis/naked/ lua/
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#716">[ date ]</a>
              <a href="thread.html#716">[ thread ]</a>
              <a href="subject.html#716">[ subject ]</a>
              <a href="author.html#716">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/iris-commit">More information about the Iris-commit
mailing list</a><br>
</body></html>
